# MIT License
#
# Copyright (c) 2021-2025 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


# This file has been autogenerated, do not modify.


"""
(No short description)

Attributes:
    bsrsv2Info_t:
        alias of `~.bsrsv2Info`

    bsrsm2Info_t:
        alias of `~.bsrsm2Info`

    bsrilu02Info_t:
        alias of `~.bsrilu02Info`

    bsric02Info_t:
        alias of `~.bsric02Info`

    csrsv2Info_t:
        alias of `~.csrsv2Info`

    csrsm2Info_t:
        alias of `~.csrsm2Info`

    csrilu02Info_t:
        alias of `~.csrilu02Info`

    csric02Info_t:
        alias of `~.csric02Info`

    csrgemm2Info_t:
        alias of `~.csrgemm2Info`

    pruneInfo_t:
        alias of `~.pruneInfo`

    csru2csrInfo_t:
        alias of `~.csru2csrInfo`

    hipsparseSpGEMMDescr_t:
        alias of `~.hipsparseSpGEMMDescr`

    hipsparseSpSVDescr_t:
        alias of `~.hipsparseSpSVDescr`

    hipsparseSpSMDescr_t:
        alias of `~.hipsparseSpSMDescr`

"""

import cython
import ctypes
import enum
from .hip import hipError_t, _hipDataType__Base # PY import enums
cdef class bsrsv2Info(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.bsrsv2Info.

    Python wrapper for cdef class chipsparse.bsrsv2Info.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.bsrsv2Info* getElementPtr(self):
        return <chipsparse.bsrsv2Info*>self._ptr

    @staticmethod
    cdef bsrsv2Info fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``bsrsv2Info`` objects from
        given ``chipsparse.bsrsv2Info`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef bsrsv2Info wrapper = bsrsv2Info.__new__(bsrsv2Info)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a bsrsv2Info from a Python object.

        Derives a bsrsv2Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``bsrsv2Info`` reference, this method
        returns it directly. No new ``bsrsv2Info`` is created in this case.
        """
        return bsrsv2Info.fromPyobj(pyobj)

    @staticmethod
    cdef bsrsv2Info fromPyobj(object pyobj):
        """Creates a bsrsv2Info from a Python object.

        Derives a bsrsv2Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``bsrsv2Info`` reference, this method
        returns it directly. No new ``bsrsv2Info`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `bsrsv2Info`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of bsrsv2Info!
        """
        cdef bsrsv2Info wrapper

        if isinstance(pyobj,bsrsv2Info):
            return pyobj
        else:
            wrapper = bsrsv2Info.__new__(bsrsv2Info)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<bsrsv2Info object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class bsrsm2Info(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.bsrsm2Info.

    Python wrapper for cdef class chipsparse.bsrsm2Info.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.bsrsm2Info* getElementPtr(self):
        return <chipsparse.bsrsm2Info*>self._ptr

    @staticmethod
    cdef bsrsm2Info fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``bsrsm2Info`` objects from
        given ``chipsparse.bsrsm2Info`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef bsrsm2Info wrapper = bsrsm2Info.__new__(bsrsm2Info)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a bsrsm2Info from a Python object.

        Derives a bsrsm2Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``bsrsm2Info`` reference, this method
        returns it directly. No new ``bsrsm2Info`` is created in this case.
        """
        return bsrsm2Info.fromPyobj(pyobj)

    @staticmethod
    cdef bsrsm2Info fromPyobj(object pyobj):
        """Creates a bsrsm2Info from a Python object.

        Derives a bsrsm2Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``bsrsm2Info`` reference, this method
        returns it directly. No new ``bsrsm2Info`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `bsrsm2Info`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of bsrsm2Info!
        """
        cdef bsrsm2Info wrapper

        if isinstance(pyobj,bsrsm2Info):
            return pyobj
        else:
            wrapper = bsrsm2Info.__new__(bsrsm2Info)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<bsrsm2Info object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class bsrilu02Info(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.bsrilu02Info.

    Python wrapper for cdef class chipsparse.bsrilu02Info.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.bsrilu02Info* getElementPtr(self):
        return <chipsparse.bsrilu02Info*>self._ptr

    @staticmethod
    cdef bsrilu02Info fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``bsrilu02Info`` objects from
        given ``chipsparse.bsrilu02Info`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef bsrilu02Info wrapper = bsrilu02Info.__new__(bsrilu02Info)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a bsrilu02Info from a Python object.

        Derives a bsrilu02Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``bsrilu02Info`` reference, this method
        returns it directly. No new ``bsrilu02Info`` is created in this case.
        """
        return bsrilu02Info.fromPyobj(pyobj)

    @staticmethod
    cdef bsrilu02Info fromPyobj(object pyobj):
        """Creates a bsrilu02Info from a Python object.

        Derives a bsrilu02Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``bsrilu02Info`` reference, this method
        returns it directly. No new ``bsrilu02Info`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `bsrilu02Info`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of bsrilu02Info!
        """
        cdef bsrilu02Info wrapper

        if isinstance(pyobj,bsrilu02Info):
            return pyobj
        else:
            wrapper = bsrilu02Info.__new__(bsrilu02Info)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<bsrilu02Info object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class bsric02Info(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.bsric02Info.

    Python wrapper for cdef class chipsparse.bsric02Info.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.bsric02Info* getElementPtr(self):
        return <chipsparse.bsric02Info*>self._ptr

    @staticmethod
    cdef bsric02Info fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``bsric02Info`` objects from
        given ``chipsparse.bsric02Info`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef bsric02Info wrapper = bsric02Info.__new__(bsric02Info)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a bsric02Info from a Python object.

        Derives a bsric02Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``bsric02Info`` reference, this method
        returns it directly. No new ``bsric02Info`` is created in this case.
        """
        return bsric02Info.fromPyobj(pyobj)

    @staticmethod
    cdef bsric02Info fromPyobj(object pyobj):
        """Creates a bsric02Info from a Python object.

        Derives a bsric02Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``bsric02Info`` reference, this method
        returns it directly. No new ``bsric02Info`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `bsric02Info`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of bsric02Info!
        """
        cdef bsric02Info wrapper

        if isinstance(pyobj,bsric02Info):
            return pyobj
        else:
            wrapper = bsric02Info.__new__(bsric02Info)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<bsric02Info object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class csrsv2Info(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.csrsv2Info.

    Python wrapper for cdef class chipsparse.csrsv2Info.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.csrsv2Info* getElementPtr(self):
        return <chipsparse.csrsv2Info*>self._ptr

    @staticmethod
    cdef csrsv2Info fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``csrsv2Info`` objects from
        given ``chipsparse.csrsv2Info`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef csrsv2Info wrapper = csrsv2Info.__new__(csrsv2Info)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a csrsv2Info from a Python object.

        Derives a csrsv2Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csrsv2Info`` reference, this method
        returns it directly. No new ``csrsv2Info`` is created in this case.
        """
        return csrsv2Info.fromPyobj(pyobj)

    @staticmethod
    cdef csrsv2Info fromPyobj(object pyobj):
        """Creates a csrsv2Info from a Python object.

        Derives a csrsv2Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csrsv2Info`` reference, this method
        returns it directly. No new ``csrsv2Info`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `csrsv2Info`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of csrsv2Info!
        """
        cdef csrsv2Info wrapper

        if isinstance(pyobj,csrsv2Info):
            return pyobj
        else:
            wrapper = csrsv2Info.__new__(csrsv2Info)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<csrsv2Info object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class csrsm2Info(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.csrsm2Info.

    Python wrapper for cdef class chipsparse.csrsm2Info.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.csrsm2Info* getElementPtr(self):
        return <chipsparse.csrsm2Info*>self._ptr

    @staticmethod
    cdef csrsm2Info fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``csrsm2Info`` objects from
        given ``chipsparse.csrsm2Info`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef csrsm2Info wrapper = csrsm2Info.__new__(csrsm2Info)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a csrsm2Info from a Python object.

        Derives a csrsm2Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csrsm2Info`` reference, this method
        returns it directly. No new ``csrsm2Info`` is created in this case.
        """
        return csrsm2Info.fromPyobj(pyobj)

    @staticmethod
    cdef csrsm2Info fromPyobj(object pyobj):
        """Creates a csrsm2Info from a Python object.

        Derives a csrsm2Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csrsm2Info`` reference, this method
        returns it directly. No new ``csrsm2Info`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `csrsm2Info`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of csrsm2Info!
        """
        cdef csrsm2Info wrapper

        if isinstance(pyobj,csrsm2Info):
            return pyobj
        else:
            wrapper = csrsm2Info.__new__(csrsm2Info)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<csrsm2Info object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class csrilu02Info(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.csrilu02Info.

    Python wrapper for cdef class chipsparse.csrilu02Info.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.csrilu02Info* getElementPtr(self):
        return <chipsparse.csrilu02Info*>self._ptr

    @staticmethod
    cdef csrilu02Info fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``csrilu02Info`` objects from
        given ``chipsparse.csrilu02Info`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef csrilu02Info wrapper = csrilu02Info.__new__(csrilu02Info)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a csrilu02Info from a Python object.

        Derives a csrilu02Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csrilu02Info`` reference, this method
        returns it directly. No new ``csrilu02Info`` is created in this case.
        """
        return csrilu02Info.fromPyobj(pyobj)

    @staticmethod
    cdef csrilu02Info fromPyobj(object pyobj):
        """Creates a csrilu02Info from a Python object.

        Derives a csrilu02Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csrilu02Info`` reference, this method
        returns it directly. No new ``csrilu02Info`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `csrilu02Info`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of csrilu02Info!
        """
        cdef csrilu02Info wrapper

        if isinstance(pyobj,csrilu02Info):
            return pyobj
        else:
            wrapper = csrilu02Info.__new__(csrilu02Info)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<csrilu02Info object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class csric02Info(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.csric02Info.

    Python wrapper for cdef class chipsparse.csric02Info.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.csric02Info* getElementPtr(self):
        return <chipsparse.csric02Info*>self._ptr

    @staticmethod
    cdef csric02Info fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``csric02Info`` objects from
        given ``chipsparse.csric02Info`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef csric02Info wrapper = csric02Info.__new__(csric02Info)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a csric02Info from a Python object.

        Derives a csric02Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csric02Info`` reference, this method
        returns it directly. No new ``csric02Info`` is created in this case.
        """
        return csric02Info.fromPyobj(pyobj)

    @staticmethod
    cdef csric02Info fromPyobj(object pyobj):
        """Creates a csric02Info from a Python object.

        Derives a csric02Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csric02Info`` reference, this method
        returns it directly. No new ``csric02Info`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `csric02Info`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of csric02Info!
        """
        cdef csric02Info wrapper

        if isinstance(pyobj,csric02Info):
            return pyobj
        else:
            wrapper = csric02Info.__new__(csric02Info)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<csric02Info object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class csrgemm2Info(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.csrgemm2Info.

    Python wrapper for cdef class chipsparse.csrgemm2Info.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.csrgemm2Info* getElementPtr(self):
        return <chipsparse.csrgemm2Info*>self._ptr

    @staticmethod
    cdef csrgemm2Info fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``csrgemm2Info`` objects from
        given ``chipsparse.csrgemm2Info`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef csrgemm2Info wrapper = csrgemm2Info.__new__(csrgemm2Info)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a csrgemm2Info from a Python object.

        Derives a csrgemm2Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csrgemm2Info`` reference, this method
        returns it directly. No new ``csrgemm2Info`` is created in this case.
        """
        return csrgemm2Info.fromPyobj(pyobj)

    @staticmethod
    cdef csrgemm2Info fromPyobj(object pyobj):
        """Creates a csrgemm2Info from a Python object.

        Derives a csrgemm2Info from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csrgemm2Info`` reference, this method
        returns it directly. No new ``csrgemm2Info`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `csrgemm2Info`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of csrgemm2Info!
        """
        cdef csrgemm2Info wrapper

        if isinstance(pyobj,csrgemm2Info):
            return pyobj
        else:
            wrapper = csrgemm2Info.__new__(csrgemm2Info)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<csrgemm2Info object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class pruneInfo(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.pruneInfo.

    Python wrapper for cdef class chipsparse.pruneInfo.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.pruneInfo* getElementPtr(self):
        return <chipsparse.pruneInfo*>self._ptr

    @staticmethod
    cdef pruneInfo fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``pruneInfo`` objects from
        given ``chipsparse.pruneInfo`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef pruneInfo wrapper = pruneInfo.__new__(pruneInfo)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a pruneInfo from a Python object.

        Derives a pruneInfo from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``pruneInfo`` reference, this method
        returns it directly. No new ``pruneInfo`` is created in this case.
        """
        return pruneInfo.fromPyobj(pyobj)

    @staticmethod
    cdef pruneInfo fromPyobj(object pyobj):
        """Creates a pruneInfo from a Python object.

        Derives a pruneInfo from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``pruneInfo`` reference, this method
        returns it directly. No new ``pruneInfo`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `pruneInfo`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of pruneInfo!
        """
        cdef pruneInfo wrapper

        if isinstance(pyobj,pruneInfo):
            return pyobj
        else:
            wrapper = pruneInfo.__new__(pruneInfo)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<pruneInfo object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class csru2csrInfo(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.csru2csrInfo.

    Python wrapper for cdef class chipsparse.csru2csrInfo.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.csru2csrInfo* getElementPtr(self):
        return <chipsparse.csru2csrInfo*>self._ptr

    @staticmethod
    cdef csru2csrInfo fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``csru2csrInfo`` objects from
        given ``chipsparse.csru2csrInfo`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef csru2csrInfo wrapper = csru2csrInfo.__new__(csru2csrInfo)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a csru2csrInfo from a Python object.

        Derives a csru2csrInfo from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csru2csrInfo`` reference, this method
        returns it directly. No new ``csru2csrInfo`` is created in this case.
        """
        return csru2csrInfo.fromPyobj(pyobj)

    @staticmethod
    cdef csru2csrInfo fromPyobj(object pyobj):
        """Creates a csru2csrInfo from a Python object.

        Derives a csru2csrInfo from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``csru2csrInfo`` reference, this method
        returns it directly. No new ``csru2csrInfo`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `csru2csrInfo`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of csru2csrInfo!
        """
        cdef csru2csrInfo wrapper

        if isinstance(pyobj,csru2csrInfo):
            return pyobj
        else:
            wrapper = csru2csrInfo.__new__(csru2csrInfo)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<csru2csrInfo object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


bsrsv2Info_t = bsrsv2Info

bsrsm2Info_t = bsrsm2Info

bsrilu02Info_t = bsrilu02Info

bsric02Info_t = bsric02Info

csrsv2Info_t = csrsv2Info

csrsm2Info_t = csrsm2Info

csrilu02Info_t = csrilu02Info

csric02Info_t = csric02Info

csrgemm2Info_t = csrgemm2Info

pruneInfo_t = pruneInfo

csru2csrInfo_t = csru2csrInfo

class _hipsparseStatus_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseStatus_t(_hipsparseStatus_t__Base):
    """hipsparseStatus_t

    Attributes:
        HIPSPARSE_STATUS_SUCCESS:
            Function succeeds
        HIPSPARSE_STATUS_NOT_INITIALIZED:
            hipSPARSE was not initialized
        HIPSPARSE_STATUS_ALLOC_FAILED:
            Resource allocation failed
        HIPSPARSE_STATUS_INVALID_VALUE:
            Unsupported value was passed to the function
        HIPSPARSE_STATUS_ARCH_MISMATCH:
            Device architecture not supported
        HIPSPARSE_STATUS_MAPPING_ERROR:
            Access to GPU memory space failed
        HIPSPARSE_STATUS_EXECUTION_FAILED:
            GPU program failed to execute
        HIPSPARSE_STATUS_INTERNAL_ERROR:
            An internal hipSPARSE operation failed
        HIPSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED:
            Matrix type not supported
        HIPSPARSE_STATUS_ZERO_PIVOT:
            Zero pivot was computed
        HIPSPARSE_STATUS_NOT_SUPPORTED:
            Operation is not supported
        HIPSPARSE_STATUS_INSUFFICIENT_RESOURCES:
            Resources are insufficient
    """
    HIPSPARSE_STATUS_SUCCESS = chipsparse.HIPSPARSE_STATUS_SUCCESS
    HIPSPARSE_STATUS_NOT_INITIALIZED = chipsparse.HIPSPARSE_STATUS_NOT_INITIALIZED
    HIPSPARSE_STATUS_ALLOC_FAILED = chipsparse.HIPSPARSE_STATUS_ALLOC_FAILED
    HIPSPARSE_STATUS_INVALID_VALUE = chipsparse.HIPSPARSE_STATUS_INVALID_VALUE
    HIPSPARSE_STATUS_ARCH_MISMATCH = chipsparse.HIPSPARSE_STATUS_ARCH_MISMATCH
    HIPSPARSE_STATUS_MAPPING_ERROR = chipsparse.HIPSPARSE_STATUS_MAPPING_ERROR
    HIPSPARSE_STATUS_EXECUTION_FAILED = chipsparse.HIPSPARSE_STATUS_EXECUTION_FAILED
    HIPSPARSE_STATUS_INTERNAL_ERROR = chipsparse.HIPSPARSE_STATUS_INTERNAL_ERROR
    HIPSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED = chipsparse.HIPSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED
    HIPSPARSE_STATUS_ZERO_PIVOT = chipsparse.HIPSPARSE_STATUS_ZERO_PIVOT
    HIPSPARSE_STATUS_NOT_SUPPORTED = chipsparse.HIPSPARSE_STATUS_NOT_SUPPORTED
    HIPSPARSE_STATUS_INSUFFICIENT_RESOURCES = chipsparse.HIPSPARSE_STATUS_INSUFFICIENT_RESOURCES
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparsePointerMode_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparsePointerMode_t(_hipsparsePointerMode_t__Base):
    """Indicates if the pointer is device pointer or host pointer.

    Attributes:
        HIPSPARSE_POINTER_MODE_HOST:
            Scalar pointers are in host memory
        HIPSPARSE_POINTER_MODE_DEVICE:
            Scalar pointers are in device memory
    """
    HIPSPARSE_POINTER_MODE_HOST = chipsparse.HIPSPARSE_POINTER_MODE_HOST
    HIPSPARSE_POINTER_MODE_DEVICE = chipsparse.HIPSPARSE_POINTER_MODE_DEVICE
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseAction_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseAction_t(_hipsparseAction_t__Base):
    """Specify where the operation is performed on.

    Attributes:
        HIPSPARSE_ACTION_SYMBOLIC:
            Operate only on indices
        HIPSPARSE_ACTION_NUMERIC:
            Operate on data and indices
    """
    HIPSPARSE_ACTION_SYMBOLIC = chipsparse.HIPSPARSE_ACTION_SYMBOLIC
    HIPSPARSE_ACTION_NUMERIC = chipsparse.HIPSPARSE_ACTION_NUMERIC
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseMatrixType_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseMatrixType_t(_hipsparseMatrixType_t__Base):
    """Specify the matrix type.

    Attributes:
        HIPSPARSE_MATRIX_TYPE_GENERAL:
            General matrix type
        HIPSPARSE_MATRIX_TYPE_SYMMETRIC:
            Symmetric matrix type
        HIPSPARSE_MATRIX_TYPE_HERMITIAN:
            Hermitian matrix type
        HIPSPARSE_MATRIX_TYPE_TRIANGULAR:
            Triangular matrix type
    """
    HIPSPARSE_MATRIX_TYPE_GENERAL = chipsparse.HIPSPARSE_MATRIX_TYPE_GENERAL
    HIPSPARSE_MATRIX_TYPE_SYMMETRIC = chipsparse.HIPSPARSE_MATRIX_TYPE_SYMMETRIC
    HIPSPARSE_MATRIX_TYPE_HERMITIAN = chipsparse.HIPSPARSE_MATRIX_TYPE_HERMITIAN
    HIPSPARSE_MATRIX_TYPE_TRIANGULAR = chipsparse.HIPSPARSE_MATRIX_TYPE_TRIANGULAR
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseFillMode_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseFillMode_t(_hipsparseFillMode_t__Base):
    """Specify the matrix fill mode.

    Attributes:
        HIPSPARSE_FILL_MODE_LOWER:
            Lower triangular part is stored
        HIPSPARSE_FILL_MODE_UPPER:
            Upper triangular part is stored
    """
    HIPSPARSE_FILL_MODE_LOWER = chipsparse.HIPSPARSE_FILL_MODE_LOWER
    HIPSPARSE_FILL_MODE_UPPER = chipsparse.HIPSPARSE_FILL_MODE_UPPER
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseDiagType_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseDiagType_t(_hipsparseDiagType_t__Base):
    """Indicates if the diagonal entries are unity.

    Attributes:
        HIPSPARSE_DIAG_TYPE_NON_UNIT:
            Diagonal entries are non-unity
        HIPSPARSE_DIAG_TYPE_UNIT:
            Diagonal entries are unity
    """
    HIPSPARSE_DIAG_TYPE_NON_UNIT = chipsparse.HIPSPARSE_DIAG_TYPE_NON_UNIT
    HIPSPARSE_DIAG_TYPE_UNIT = chipsparse.HIPSPARSE_DIAG_TYPE_UNIT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseIndexBase_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseIndexBase_t(_hipsparseIndexBase_t__Base):
    """Specify the matrix index base.

    Attributes:
        HIPSPARSE_INDEX_BASE_ZERO:
            Zero based indexing
        HIPSPARSE_INDEX_BASE_ONE:
            One based indexing
    """
    HIPSPARSE_INDEX_BASE_ZERO = chipsparse.HIPSPARSE_INDEX_BASE_ZERO
    HIPSPARSE_INDEX_BASE_ONE = chipsparse.HIPSPARSE_INDEX_BASE_ONE
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseOperation_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseOperation_t(_hipsparseOperation_t__Base):
    """Specify whether the matrix is to be transposed or not.

    Attributes:
        HIPSPARSE_OPERATION_NON_TRANSPOSE:
            Operate with matrix
        HIPSPARSE_OPERATION_TRANSPOSE:
            Operate with transpose
        HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE:
            Operate with conj. transpose
    """
    HIPSPARSE_OPERATION_NON_TRANSPOSE = chipsparse.HIPSPARSE_OPERATION_NON_TRANSPOSE
    HIPSPARSE_OPERATION_TRANSPOSE = chipsparse.HIPSPARSE_OPERATION_TRANSPOSE
    HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE = chipsparse.HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseHybPartition_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseHybPartition_t(_hipsparseHybPartition_t__Base):
    """HYB matrix partitioning type.

    Attributes:
        HIPSPARSE_HYB_PARTITION_AUTO:
            Automatically decide on ELL nnz per row
        HIPSPARSE_HYB_PARTITION_USER:
            User given ELL nnz per row
        HIPSPARSE_HYB_PARTITION_MAX:
            Max ELL nnz per row, no COO part
    """
    HIPSPARSE_HYB_PARTITION_AUTO = chipsparse.HIPSPARSE_HYB_PARTITION_AUTO
    HIPSPARSE_HYB_PARTITION_USER = chipsparse.HIPSPARSE_HYB_PARTITION_USER
    HIPSPARSE_HYB_PARTITION_MAX = chipsparse.HIPSPARSE_HYB_PARTITION_MAX
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseSolvePolicy_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseSolvePolicy_t(_hipsparseSolvePolicy_t__Base):
    """Specify policy in triangular solvers and factorizations.

    Attributes:
        HIPSPARSE_SOLVE_POLICY_NO_LEVEL:
            No level information generated
        HIPSPARSE_SOLVE_POLICY_USE_LEVEL:
            Generate level information
    """
    HIPSPARSE_SOLVE_POLICY_NO_LEVEL = chipsparse.HIPSPARSE_SOLVE_POLICY_NO_LEVEL
    HIPSPARSE_SOLVE_POLICY_USE_LEVEL = chipsparse.HIPSPARSE_SOLVE_POLICY_USE_LEVEL
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseSideMode_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseSideMode_t(_hipsparseSideMode_t__Base):
    """

    Attributes:
        HIPSPARSE_SIDE_LEFT:
            (undocumented)
        HIPSPARSE_SIDE_RIGHT:
            (undocumented)
    """
    HIPSPARSE_SIDE_LEFT = chipsparse.HIPSPARSE_SIDE_LEFT
    HIPSPARSE_SIDE_RIGHT = chipsparse.HIPSPARSE_SIDE_RIGHT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseDirection_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseDirection_t(_hipsparseDirection_t__Base):
    """Specify the matrix direction.

    Attributes:
        HIPSPARSE_DIRECTION_ROW:
            Parse the matrix by rows
        HIPSPARSE_DIRECTION_COLUMN:
            Parse the matrix by columns
    """
    HIPSPARSE_DIRECTION_ROW = chipsparse.HIPSPARSE_DIRECTION_ROW
    HIPSPARSE_DIRECTION_COLUMN = chipsparse.HIPSPARSE_DIRECTION_COLUMN
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


@cython.embedsignature(True)
def hipsparseCreate():
    r"""Create a hipsparse handle

    ``hipsparseCreate`` creates the hipSPARSE library context. It must be
    initialized before any other hipSPARSE API function is invoked and must be passed to
    all subsequent library function calls. The handle should be destroyed at the end
    using hipsparseDestroy().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    handle = hip._util.types.Pointer.fromPtr(NULL)
    _hipsparseCreate__retval = hipsparseStatus_t(chipsparse.hipsparseCreate(
        <void **>&handle._ptr))
    return (_hipsparseCreate__retval,None if handle._ptr == NULL else handle)


@cython.embedsignature(True)
def hipsparseDestroy(object handle):
    r"""Destroy a hipsparse handle

    ``hipsparseDestroy`` destroys the hipSPARSE library context and releases all
    resources used by the hipSPARSE library.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroy__retval = hipsparseStatus_t(chipsparse.hipsparseDestroy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr))
    return (_hipsparseDestroy__retval,)


@cython.embedsignature(True)
def hipsparseGetErrorName(object status):
    r"""Return the string representation of a hipSPARSE status's matching backend status enum name

    ``hipsparseGetErrorName`` takes a hipSPARSE status as input and first converts it to the matching backend
    status (either rocsparse_status or cusparseStatus_t). It then returns the string representation of this status
    enum name. If the status is not recognized, the function returns "Unrecognized status code".

    For example, hipsparseGetErrorName(HIPSPARSE_STATUS_SUCCESS) on a system with a rocSPARSE backend will
    return "rocsparse_status_success". On a system with a cuSPARSE backend this function would return
    "CUSPARSE_STATUS_SUCCESS".

    Args:
        status (`~.hipsparseStatus_t`):
            (undocumented)
    """
    if not isinstance(status,_hipsparseStatus_t__Base):
        raise TypeError("argument 'status' must be of type '_hipsparseStatus_t__Base'")
    _hipsparseGetErrorName__retval = hip._util.types.CStr.fromPtr(<void*>chipsparse.hipsparseGetErrorName(status.value))
    return (None if _hipsparseGetErrorName__retval._ptr == NULL else _hipsparseGetErrorName__retval,)


@cython.embedsignature(True)
def hipsparseGetErrorString(object status):
    r"""Return the hipSPARSE status's matching backend status description as a string

    ``hipsparseGetErrorString`` takes a hipSPARSE status as input and first converts it to the matching backend
    status (either rocsparse_status or cusparseStatus_t). It then returns the string description of this status.
    If the status is not recognized, the function returns "Unrecognized status code".

    Args:
        status (`~.hipsparseStatus_t`):
            (undocumented)
    """
    if not isinstance(status,_hipsparseStatus_t__Base):
        raise TypeError("argument 'status' must be of type '_hipsparseStatus_t__Base'")
    _hipsparseGetErrorString__retval = hip._util.types.CStr.fromPtr(<void*>chipsparse.hipsparseGetErrorString(status.value))
    return (None if _hipsparseGetErrorString__retval._ptr == NULL else _hipsparseGetErrorString__retval,)


@cython.embedsignature(True)
def hipsparseGetVersion(object handle, object version):
    r"""Get hipSPARSE version

    ``hipsparseGetVersion`` gets the hipSPARSE library version number.
    - patch = version % 100
    - minor = version / 100 % 1000
    - major = version / 100000

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        version (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseGetVersion__retval = hipsparseStatus_t(chipsparse.hipsparseGetVersion(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(version)._ptr))
    return (_hipsparseGetVersion__retval,)


@cython.embedsignature(True)
def hipsparseGetGitRevision(object handle, object rev):
    r"""Get hipSPARSE git revision

    ``hipsparseGetGitRevision`` gets the hipSPARSE library git commit revision (SHA-1).

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rev (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseGetGitRevision__retval = hipsparseStatus_t(chipsparse.hipsparseGetGitRevision(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <char *>hip._util.types.Pointer.fromPyobj(rev)._ptr))
    return (_hipsparseGetGitRevision__retval,)


@cython.embedsignature(True)
def hipsparseSetStream(object handle, object streamId):
    r"""Specify user defined HIP stream

    ``hipsparseSetStream`` specifies the stream to be used by the hipSPARSE library
    context and all subsequent function calls.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        streamId (`~.ihipStream_t`/`~.object`):
            (undocumented)
    """
    _hipsparseSetStream__retval = hipsparseStatus_t(chipsparse.hipsparseSetStream(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        ihipStream_t.fromPyobj(streamId).getElementPtr()))
    return (_hipsparseSetStream__retval,)


@cython.embedsignature(True)
def hipsparseGetStream(object handle):
    r"""Get current stream from library context

    ``hipsparseGetStream`` gets the hipSPARSE library context stream which is currently
    used for all subsequent function calls.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * streamId (`~.ihipStream_t`):
            (undocumented)
    """
    streamId = ihipStream_t.fromPtr(NULL)
    _hipsparseGetStream__retval = hipsparseStatus_t(chipsparse.hipsparseGetStream(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,<chipsparse.ihipStream_t**>&streamId._ptr))
    return (_hipsparseGetStream__retval,None if streamId._ptr == NULL else streamId)


@cython.embedsignature(True)
def hipsparseSetPointerMode(object handle, object mode):
    r"""Specify pointer mode

    ``hipsparseSetPointerMode`` specifies the pointer mode to be used by the hipSPARSE
    library context and all subsequent function calls. By default, all values are passed
    by reference on the host. Valid pointer modes are ``HIPSPARSE_POINTER_MODE_HOST`` 
    or ``HIPSPARSE_POINTER_MODE_DEVICE`` .

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mode (`~.hipsparsePointerMode_t`):
            (undocumented)
    """
    if not isinstance(mode,_hipsparsePointerMode_t__Base):
        raise TypeError("argument 'mode' must be of type '_hipsparsePointerMode_t__Base'")
    _hipsparseSetPointerMode__retval = hipsparseStatus_t(chipsparse.hipsparseSetPointerMode(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mode.value))
    return (_hipsparseSetPointerMode__retval,)


@cython.embedsignature(True)
def hipsparseGetPointerMode(object handle, object mode):
    r"""Get current pointer mode from library context

    ``hipsparseGetPointerMode`` gets the hipSPARSE library context pointer mode which
    is currently used for all subsequent function calls.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mode (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseGetPointerMode__retval = hipsparseStatus_t(chipsparse.hipsparseGetPointerMode(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <chipsparse.hipsparsePointerMode_t *>hip._util.types.Pointer.fromPyobj(mode)._ptr))
    return (_hipsparseGetPointerMode__retval,)


@cython.embedsignature(True)
def hipsparseCreateMatDescr(object descrA):
    r"""Create a matrix descriptor

    ``hipsparseCreateMatDescr`` creates a matrix descriptor. It initializes
    ``hipsparseMatrixType_t`` to ``HIPSPARSE_MATRIX_TYPE_GENERAL`` and
    ``hipsparseIndexBase_t`` to ``HIPSPARSE_INDEX_BASE_ZERO`` . It should be destroyed
    at the end using hipsparseDestroyMatDescr().

    Args:
        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCreateMatDescr__retval = hipsparseStatus_t(chipsparse.hipsparseCreateMatDescr(
        <void **>hip._util.types.Pointer.fromPyobj(descrA)._ptr))
    return (_hipsparseCreateMatDescr__retval,)


@cython.embedsignature(True)
def hipsparseDestroyMatDescr(object descrA):
    r"""Destroy a matrix descriptor

    ``hipsparseDestroyMatDescr`` destroys a matrix descriptor and releases all
    resources used by the descriptor.

    Args:
        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyMatDescr__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyMatDescr(
        <void *>hip._util.types.Pointer.fromPyobj(descrA)._ptr))
    return (_hipsparseDestroyMatDescr__retval,)


@cython.embedsignature(True)
def hipsparseCopyMatDescr(object dest, object src):
    r"""Copy a matrix descriptor

    ``hipsparseCopyMatDescr`` copies a matrix descriptor. Both, source and destination
    matrix descriptors must be initialized prior to calling ``hipsparseCopyMatDescr.``

    Args:
        dest (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        src (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCopyMatDescr__retval = hipsparseStatus_t(chipsparse.hipsparseCopyMatDescr(
        <void *>hip._util.types.Pointer.fromPyobj(dest)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(src)._ptr))
    return (_hipsparseCopyMatDescr__retval,)


@cython.embedsignature(True)
def hipsparseSetMatType(object descrA, object type):
    r"""Specify the matrix type of a matrix descriptor

    ``hipsparseSetMatType`` sets the matrix type of a matrix descriptor. Valid
    matrix types are ``HIPSPARSE_MATRIX_TYPE_GENERAL`` ,
    ``HIPSPARSE_MATRIX_TYPE_SYMMETRIC`` , ``HIPSPARSE_MATRIX_TYPE_HERMITIAN`` or
    ``HIPSPARSE_MATRIX_TYPE_TRIANGULAR`` .

    Args:
        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        type (`~.hipsparseMatrixType_t`):
            (undocumented)
    """
    if not isinstance(type,_hipsparseMatrixType_t__Base):
        raise TypeError("argument 'type' must be of type '_hipsparseMatrixType_t__Base'")
    _hipsparseSetMatType__retval = hipsparseStatus_t(chipsparse.hipsparseSetMatType(
        <void *>hip._util.types.Pointer.fromPyobj(descrA)._ptr,type.value))
    return (_hipsparseSetMatType__retval,)


@cython.embedsignature(True)
def hipsparseGetMatType(object descrA):
    r"""Get the matrix type of a matrix descriptor

    ``hipsparseGetMatType`` returns the matrix type of a matrix descriptor.

    Args:
        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseGetMatType__retval = hipsparseMatrixType_t(chipsparse.hipsparseGetMatType(
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr))
    return (_hipsparseGetMatType__retval,)


@cython.embedsignature(True)
def hipsparseSetMatFillMode(object descrA, object fillMode):
    r"""Specify the matrix fill mode of a matrix descriptor

    ``hipsparseSetMatFillMode`` sets the matrix fill mode of a matrix descriptor.
    Valid fill modes are ``HIPSPARSE_FILL_MODE_LOWER`` or
    ``HIPSPARSE_FILL_MODE_UPPER`` .

    Args:
        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        fillMode (`~.hipsparseFillMode_t`):
            (undocumented)
    """
    if not isinstance(fillMode,_hipsparseFillMode_t__Base):
        raise TypeError("argument 'fillMode' must be of type '_hipsparseFillMode_t__Base'")
    _hipsparseSetMatFillMode__retval = hipsparseStatus_t(chipsparse.hipsparseSetMatFillMode(
        <void *>hip._util.types.Pointer.fromPyobj(descrA)._ptr,fillMode.value))
    return (_hipsparseSetMatFillMode__retval,)


@cython.embedsignature(True)
def hipsparseGetMatFillMode(object descrA):
    r"""Get the matrix fill mode of a matrix descriptor

    ``hipsparseGetMatFillMode`` returns the matrix fill mode of a matrix descriptor.

    Args:
        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseGetMatFillMode__retval = hipsparseFillMode_t(chipsparse.hipsparseGetMatFillMode(
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr))
    return (_hipsparseGetMatFillMode__retval,)


@cython.embedsignature(True)
def hipsparseSetMatDiagType(object descrA, object diagType):
    r"""Specify the matrix diagonal type of a matrix descriptor

    ``hipsparseSetMatDiagType`` sets the matrix diagonal type of a matrix
    descriptor. Valid diagonal types are ``HIPSPARSE_DIAG_TYPE_UNIT`` or
    ``HIPSPARSE_DIAG_TYPE_NON_UNIT`` .

    Args:
        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        diagType (`~.hipsparseDiagType_t`):
            (undocumented)
    """
    if not isinstance(diagType,_hipsparseDiagType_t__Base):
        raise TypeError("argument 'diagType' must be of type '_hipsparseDiagType_t__Base'")
    _hipsparseSetMatDiagType__retval = hipsparseStatus_t(chipsparse.hipsparseSetMatDiagType(
        <void *>hip._util.types.Pointer.fromPyobj(descrA)._ptr,diagType.value))
    return (_hipsparseSetMatDiagType__retval,)


@cython.embedsignature(True)
def hipsparseGetMatDiagType(object descrA):
    r"""Get the matrix diagonal type of a matrix descriptor

    ``hipsparseGetMatDiagType`` returns the matrix diagonal type of a matrix
    descriptor.

    Args:
        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseGetMatDiagType__retval = hipsparseDiagType_t(chipsparse.hipsparseGetMatDiagType(
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr))
    return (_hipsparseGetMatDiagType__retval,)


@cython.embedsignature(True)
def hipsparseSetMatIndexBase(object descrA, object base):
    r"""Specify the index base of a matrix descriptor

    ``hipsparseSetMatIndexBase`` sets the index base of a matrix descriptor. Valid
    options are ``HIPSPARSE_INDEX_BASE_ZERO`` or ``HIPSPARSE_INDEX_BASE_ONE`` .

    Args:
        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        base (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(base,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'base' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseSetMatIndexBase__retval = hipsparseStatus_t(chipsparse.hipsparseSetMatIndexBase(
        <void *>hip._util.types.Pointer.fromPyobj(descrA)._ptr,base.value))
    return (_hipsparseSetMatIndexBase__retval,)


@cython.embedsignature(True)
def hipsparseGetMatIndexBase(object descrA):
    r"""Get the index base of a matrix descriptor

    ``hipsparseGetMatIndexBase`` returns the index base of a matrix descriptor.

    Args:
        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseGetMatIndexBase__retval = hipsparseIndexBase_t(chipsparse.hipsparseGetMatIndexBase(
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr))
    return (_hipsparseGetMatIndexBase__retval,)


@cython.embedsignature(True)
def hipsparseCreateHybMat(object hybA):
    r"""Create a ``HYB`` matrix structure

    ``hipsparseCreateHybMat`` creates a structure that holds the matrix in ``HYB``
    storage format. It should be destroyed at the end using hipsparseDestroyHybMat().

    Args:
        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCreateHybMat__retval = hipsparseStatus_t(chipsparse.hipsparseCreateHybMat(
        <void **>hip._util.types.Pointer.fromPyobj(hybA)._ptr))
    return (_hipsparseCreateHybMat__retval,)


@cython.embedsignature(True)
def hipsparseDestroyHybMat(object hybA):
    r"""Destroy a ``HYB`` matrix structure

    ``hipsparseDestroyHybMat`` destroys a ``HYB`` structure.

    Args:
        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyHybMat__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyHybMat(
        <void *>hip._util.types.Pointer.fromPyobj(hybA)._ptr))
    return (_hipsparseDestroyHybMat__retval,)


@cython.embedsignature(True)
def hipsparseCreateBsrsv2Info():
    r"""Create a bsrsv2 info structure

    ``hipsparseCreateBsrsv2Info`` creates a structure that holds the bsrsv2 info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyBsrsv2Info().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.bsrsv2Info`):
            (undocumented)
    """
    info = bsrsv2Info.fromPtr(NULL)
    _hipsparseCreateBsrsv2Info__retval = hipsparseStatus_t(chipsparse.hipsparseCreateBsrsv2Info(<chipsparse.bsrsv2Info**>&info._ptr))
    return (_hipsparseCreateBsrsv2Info__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyBsrsv2Info(object info):
    r"""Destroy a bsrsv2 info structure

    ``hipsparseDestroyBsrsv2Info`` destroys a bsrsv2 info structure.

    Args:
        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyBsrsv2Info__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyBsrsv2Info(
        bsrsv2Info.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyBsrsv2Info__retval,)


@cython.embedsignature(True)
def hipsparseCreateBsrsm2Info():
    r"""Create a bsrsm2 info structure

    ``hipsparseCreateBsrsm2Info`` creates a structure that holds the bsrsm2 info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyBsrsm2Info().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.bsrsm2Info`):
            (undocumented)
    """
    info = bsrsm2Info.fromPtr(NULL)
    _hipsparseCreateBsrsm2Info__retval = hipsparseStatus_t(chipsparse.hipsparseCreateBsrsm2Info(<chipsparse.bsrsm2Info**>&info._ptr))
    return (_hipsparseCreateBsrsm2Info__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyBsrsm2Info(object info):
    r"""Destroy a bsrsm2 info structure

    ``hipsparseDestroyBsrsm2Info`` destroys a bsrsm2 info structure.

    Args:
        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyBsrsm2Info__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyBsrsm2Info(
        bsrsm2Info.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyBsrsm2Info__retval,)


@cython.embedsignature(True)
def hipsparseCreateBsrilu02Info():
    r"""Create a bsrilu02 info structure

    ``hipsparseCreateBsrilu02Info`` creates a structure that holds the bsrilu02 info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyBsrilu02Info().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.bsrilu02Info`):
            (undocumented)
    """
    info = bsrilu02Info.fromPtr(NULL)
    _hipsparseCreateBsrilu02Info__retval = hipsparseStatus_t(chipsparse.hipsparseCreateBsrilu02Info(<chipsparse.bsrilu02Info**>&info._ptr))
    return (_hipsparseCreateBsrilu02Info__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyBsrilu02Info(object info):
    r"""Destroy a bsrilu02 info structure

    ``hipsparseDestroyBsrilu02Info`` destroys a bsrilu02 info structure.

    Args:
        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyBsrilu02Info__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyBsrilu02Info(
        bsrilu02Info.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyBsrilu02Info__retval,)


@cython.embedsignature(True)
def hipsparseCreateBsric02Info():
    r"""Create a bsric02 info structure

    ``hipsparseCreateBsric02Info`` creates a structure that holds the bsric02 info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyBsric02Info().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.bsric02Info`):
            (undocumented)
    """
    info = bsric02Info.fromPtr(NULL)
    _hipsparseCreateBsric02Info__retval = hipsparseStatus_t(chipsparse.hipsparseCreateBsric02Info(<chipsparse.bsric02Info**>&info._ptr))
    return (_hipsparseCreateBsric02Info__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyBsric02Info(object info):
    r"""Destroy a bsric02 info structure

    ``hipsparseDestroyBsric02Info`` destroys a bsric02 info structure.

    Args:
        info (`~.bsric02Info`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyBsric02Info__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyBsric02Info(
        bsric02Info.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyBsric02Info__retval,)


@cython.embedsignature(True)
def hipsparseCreateCsrsv2Info():
    r"""Create a csrsv2 info structure

    ``hipsparseCreateCsrsv2Info`` creates a structure that holds the csrsv2 info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyCsrsv2Info().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.csrsv2Info`):
            (undocumented)
    """
    info = csrsv2Info.fromPtr(NULL)
    _hipsparseCreateCsrsv2Info__retval = hipsparseStatus_t(chipsparse.hipsparseCreateCsrsv2Info(<chipsparse.csrsv2Info**>&info._ptr))
    return (_hipsparseCreateCsrsv2Info__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyCsrsv2Info(object info):
    r"""Destroy a csrsv2 info structure

    ``hipsparseDestroyCsrsv2Info`` destroys a csrsv2 info structure.

    Args:
        info (`~.csrsv2Info`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyCsrsv2Info__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyCsrsv2Info(
        csrsv2Info.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyCsrsv2Info__retval,)


@cython.embedsignature(True)
def hipsparseCreateCsrsm2Info():
    r"""Create a csrsm2 info structure

    ``hipsparseCreateCsrsm2Info`` creates a structure that holds the csrsm2 info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyCsrsm2Info().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.csrsm2Info`):
            (undocumented)
    """
    info = csrsm2Info.fromPtr(NULL)
    _hipsparseCreateCsrsm2Info__retval = hipsparseStatus_t(chipsparse.hipsparseCreateCsrsm2Info(<chipsparse.csrsm2Info**>&info._ptr))
    return (_hipsparseCreateCsrsm2Info__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyCsrsm2Info(object info):
    r"""Destroy a csrsm2 info structure

    ``hipsparseDestroyCsrsm2Info`` destroys a csrsm2 info structure.

    Args:
        info (`~.csrsm2Info`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyCsrsm2Info__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyCsrsm2Info(
        csrsm2Info.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyCsrsm2Info__retval,)


@cython.embedsignature(True)
def hipsparseCreateCsrilu02Info():
    r"""Create a csrilu02 info structure

    ``hipsparseCreateCsrilu02Info`` creates a structure that holds the csrilu02 info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyCsrilu02Info().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.csrilu02Info`):
            (undocumented)
    """
    info = csrilu02Info.fromPtr(NULL)
    _hipsparseCreateCsrilu02Info__retval = hipsparseStatus_t(chipsparse.hipsparseCreateCsrilu02Info(<chipsparse.csrilu02Info**>&info._ptr))
    return (_hipsparseCreateCsrilu02Info__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyCsrilu02Info(object info):
    r"""Destroy a csrilu02 info structure

    ``hipsparseDestroyCsrilu02Info`` destroys a csrilu02 info structure.

    Args:
        info (`~.csrilu02Info`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyCsrilu02Info__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyCsrilu02Info(
        csrilu02Info.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyCsrilu02Info__retval,)


@cython.embedsignature(True)
def hipsparseCreateCsric02Info():
    r"""Create a csric02 info structure

    ``hipsparseCreateCsric02Info`` creates a structure that holds the csric02 info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyCsric02Info().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.csric02Info`):
            (undocumented)
    """
    info = csric02Info.fromPtr(NULL)
    _hipsparseCreateCsric02Info__retval = hipsparseStatus_t(chipsparse.hipsparseCreateCsric02Info(<chipsparse.csric02Info**>&info._ptr))
    return (_hipsparseCreateCsric02Info__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyCsric02Info(object info):
    r"""Destroy a csric02 info structure

    ``hipsparseDestroyCsric02Info`` destroys a csric02 info structure.

    Args:
        info (`~.csric02Info`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyCsric02Info__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyCsric02Info(
        csric02Info.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyCsric02Info__retval,)


@cython.embedsignature(True)
def hipsparseCreateCsru2csrInfo():
    r"""Create a csru2csr info structure

    ``hipsparseCreateCsru2csrInfo`` creates a structure that holds the csru2csr info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyCsru2csrInfo().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.csru2csrInfo`):
            (undocumented)
    """
    info = csru2csrInfo.fromPtr(NULL)
    _hipsparseCreateCsru2csrInfo__retval = hipsparseStatus_t(chipsparse.hipsparseCreateCsru2csrInfo(<chipsparse.csru2csrInfo**>&info._ptr))
    return (_hipsparseCreateCsru2csrInfo__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyCsru2csrInfo(object info):
    r"""Destroy a csru2csr info structure

    ``hipsparseDestroyCsru2csrInfo`` destroys a csru2csr info structure.

    Args:
        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyCsru2csrInfo__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyCsru2csrInfo(
        csru2csrInfo.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyCsru2csrInfo__retval,)


@cython.embedsignature(True)
def hipsparseCreateColorInfo(object info):
    r"""Create a color info structure

    ``hipsparseCreateColorInfo`` creates a structure that holds the color info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyColorInfo().

    Args:
        info (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCreateColorInfo__retval = hipsparseStatus_t(chipsparse.hipsparseCreateColorInfo(
        <void **>hip._util.types.Pointer.fromPyobj(info)._ptr))
    return (_hipsparseCreateColorInfo__retval,)


@cython.embedsignature(True)
def hipsparseDestroyColorInfo(object info):
    r"""Destroy a color info structure

    ``hipsparseDestroyColorInfo`` destroys a color info structure.

    Args:
        info (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyColorInfo__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyColorInfo(
        <void *>hip._util.types.Pointer.fromPyobj(info)._ptr))
    return (_hipsparseDestroyColorInfo__retval,)


@cython.embedsignature(True)
def hipsparseCreateCsrgemm2Info():
    r"""Create a csrgemm2 info structure

    ``hipsparseCreateCsrgemm2Info`` creates a structure that holds the csrgemm2 info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyCsrgemm2Info().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.csrgemm2Info`):
            (undocumented)
    """
    info = csrgemm2Info.fromPtr(NULL)
    _hipsparseCreateCsrgemm2Info__retval = hipsparseStatus_t(chipsparse.hipsparseCreateCsrgemm2Info(<chipsparse.csrgemm2Info**>&info._ptr))
    return (_hipsparseCreateCsrgemm2Info__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyCsrgemm2Info(object info):
    r"""Destroy a csrgemm2 info structure

    ``hipsparseDestroyCsrgemm2Info`` destroys a csrgemm2 info structure.

    Args:
        info (`~.csrgemm2Info`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyCsrgemm2Info__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyCsrgemm2Info(
        csrgemm2Info.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyCsrgemm2Info__retval,)


@cython.embedsignature(True)
def hipsparseCreatePruneInfo():
    r"""Create a prune info structure

    ``hipsparseCreatePruneInfo`` creates a structure that holds the prune info data
    that is gathered during the analysis routines available. It should be destroyed
    at the end using hipsparseDestroyPruneInfo().

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * info (`~.pruneInfo`):
            (undocumented)
    """
    info = pruneInfo.fromPtr(NULL)
    _hipsparseCreatePruneInfo__retval = hipsparseStatus_t(chipsparse.hipsparseCreatePruneInfo(<chipsparse.pruneInfo**>&info._ptr))
    return (_hipsparseCreatePruneInfo__retval,None if info._ptr == NULL else info)


@cython.embedsignature(True)
def hipsparseDestroyPruneInfo(object info):
    r"""Destroy a prune info structure

    ``hipsparseDestroyPruneInfo`` destroys a prune info structure.

    Args:
        info (`~.pruneInfo`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyPruneInfo__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyPruneInfo(
        pruneInfo.fromPyobj(info).getElementPtr()))
    return (_hipsparseDestroyPruneInfo__retval,)


@cython.embedsignature(True)
def hipsparseSaxpyi(object handle, int nnz, object alpha, object xVal, object xInd, object y, object idxBase):
    r"""Scale a sparse vector and add it to a dense vector.

    ``hipsparseXaxpyi`` multiplies the sparse vector :math:`x` with scalar :math:`\alpha` and
    adds the result to the dense vector :math:`y`, such that

    .. math::

       y := y + \alpha \cdot x

    .. code-block::

       for(i = 0; i < nnz; ++i)
       {
           y[xInd[i]] = y[xInd[i]] + alpha * xVal[i];
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // Number of non-zeros of the sparse vector
       int nnz = 3;

       // Sparse index vector
       int hxInd[3] = {0, 3, 5};

       // Sparse value vector
       double hxVal[3] = {1.0, 2.0, 3.0};

       // Dense vector
       double hy[9] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};

       // Scalar alpha
       double alpha = 3.7;

       // Index base
       hipsparseIndexBase_t idxBase = HIPSPARSE_INDEX_BASE_ZERO;

       // Offload data to device
       int* dxInd;
       double*        dxVal;
       double*        dy;

       hipMalloc((void**)&dxInd, sizeof(int) * nnz);
       hipMalloc((void**)&dxVal, sizeof(double) * nnz);
       hipMalloc((void**)&dy, sizeof(double) * 9);

       hipMemcpy(dxInd, hxInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dxVal, hxVal, sizeof(double) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dy, hy, sizeof(double) * 9, hipMemcpyHostToDevice);

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Call daxpyi to perform y = y + alpha * x
       hipsparseDaxpyi(handle, nnz, &alpha, dxVal, dxInd, dy, idxBase);

       // Copy result back to host
       hipMemcpy(hy, dy, sizeof(double) * 9, hipMemcpyDeviceToHost);

       // Clear hipSPARSE
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dxInd);
       hipFree(dxVal);
       hipFree(dy);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseSaxpyi__retval = hipsparseStatus_t(chipsparse.hipsparseSaxpyi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,idxBase.value))
    return (_hipsparseSaxpyi__retval,)


@cython.embedsignature(True)
def hipsparseDaxpyi(object handle, int nnz, object alpha, object xVal, object xInd, object y, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseDaxpyi__retval = hipsparseStatus_t(chipsparse.hipsparseDaxpyi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,idxBase.value))
    return (_hipsparseDaxpyi__retval,)


@cython.embedsignature(True)
def hipsparseCaxpyi(object handle, int nnz, object alpha, object xVal, object xInd, object y, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        xVal (`~.float2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseCaxpyi__retval = hipsparseStatus_t(chipsparse.hipsparseCaxpyi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        float2.fromPyobj(y).getElementPtr(),idxBase.value))
    return (_hipsparseCaxpyi__retval,)


@cython.embedsignature(True)
def hipsparseZaxpyi(object handle, int nnz, object alpha, object xVal, object xInd, object y, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        xVal (`~.double2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseZaxpyi__retval = hipsparseStatus_t(chipsparse.hipsparseZaxpyi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        double2.fromPyobj(y).getElementPtr(),idxBase.value))
    return (_hipsparseZaxpyi__retval,)


@cython.embedsignature(True)
def hipsparseSdoti(object handle, int nnz, object xVal, object xInd, object y, object result, object idxBase):
    r"""Compute the dot product of a sparse vector with a dense vector.

    ``hipsparseXdoti`` computes the dot product of the sparse vector :math:`x` with the
    dense vector :math:`y`, such that

    .. math::

       result := y^T x

    .. code-block::

       result = 0
       for(i = 0; i < nnz; ++i)
       {
           result += xVal[i] * y[xInd[i]];
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // Number of non-zeros of the sparse vector
       int nnz = 3;

       // Sparse index vector
       int hxInd[3] = {0, 3, 5};

       // Sparse value vector
       float hxVal[3] = {1.0f, 2.0f, 3.0f};

       // Dense vector
       float hy[9] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f};

       // Index base
       hipsparseIndexBase_t idxBase = HIPSPARSE_INDEX_BASE_ZERO;

       // Offload data to device
       int* dxInd;
       float*        dxVal;
       float*        dy;

       hipMalloc((void**)&dxInd, sizeof(int) * nnz);
       hipMalloc((void**)&dxVal, sizeof(float) * nnz);
       hipMalloc((void**)&dy, sizeof(float) * 9);

       hipMemcpy(dxInd, hxInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dxVal, hxVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dy, hy, sizeof(float) * 9, hipMemcpyHostToDevice);

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Call sdoti to compute the dot product
       float dot;
       hipsparseSdoti(handle, nnz, dxVal, dxInd, dy, &dot, idxBase);

       // Clear hipSPARSE
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dxInd);
       hipFree(dxVal);
       hipFree(dy);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseSdoti__retval = hipsparseStatus_t(chipsparse.hipsparseSdoti(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(result)._ptr,idxBase.value))
    return (_hipsparseSdoti__retval,)


@cython.embedsignature(True)
def hipsparseDdoti(object handle, int nnz, object xVal, object xInd, object y, object result, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseDdoti__retval = hipsparseStatus_t(chipsparse.hipsparseDdoti(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(result)._ptr,idxBase.value))
    return (_hipsparseDdoti__retval,)


@cython.embedsignature(True)
def hipsparseCdoti(object handle, int nnz, object xVal, object xInd, object y, object result, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.float2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseCdoti__retval = hipsparseStatus_t(chipsparse.hipsparseCdoti(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        float2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        float2.fromPyobj(y).getElementPtr(),
        float2.fromPyobj(result).getElementPtr(),idxBase.value))
    return (_hipsparseCdoti__retval,)


@cython.embedsignature(True)
def hipsparseZdoti(object handle, int nnz, object xVal, object xInd, object y, object result, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.double2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseZdoti__retval = hipsparseStatus_t(chipsparse.hipsparseZdoti(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        double2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        double2.fromPyobj(y).getElementPtr(),
        double2.fromPyobj(result).getElementPtr(),idxBase.value))
    return (_hipsparseZdoti__retval,)


@cython.embedsignature(True)
def hipsparseCdotci(object handle, int nnz, object xVal, object xInd, object y, object result, object idxBase):
    r"""Compute the dot product of a complex conjugate sparse vector with a dense
    vector.

    ``hipsparseXdotci`` computes the dot product of the complex conjugate sparse vector
    :math:`x` with the dense vector :math:`y`, such that

    .. math::

       result := \bar{x}^H y

    .. code-block::

       result = 0
       for(i = 0; i < nnz; ++i)
       {
           result += conj(xVal[i]) * y[xInd[i]];
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.float2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        result (`~.float2`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseCdotci__retval = hipsparseStatus_t(chipsparse.hipsparseCdotci(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        float2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        float2.fromPyobj(y).getElementPtr(),
        float2.fromPyobj(result).getElementPtr(),idxBase.value))
    return (_hipsparseCdotci__retval,)


@cython.embedsignature(True)
def hipsparseZdotci(object handle, int nnz, object xVal, object xInd, object y, object result, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.double2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        result (`~.double2`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseZdotci__retval = hipsparseStatus_t(chipsparse.hipsparseZdotci(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        double2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        double2.fromPyobj(y).getElementPtr(),
        double2.fromPyobj(result).getElementPtr(),idxBase.value))
    return (_hipsparseZdotci__retval,)


@cython.embedsignature(True)
def hipsparseSgthr(object handle, int nnz, object y, object xVal, object xInd, object idxBase):
    r"""Gather elements from a dense vector and store them into a sparse vector.

    ``hipsparseXgthr`` gathers the elements that are listed in ``xInd`` from the dense
    vector :math:`y` and stores them in the sparse vector :math:`x`.

    .. code-block::

       for(i = 0; i < nnz; ++i)
       {
           xVal[i] = y[xInd[i]];
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // Number of non-zeros of the sparse vector
       int nnz = 3;

       // Sparse index vector
       int hxInd[3] = {0, 3, 5};

       // Sparse value vector
       float hxVal[3];

       // Dense vector
       float hy[9] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};

       // Index base
       hipsparseIndexBase_t idxBase = HIPSPARSE_INDEX_BASE_ZERO;

       // Offload data to device
       int* dxInd;
       float*         dxVal;
       float*         dy;

       hipMalloc((void**)&dxInd, sizeof(int) * nnz);
       hipMalloc((void**)&dxVal, sizeof(float) * nnz);
       hipMalloc((void**)&dy, sizeof(float) * 9);

       hipMemcpy(dxInd, hxInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dy, hy, sizeof(float) * 9, hipMemcpyHostToDevice);

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Call sgthr
       hipsparseSgthr(handle, nnz, dy, dxVal, dxInd, idxBase);

       // Copy result back to host
       hipMemcpy(hxVal, dxVal, sizeof(float) * nnz, hipMemcpyDeviceToHost);

       // Clear hipSPARSE
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dxInd);
       hipFree(dxVal);
       hipFree(dy);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseSgthr__retval = hipsparseStatus_t(chipsparse.hipsparseSgthr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(y)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,idxBase.value))
    return (_hipsparseSgthr__retval,)


@cython.embedsignature(True)
def hipsparseDgthr(object handle, int nnz, object y, object xVal, object xInd, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseDgthr__retval = hipsparseStatus_t(chipsparse.hipsparseDgthr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(y)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,idxBase.value))
    return (_hipsparseDgthr__retval,)


@cython.embedsignature(True)
def hipsparseCgthr(object handle, int nnz, object y, object xVal, object xInd, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        xVal (`~.float2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseCgthr__retval = hipsparseStatus_t(chipsparse.hipsparseCgthr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        float2.fromPyobj(y).getElementPtr(),
        float2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,idxBase.value))
    return (_hipsparseCgthr__retval,)


@cython.embedsignature(True)
def hipsparseZgthr(object handle, int nnz, object y, object xVal, object xInd, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        xVal (`~.double2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseZgthr__retval = hipsparseStatus_t(chipsparse.hipsparseZgthr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        double2.fromPyobj(y).getElementPtr(),
        double2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,idxBase.value))
    return (_hipsparseZgthr__retval,)


@cython.embedsignature(True)
def hipsparseSgthrz(object handle, int nnz, object y, object xVal, object xInd, object idxBase):
    r"""Gather and zero out elements from a dense vector and store them into a sparse
    vector.

    ``hipsparseXgthrz`` gathers the elements that are listed in ``xInd`` from the dense
    vector :math:`y` and stores them in the sparse vector :math:`x`. The gathered elements
    in :math:`y` are replaced by zero.

    .. code-block::

       for(i = 0; i < nnz; ++i)
       {
           xVal[i]    = y[xInd[i]];
           y[xInd[i]] = 0;
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseSgthrz__retval = hipsparseStatus_t(chipsparse.hipsparseSgthrz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,idxBase.value))
    return (_hipsparseSgthrz__retval,)


@cython.embedsignature(True)
def hipsparseDgthrz(object handle, int nnz, object y, object xVal, object xInd, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseDgthrz__retval = hipsparseStatus_t(chipsparse.hipsparseDgthrz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,idxBase.value))
    return (_hipsparseDgthrz__retval,)


@cython.embedsignature(True)
def hipsparseCgthrz(object handle, int nnz, object y, object xVal, object xInd, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        xVal (`~.float2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseCgthrz__retval = hipsparseStatus_t(chipsparse.hipsparseCgthrz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        float2.fromPyobj(y).getElementPtr(),
        float2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,idxBase.value))
    return (_hipsparseCgthrz__retval,)


@cython.embedsignature(True)
def hipsparseZgthrz(object handle, int nnz, object y, object xVal, object xInd, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        xVal (`~.double2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseZgthrz__retval = hipsparseStatus_t(chipsparse.hipsparseZgthrz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        double2.fromPyobj(y).getElementPtr(),
        double2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,idxBase.value))
    return (_hipsparseZgthrz__retval,)


@cython.embedsignature(True)
def hipsparseSroti(object handle, int nnz, object xVal, object xInd, object y, object c, object s, object idxBase):
    r"""Apply Givens rotation to a dense and a sparse vector.

    ``hipsparseXroti`` applies the Givens rotation matrix :math:`G` to the sparse vector
    :math:`x` and the dense vector :math:`y`, where

    .. math::

       G = \begin{pmatrix} c & s \\ -s & c \end{pmatrix}

    .. code-block::

       for(i = 0; i < nnz; ++i)
       {
           x_tmp = xVal[i];
           y_tmp = y[xInd[i]];

           xVal[i]    = c * x_tmp + s * y_tmp;
           y[xInd[i]] = c * y_tmp - s * x_tmp;
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // Number of non-zeros of the sparse vector
       int nnz = 3;

       // Sparse index vector
       int hxInd[3] = {0, 3, 5};

       // Sparse value vector
       float hxVal[3] = {1.0f, 2.0f, 3.0f};

       // Dense vector
       float hy[9] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f};

       // c and s
       float c = 3.7;
       float s = 1.3;

       // Index base
       hipsparseIndexBase_t idxBase = HIPSPARSE_INDEX_BASE_ZERO;

       // Offload data to device
       int* dxInd;
       float*        dxVal;
       float*        dy;

       hipMalloc((void**)&dxInd, sizeof(int) * nnz);
       hipMalloc((void**)&dxVal, sizeof(float) * nnz);
       hipMalloc((void**)&dy, sizeof(float) * 9);

       hipMemcpy(dxInd, hxInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dxVal, hxVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dy, hy, sizeof(float) * 9, hipMemcpyHostToDevice);

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Call sroti
       hipsparseSroti(handle, nnz, dxVal, dxInd, dy, &c, &s, idxBase);

       // Copy result back to host
       hipMemcpy(hxVal, dxVal, sizeof(float) * nnz, hipMemcpyDeviceToHost);
       hipMemcpy(hy, dy, sizeof(float) * 9, hipMemcpyDeviceToHost);

       // Clear hipSPARSE
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dxInd);
       hipFree(dxVal);
       hipFree(dy);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseSroti__retval = hipsparseStatus_t(chipsparse.hipsparseSroti(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <float *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(s)._ptr,idxBase.value))
    return (_hipsparseSroti__retval,)


@cython.embedsignature(True)
def hipsparseDroti(object handle, int nnz, object xVal, object xInd, object y, object c, object s, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseDroti__retval = hipsparseStatus_t(chipsparse.hipsparseDroti(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <double *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(c)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(s)._ptr,idxBase.value))
    return (_hipsparseDroti__retval,)


@cython.embedsignature(True)
def hipsparseSsctr(object handle, int nnz, object xVal, object xInd, object y, object idxBase):
    r"""Scatter elements from a dense vector across a sparse vector.

    ``hipsparseXsctr`` scatters the elements that are listed in ``xInd`` from the sparse
    vector :math:`x` into the dense vector :math:`y`. Indices of :math:`y` that are not listed
    in ``xInd`` remain unchanged.

    .. code-block::

       for(i = 0; i < nnz; ++i)
       {
           y[xInd[i]] = xVal[i];
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // Number of non-zeros of the sparse vector
       int nnz = 3;

       // Sparse index vector
       int hxInd[3] = {0, 3, 5};

       // Sparse value vector
       float hxVal[3] = {9.0, 2.0, 3.0};

       // Dense vector
       float hy[9] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};

       // Index base
       hipsparseIndexBase_t idxBase = HIPSPARSE_INDEX_BASE_ZERO;

       // Offload data to device
       int* dxInd;
       float*         dxVal;
       float*         dy;

       hipMalloc((void**)&dxInd, sizeof(int) * nnz);
       hipMalloc((void**)&dxVal, sizeof(float) * nnz);
       hipMalloc((void**)&dy, sizeof(float) * 9);

       hipMemcpy(dxInd, hxInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dxVal, hxVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dy, hy, sizeof(float) * 9, hipMemcpyHostToDevice);

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Call ssctr
       hipsparseSsctr(handle, nnz, dxVal, dxInd, dy, idxBase);

       // Copy result back to host
       hipMemcpy(hy, dy, sizeof(float) * 9, hipMemcpyDeviceToHost);

       // Clear hipSPARSE
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dxInd);
       hipFree(dxVal);
       hipFree(dy);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseSsctr__retval = hipsparseStatus_t(chipsparse.hipsparseSsctr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,idxBase.value))
    return (_hipsparseSsctr__retval,)


@cython.embedsignature(True)
def hipsparseDsctr(object handle, int nnz, object xVal, object xInd, object y, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseDsctr__retval = hipsparseStatus_t(chipsparse.hipsparseDsctr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(xVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,idxBase.value))
    return (_hipsparseDsctr__retval,)


@cython.embedsignature(True)
def hipsparseCsctr(object handle, int nnz, object xVal, object xInd, object y, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.float2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseCsctr__retval = hipsparseStatus_t(chipsparse.hipsparseCsctr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        float2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        float2.fromPyobj(y).getElementPtr(),idxBase.value))
    return (_hipsparseCsctr__retval,)


@cython.embedsignature(True)
def hipsparseZsctr(object handle, int nnz, object xVal, object xInd, object y, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        xVal (`~.double2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseZsctr__retval = hipsparseStatus_t(chipsparse.hipsparseZsctr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,nnz,
        double2.fromPyobj(xVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        double2.fromPyobj(y).getElementPtr(),idxBase.value))
    return (_hipsparseZsctr__retval,)


@cython.embedsignature(True)
def hipsparseScsrmv(object handle, object transA, int m, int n, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object x, object beta, object y):
    r"""Sparse matrix vector multiplication using CSR storage format

    ``hipsparseXcsrmv`` multiplies the scalar :math:`\alpha` with a sparse :math:`m \times n`
    matrix, defined in CSR storage format, and the dense vector :math:`x` and adds the
    result to the dense vector :math:`y` that is multiplied by the scalar :math:`\beta`,
    such that

    .. math::

       y := \alpha \cdot op(A) \cdot x + \beta \cdot y,

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    .. code-block::

       for(i = 0; i < m; ++i)
       {
           y[i] = beta * y[i];

           for(j = csrRowPtr[i]; j < csrRowPtr[i + 1]; ++j)
           {
               y[i] = y[i] + alpha * csrVal[j] * x[csrColInd[j]];
           }
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``trans`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` is supported.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // alpha * ( 1.0  0.0  2.0 ) * ( 1.0 ) + beta * ( 4.0 ) = (  31.1 )
       //         ( 3.0  0.0  4.0 ) * ( 2.0 )          ( 5.0 ) = (  62.0 )
       //         ( 5.0  6.0  0.0 ) * ( 3.0 )          ( 6.0 ) = (  70.7 )
       //         ( 7.0  0.0  8.0 ) *                  ( 7.0 ) = ( 123.8 )

       int m = 4;
       int n = 3;
       int nnz = 8;

       // CSR row pointers
       int hcsrRowPtr[5] = {0, 2, 4, 6, 8};

       // CSR column indices
       int hcsrColInd[8] = {0, 2, 0, 2, 0, 1, 0, 2};

       // CSR values
       double hcsrVal[8] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};

       // Transposition of the matrix
       hipsparseOperation_t trans = HIPSPARSE_OPERATION_NON_TRANSPOSE;

       // Scalar alpha and beta
       double alpha = 3.7;
       double beta  = 1.3;

       // x and y
       double hx[3] = {1.0, 2.0, 3.0};
       double hy[4] = {4.0, 5.0, 6.0, 7.0};

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Offload data to device
       int* dcsrRowPtr;
       int* dcsrColInd;
       double*        dcsrVal;
       double*        dx;
       double*        dy;

       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(double) * nnz);
       hipMalloc((void**)&dx, sizeof(double) * n);
       hipMalloc((void**)&dy, sizeof(double) * m);

       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(double) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dx, hx, sizeof(double) * n, hipMemcpyHostToDevice);
       hipMemcpy(dy, hy, sizeof(double) * m, hipMemcpyHostToDevice);

       // Call dcsrmv to perform y = alpha * A x + beta * y
       hipsparseDcsrmv(handle,
                       trans,
                       m,
                       n,
                       nnz,
                       &alpha,
                       descr,
                       dcsrVal,
                       dcsrRowPtr,
                       dcsrColInd,
                       dx,
                       &beta,
                       dy);

       // Copy result back to host
       hipMemcpy(hy, dy, sizeof(double) * m, hipMemcpyDeviceToHost);

       // Clear hipSPARSE
       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);
       hipFree(dx);
       hipFree(dy);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseScsrmv__retval = hipsparseStatus_t(chipsparse.hipsparseScsrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr))
    return (_hipsparseScsrmv__retval,)


@cython.embedsignature(True)
def hipsparseDcsrmv(object handle, object transA, int m, int n, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDcsrmv__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr))
    return (_hipsparseDcsrmv__retval,)


@cython.embedsignature(True)
def hipsparseCcsrmv(object handle, object transA, int m, int n, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCcsrmv__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,nnz,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        float2.fromPyobj(x).getElementPtr(),
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr()))
    return (_hipsparseCcsrmv__retval,)


@cython.embedsignature(True)
def hipsparseZcsrmv(object handle, object transA, int m, int n, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZcsrmv__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,nnz,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        double2.fromPyobj(x).getElementPtr(),
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr()))
    return (_hipsparseZcsrmv__retval,)


@cython.embedsignature(True)
def hipsparseXcsrsv2_zeroPivot(object handle, object info, object position):
    r"""Sparse triangular solve using CSR storage format

    ``hipsparseXcsrsv2_zeroPivot`` returns ``HIPSPARSE_STATUS_ZERO_PIVOT`` , if either a
    structural or numerical zero has been found during hipsparseScsrsv2_solve(),
    hipsparseDcsrsv2_solve(), hipsparseCcsrsv2_solve() or hipsparseZcsrsv2_solve()
    computation. The first zero pivot :math:`j` at :math:`A_{j,j}` is stored in ``position,``
    using same index base as the CSR matrix.

    ``position`` can be in host or device memory. If no zero pivot has been found,
    ``position`` is set to -1 and ``HIPSPARSE_STATUS_SUCCESS`` is returned instead.

    Note:
        ``hipsparseXcsrsv2_zeroPivot`` is a blocking function. It might influence
        performance negatively.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        position (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcsrsv2_zeroPivot__retval = hipsparseStatus_t(chipsparse.hipsparseXcsrsv2_zeroPivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(position)._ptr))
    return (_hipsparseXcsrsv2_zeroPivot__retval,)


@cython.embedsignature(True)
def hipsparseScsrsv2_bufferSize(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""Sparse triangular solve using CSR storage format

    ``hipsparseXcsrsv2_bufferSize`` returns the size of the temporary storage buffer in bytes
    that is required by hipsparseScsrsv2_analysis(), hipsparseDcsrsv2_analysis(),
    hipsparseCcsrsv2_analysis(), hipsparseZcsrsv2_analysis(), hipsparseScsrsv2_solve(),
    hipsparseDcsrsv2_solve(), hipsparseCcsrsv2_solve() and hipsparseZcsrsv2_solve(). The
    temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseScsrsv2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseScsrsv2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsrsv2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDcsrsv2_bufferSize(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDcsrsv2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrsv2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsrsv2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCcsrsv2_bufferSize(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCcsrsv2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrsv2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsrsv2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZcsrsv2_bufferSize(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZcsrsv2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrsv2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsrsv2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseScsrsv2_bufferSizeExt(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""Sparse triangular solve using CSR storage format

    ``hipsparseXcsrsv2_bufferSizeExt`` returns the size of the temporary storage buffer in bytes
    that is required by hipsparseScsrsv2_analysis(), hipsparseDcsrsv2_analysis(),
    hipsparseCcsrsv2_analysis(), hipsparseZcsrsv2_analysis(), hipsparseScsrsv2_solve(),
    hipsparseDcsrsv2_solve(), hipsparseCcsrsv2_solve() and hipsparseZcsrsv2_solve(). The
    temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseScsrsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseScsrsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsrsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDcsrsv2_bufferSizeExt(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDcsrsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsrsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCcsrsv2_bufferSizeExt(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCcsrsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsrsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZcsrsv2_bufferSizeExt(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZcsrsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsrsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseScsrsv2_analysis(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""Sparse triangular solve using CSR storage format

    ``hipsparseXcsrsv2_analysis`` performs the analysis step for hipsparseScsrsv2_solve(),
    hipsparseDcsrsv2_solve(), hipsparseCcsrsv2_solve() and hipsparseZcsrsv2_solve().

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseScsrsv2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseScsrsv2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsrsv2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseDcsrsv2_analysis(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDcsrsv2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrsv2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsrsv2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseCcsrsv2_analysis(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCcsrsv2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrsv2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsrsv2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseZcsrsv2_analysis(object handle, object transA, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZcsrsv2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrsv2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsrsv2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseScsrsv2_solve(object handle, object transA, int m, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object f, object x, object policy, object pBuffer):
    r"""Sparse triangular solve using CSR storage format

    ``hipsparseXcsrsv2_solve`` solves a sparse triangular linear system of a sparse
    :math:`m \times m` matrix, defined in CSR storage format, a dense solution vector
    :math:`y` and the right-hand side :math:`x` that is multiplied by :math:`\alpha`, such that

    .. math::

       op(A) \cdot y = \alpha \cdot x,

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    Note:
        The sparse CSR matrix has to be sorted. This can be achieved by calling
        hipsparseXcsrsort().

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``trans`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` and
        ``trans`` == ``HIPSPARSE_OPERATION_TRANSPOSE`` is supported.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // alpha * ( 1.0  0.0  2.0  0.0 ) * ( x_0 ) = ( 32.0 )
       //         ( 3.0  2.0  4.0  1.0 ) * ( x_1 ) = ( 14.7 )
       //         ( 5.0  6.0  1.0  3.0 ) * ( x_2 ) = ( 33.6 )
       //         ( 7.0  0.0  8.0  0.6 ) * ( x_3 ) = ( 10.0 )

       int m = 4;
       int nnz = 13;

       // CSR row pointers
       int hcsrRowPtr[5] = {0, 2, 6, 10, 13};

       // CSR column indices
       int hcsrColInd[13] = {0, 2, 0, 1, 2, 3, 0, 1, 2, 3, 0, 2, 3};

       // CSR values
       double hcsrVal[13] = {1.0, 2.0, 3.0, 2.0, 4.0, 1.0, 5.0, 6.0, 1.0, 3.0, 7.0, 8.0, 0.6};

       // Transposition of the matrix
       hipsparseOperation_t trans = HIPSPARSE_OPERATION_NON_TRANSPOSE;
       hipsparseSolvePolicy_t policy = HIPSPARSE_SOLVE_POLICY_USE_LEVEL;

       // Scalar alpha
       double alpha = 1.0;

       // f and x
       double hf[4] = {32.0, 14.7, 33.6, 10.0};
       double hx[4];

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Set index base on descriptor
       hipsparseSetMatIndexBase(descr, HIPSPARSE_INDEX_BASE_ZERO);

       // Set fill mode on descriptor
       hipsparseSetMatFillMode(descr, HIPSPARSE_FILL_MODE_LOWER);

       // Set diag type on descriptor
       hipsparseSetMatDiagType(descr, HIPSPARSE_DIAG_TYPE_UNIT);

       // Csrsv info
       csrsv2Info_t info;
       hipsparseCreateCsrsv2Info(&info);

       // Offload data to device
       int* dcsrRowPtr;
       int* dcsrColInd;
       double*        dcsrVal;
       double*        df;
       double*        dx;

       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(double) * nnz);
       hipMalloc((void**)&df, sizeof(double) * m);
       hipMalloc((void**)&dx, sizeof(double) * m);

       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(double) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(df, hf, sizeof(double) * m, hipMemcpyHostToDevice);

       int bufferSize = 0;
       hipsparseDcsrsv2_bufferSize(handle,
                                   trans,
                                   m,
                                   nnz,
                                   descr,
                                   dcsrVal,
                                   dcsrRowPtr,
                                   dcsrColInd,
                                   info,
                                   &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       hipsparseDcsrsv2_analysis(handle,
                                 trans,
                                 m,
                                 nnz,
                                 descr,
                                 dcsrVal,
                                 dcsrRowPtr,
                                 dcsrColInd,
                                 info,
                                 policy,
                                 dbuffer);

       // Call dcsrsv to perform alpha * A * x = f
       hipsparseDcsrsv2_solve(handle,
                              trans,
                              m,
                              nnz,
                              &alpha,
                              descr,
                              dcsrVal,
                              dcsrRowPtr,
                              dcsrColInd,
                              info,
                              df,
                              dx,
                              policy,
                              dbuffer);

       // Copy result back to host
       hipMemcpy(hx, dx, sizeof(double) * m, hipMemcpyDeviceToHost);

       // Clear hipSPARSE
       hipsparseDestroyMatDescr(descr);
       hipsparseDestroyCsrsv2Info(info);
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);
       hipFree(df);
       hipFree(dx);
       hipFree(dbuffer);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        f (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseScsrsv2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseScsrsv2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <const float *>hip._util.types.Pointer.fromPyobj(f)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsrsv2_solve__retval,)


@cython.embedsignature(True)
def hipsparseDcsrsv2_solve(object handle, object transA, int m, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object f, object x, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        f (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDcsrsv2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrsv2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        <const double *>hip._util.types.Pointer.fromPyobj(f)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsrsv2_solve__retval,)


@cython.embedsignature(True)
def hipsparseCcsrsv2_solve(object handle, object transA, int m, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object f, object x, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        f (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCcsrsv2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrsv2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        float2.fromPyobj(f).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsrsv2_solve__retval,)


@cython.embedsignature(True)
def hipsparseZcsrsv2_solve(object handle, object transA, int m, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object f, object x, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsv2Info`/`~.object`):
            (undocumented)

        f (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZcsrsv2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrsv2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,nnz,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrsv2Info.fromPyobj(info).getElementPtr(),
        double2.fromPyobj(f).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsrsv2_solve__retval,)


@cython.embedsignature(True)
def hipsparseShybmv(object handle, object transA, object alpha, object descrA, object hybA, object x, object beta, object y):
    r"""Sparse matrix vector multiplication using HYB storage format

    ``hipsparseXhybmv`` multiplies the scalar :math:`\alpha` with a sparse :math:`m \times n`
    matrix, defined in HYB storage format, and the dense vector :math:`x` and adds the
    result to the dense vector :math:`y` that is multiplied by the scalar :math:`\beta`,
    such that

    .. math::

       y := \alpha \cdot op(A) \cdot x + \beta \cdot y,

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``trans`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` is supported.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // A sparse matrix
       // 1 0 3 4
       // 0 0 5 1
       // 0 2 0 0
       // 4 0 0 8
       int hAptr[5] = {0, 3, 5, 6, 8};
       int hAcol[8] = {0, 2, 3, 2, 3, 1, 0, 3};
       double hAval[8] = {1.0, 3.0, 4.0, 5.0, 1.0, 2.0, 4.0, 8.0};

       int m = 4;
       int n = 4;
       int nnz = 8;

       double halpha = 1.0;
       double hbeta  = 0.0;

       double  hx[4] = {1.0, 2.0, 3.0, 4.0};
       double  hy[4] = {4.0, 5.0, 6.0, 7.0};

       // Matrix descriptor
       hipsparseMatDescr_t descrA;
       hipsparseCreateMatDescr(&descrA);

       // Offload data to device
       int* dAptr = NULL;
       int* dAcol = NULL;
       double*        dAval = NULL;
       double*        dx    = NULL;
       double*        dy    = NULL;

       hipMalloc((void**)&dAptr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dAcol, sizeof(int) * nnz);
       hipMalloc((void**)&dAval, sizeof(double) * nnz);
       hipMalloc((void**)&dx, sizeof(double) * n);
       hipMalloc((void**)&dy, sizeof(double) * m);

       hipMemcpy(dAptr, hAptr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dAcol, hAcol, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dAval, hAval, sizeof(double) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dx, hx, sizeof(double) * n, hipMemcpyHostToDevice);

       // Convert CSR matrix to HYB format
       hipsparseHybMat_t hybA;
       hipsparseCreateHybMat(&hybA);

       hipsparseDcsr2hyb(handle, m, n, descrA, dAval, dAptr, dAcol, hybA, 0, HIPSPARSE_HYB_PARTITION_AUTO);

       // Clean up CSR structures
       hipFree(dAptr);
       hipFree(dAcol);
       hipFree(dAval);

       // Call hipsparse hybmv
       hipsparseDhybmv(handle, HIPSPARSE_OPERATION_NON_TRANSPOSE, &halpha, descrA, hybA, dx, &hbeta, dy);

       // Copy result back to host
       hipMemcpy(hy, dy, sizeof(double) * m, hipMemcpyDeviceToHost);

       // Clear up on device
       hipsparseDestroyHybMat(hybA);
       hipsparseDestroyMatDescr(descrA);
       hipsparseDestroy(handle);

       hipFree(dx);
       hipFree(dy);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseShybmv__retval = hipsparseStatus_t(chipsparse.hipsparseShybmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(hybA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr))
    return (_hipsparseShybmv__retval,)


@cython.embedsignature(True)
def hipsparseDhybmv(object handle, object transA, object alpha, object descrA, object hybA, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDhybmv__retval = hipsparseStatus_t(chipsparse.hipsparseDhybmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(hybA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr))
    return (_hipsparseDhybmv__retval,)


@cython.embedsignature(True)
def hipsparseChybmv(object handle, object transA, object alpha, object descrA, object hybA, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseChybmv__retval = hipsparseStatus_t(chipsparse.hipsparseChybmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(hybA)._ptr,
        float2.fromPyobj(x).getElementPtr(),
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr()))
    return (_hipsparseChybmv__retval,)


@cython.embedsignature(True)
def hipsparseZhybmv(object handle, object transA, object alpha, object descrA, object hybA, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZhybmv__retval = hipsparseStatus_t(chipsparse.hipsparseZhybmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(hybA)._ptr,
        double2.fromPyobj(x).getElementPtr(),
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr()))
    return (_hipsparseZhybmv__retval,)


@cython.embedsignature(True)
def hipsparseSbsrmv(object handle, object dirA, object transA, int mb, int nb, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object x, object beta, object y):
    r"""Sparse matrix vector multiplication using BSR storage format

    ``hipsparseXbsrmv`` multiplies the scalar :math:`\alpha` with a sparse

    math:`(mb \cdot \text{blockDim}) \times (nb \cdot \text{blockDim})`
    matrix, defined in BSR storage format, and the dense vector :math:`x` and adds the
    result to the dense vector :math:`y` that is multiplied by the scalar :math:`\beta`,
    such that

    .. math::

       y := \alpha \cdot op(A) \cdot x + \beta \cdot y,

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``trans`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` is supported.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // alpha * ( 1.0  0.0  2.0 ) * ( 1.0 ) + beta * ( 4.0 ) = (  31.1 )
       //         ( 3.0  0.0  4.0 ) * ( 2.0 )          ( 5.0 ) = (  62.0 )
       //         ( 5.0  6.0  0.0 ) * ( 3.0 )          ( 6.0 ) = (  70.7 )
       //         ( 7.0  0.0  8.0 ) *                  ( 7.0 ) = ( 123.8 )

       // BSR block dimension
       int bsr_dim = 2;

       // Number of block rows and columns
       int mb = 2;
       int nb = 2;

       // Number of non-zero blocks
       int nnzb = 4;

       // BSR row pointers
       int hbsrRowPtr[3] = {0, 2, 4};

       // BSR column indices
       int hbsrColInd[4] = {0, 1, 0, 1};

       // BSR values
       double hbsrVal[16]
         = {1.0, 3.0, 0.0, 0.0, 2.0, 4.0, 0.0, 0.0, 5.0, 7.0, 6.0, 0.0, 0.0, 8.0, 0.0, 0.0};

       // Block storage in column major
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_COLUMN;

       // Transposition of the matrix
       hipsparseOperation_t trans = HIPSPARSE_OPERATION_NON_TRANSPOSE;

       // Scalar alpha and beta
       double alpha = 3.7;
       double beta  = 1.3;

       // x and y
       double hx[4] = {1.0, 2.0, 3.0, 0.0};
       double hy[4] = {4.0, 5.0, 6.0, 7.0};

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Offload data to device
       int* dbsrRowPtr;
       int* dbsrColInd;
       double*        dbsrVal;
       double*        dx;
       double*        dy;

       hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
       hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
       hipMalloc((void**)&dbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim);
       hipMalloc((void**)&dx, sizeof(double) * nb * bsr_dim);
       hipMalloc((void**)&dy, sizeof(double) * mb * bsr_dim);

       hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
       hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
       hipMemcpy(dbsrVal, hbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim, hipMemcpyHostToDevice);
       hipMemcpy(dx, hx, sizeof(double) * nb * bsr_dim, hipMemcpyHostToDevice);
       hipMemcpy(dy, hy, sizeof(double) * mb * bsr_dim, hipMemcpyHostToDevice);

       // Call dbsrmv to perform y = alpha * A x + beta * y
       hipsparseDbsrmv(handle,
                       dir,
                       trans,
                       mb,
                       nb,
                       nnzb,
                       &alpha,
                       descr,
                       dbsrVal,
                       dbsrRowPtr,
                       dbsrColInd,
                       bsr_dim,
                       dx,
                       &beta,
                       dy);

       // Copy result back to host
       hipMemcpy(hy, dy, sizeof(double) * mb * bsr_dim, hipMemcpyDeviceToHost);

       // Clear hipSPARSE
       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dbsrRowPtr);
       hipFree(dbsrColInd);
       hipFree(dbsrVal);
       hipFree(dx);
       hipFree(dy);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseSbsrmv__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nb,nnzb,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr))
    return (_hipsparseSbsrmv__retval,)


@cython.embedsignature(True)
def hipsparseDbsrmv(object handle, object dirA, object transA, int mb, int nb, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDbsrmv__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nb,nnzb,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr))
    return (_hipsparseDbsrmv__retval,)


@cython.embedsignature(True)
def hipsparseCbsrmv(object handle, object dirA, object transA, int mb, int nb, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCbsrmv__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nb,nnzb,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        float2.fromPyobj(x).getElementPtr(),
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr()))
    return (_hipsparseCbsrmv__retval,)


@cython.embedsignature(True)
def hipsparseZbsrmv(object handle, object dirA, object transA, int mb, int nb, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZbsrmv__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nb,nnzb,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        double2.fromPyobj(x).getElementPtr(),
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr()))
    return (_hipsparseZbsrmv__retval,)


@cython.embedsignature(True)
def hipsparseSbsrxmv(object handle, object dir, object trans, int sizeOfMask, int mb, int nb, int nnzb, object alpha, object descr, object bsrVal, object bsrMaskPtr, object bsrRowPtr, object bsrEndPtr, object bsrColInd, int blockDim, object x, object beta, object y):
    r"""Sparse matrix vector multiplication with mask operation using BSR storage format

    ``hipsparseXbsrxmv`` multiplies the scalar :math:`\alpha` with a sparse

    math:`(mb \cdot \text{blockDim}) \times (nb \cdot \text{blockDim})`
    modified matrix, defined in BSR storage format, and the dense vector :math:`x` and adds the
    result to the dense vector :math:`y` that is multiplied by the scalar :math:`\beta`,
    such that

    .. math::

       y := \left( \alpha \cdot op(A) \cdot x + \beta \cdot y \right)\left( \text{mask} \right),

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``trans`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` is supported.
        Currently, ``blockDim`` == 1 is not supported.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        trans (`~.hipsparseOperation_t`):
            (undocumented)

        sizeOfMask (`~.int`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrMaskPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrEndPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(trans,_hipsparseOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseSbsrxmv__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrxmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,trans.value,sizeOfMask,mb,nb,nnzb,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrMaskPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrEndPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,blockDim,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr))
    return (_hipsparseSbsrxmv__retval,)


@cython.embedsignature(True)
def hipsparseDbsrxmv(object handle, object dir, object trans, int sizeOfMask, int mb, int nb, int nnzb, object alpha, object descr, object bsrVal, object bsrMaskPtr, object bsrRowPtr, object bsrEndPtr, object bsrColInd, int blockDim, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        trans (`~.hipsparseOperation_t`):
            (undocumented)

        sizeOfMask (`~.int`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrMaskPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrEndPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(trans,_hipsparseOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDbsrxmv__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrxmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,trans.value,sizeOfMask,mb,nb,nnzb,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrMaskPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrEndPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,blockDim,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr))
    return (_hipsparseDbsrxmv__retval,)


@cython.embedsignature(True)
def hipsparseCbsrxmv(object handle, object dir, object trans, int sizeOfMask, int mb, int nb, int nnzb, object alpha, object descr, object bsrVal, object bsrMaskPtr, object bsrRowPtr, object bsrEndPtr, object bsrColInd, int blockDim, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        trans (`~.hipsparseOperation_t`):
            (undocumented)

        sizeOfMask (`~.int`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrVal (`~.float2`/`~.object`):
            (undocumented)

        bsrMaskPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrEndPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(trans,_hipsparseOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCbsrxmv__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrxmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,trans.value,sizeOfMask,mb,nb,nnzb,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        float2.fromPyobj(bsrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrMaskPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrEndPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,blockDim,
        float2.fromPyobj(x).getElementPtr(),
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr()))
    return (_hipsparseCbsrxmv__retval,)


@cython.embedsignature(True)
def hipsparseZbsrxmv(object handle, object dir, object trans, int sizeOfMask, int mb, int nb, int nnzb, object alpha, object descr, object bsrVal, object bsrMaskPtr, object bsrRowPtr, object bsrEndPtr, object bsrColInd, int blockDim, object x, object beta, object y):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        trans (`~.hipsparseOperation_t`):
            (undocumented)

        sizeOfMask (`~.int`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrVal (`~.double2`/`~.object`):
            (undocumented)

        bsrMaskPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrEndPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(trans,_hipsparseOperation_t__Base):
        raise TypeError("argument 'trans' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZbsrxmv__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrxmv(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,trans.value,sizeOfMask,mb,nb,nnzb,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        double2.fromPyobj(bsrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrMaskPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrEndPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,blockDim,
        double2.fromPyobj(x).getElementPtr(),
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr()))
    return (_hipsparseZbsrxmv__retval,)


@cython.embedsignature(True)
def hipsparseXbsrsv2_zeroPivot(object handle, object info, object position):
    r"""Sparse triangular solve using BSR storage format

    ``hipsparseXbsrsv2_zeroPivot`` returns ``HIPSPARSE_STATUS_ZERO_PIVOT`` , if either a
    structural or numerical zero has been found during hipsparseXbsrsv2_analysis() or
    hipsparseXbsrsv2_solve() computation. The first zero pivot :math:`j` at :math:`A_{j,j}`
    is stored in ``position,`` using same index base as the BSR matrix.

    ``position`` can be in host or device memory. If no zero pivot has been found,
    ``position`` is set to -1 and ``HIPSPARSE_STATUS_SUCCESS`` is returned instead.

    Note:
        ``hipsparseXbsrsv2_zeroPivot`` is a blocking function. It might influence
        performance negatively.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        position (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXbsrsv2_zeroPivot__retval = hipsparseStatus_t(chipsparse.hipsparseXbsrsv2_zeroPivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(position)._ptr))
    return (_hipsparseXbsrsv2_zeroPivot__retval,)


@cython.embedsignature(True)
def hipsparseSbsrsv2_bufferSize(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""Sparse triangular solve using BSR storage format

    ``hipsparseXbsrsv2_bufferSize`` returns the size of the temporary storage buffer in bytes
    that is required by hipsparseXbsrsv2_analysis() and hipsparseXbsrsv2_solve(). The
    temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseSbsrsv2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrsv2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSbsrsv2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDbsrsv2_bufferSize(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDbsrsv2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrsv2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDbsrsv2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCbsrsv2_bufferSize(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCbsrsv2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrsv2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCbsrsv2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZbsrsv2_bufferSize(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZbsrsv2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrsv2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZbsrsv2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSbsrsv2_bufferSizeExt(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""Sparse triangular solve using BSR storage format

    ``hipsparseXbsrsv2_bufferSizeExt`` returns the size of the temporary storage buffer in bytes
    that is required by hipsparseXbsrsv2_analysis() and hipsparseXbsrsv2_solve(). The
    temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseSbsrsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSbsrsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDbsrsv2_bufferSizeExt(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDbsrsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDbsrsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCbsrsv2_bufferSizeExt(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCbsrsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCbsrsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZbsrsv2_bufferSizeExt(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZbsrsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZbsrsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseSbsrsv2_analysis(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""Sparse triangular solve using BSR storage format

    ``hipsparseXbsrsv2_analysis`` performs the analysis step for hipsparseXbsrsv2_solve().

    Note:
        If the matrix sparsity pattern changes, the gathered information will become invalid.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseSbsrsv2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrsv2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSbsrsv2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseDbsrsv2_analysis(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDbsrsv2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrsv2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDbsrsv2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseCbsrsv2_analysis(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCbsrsv2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrsv2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCbsrsv2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseZbsrsv2_analysis(object handle, object dirA, object transA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZbsrsv2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrsv2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZbsrsv2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseSbsrsv2_solve(object handle, object dirA, object transA, int mb, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object f, object x, object policy, object pBuffer):
    r"""Sparse triangular solve using BSR storage format

    ``hipsparseXbsrsv2_solve`` solves a sparse triangular linear system of a sparse
    :math:`m \times m` matrix, defined in BSR storage format, a dense solution vector
    :math:`y` and the right-hand side :math:`x` that is multiplied by :math:`\alpha`, such that

    .. math::

       op(A) \cdot y = \alpha \cdot x,

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    Note:
        The sparse BSR matrix has to be sorted.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``trans`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` and
        ``trans`` == ``HIPSPARSE_OPERATION_TRANSPOSE`` is supported.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // A = ( 1.0  0.0  0.0  0.0 )
       //     ( 2.0  3.0  0.0  0.0 )
       //     ( 4.0  5.0  6.0  0.0 )
       //     ( 7.0  0.0  8.0  9.0 )
       //
       // with bsr_dim = 2
       //
       //      -------------------
       //   = | 1.0 0.0 | 0.0 0.0 |
       //     | 2.0 3.0 | 0.0 0.0 |
       //      -------------------
       //     | 4.0 5.0 | 6.0 0.0 |
       //     | 7.0 0.0 | 8.0 9.0 |
       //      -------------------

       // Number of rows and columns
       int m = 4;

       // Number of block rows and block columns
       int mb = 2;
       int nb = 2;

       // BSR block dimension
       int bsr_dim = 2;

       // Number of non-zero blocks
       int nnzb = 3;

       // BSR row pointers
       int hbsrRowPtr[3] = {0, 1, 3};

       // BSR column indices
       int hbsrColInd[3] = {0, 0, 1};

       // BSR values
       double hbsrVal[12] = {1.0, 2.0, 0.0, 3.0, 4.0, 7.0, 5.0, 0.0, 6.0, 8.0, 0.0, 9.0};

       // Storage scheme of the BSR blocks
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_COLUMN;

       // Transposition of the matrix and rhs matrix
       hipsparseOperation_t trans = HIPSPARSE_OPERATION_NON_TRANSPOSE;

       // Solve policy
       hipsparseSolvePolicy_t solve_policy = HIPSPARSE_SOLVE_POLICY_USE_LEVEL;

       // Scalar alpha and beta
       double alpha = 3.7;

       double hx[4] = {1, 2, 3, 4};
       double hy[4];

       // Offload data to device
       int* dbsrRowPtr;
       int* dbsrColInd;
       double* dbsrVal;
       double* dx;
       double* dy;

       hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
       hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
       hipMalloc((void**)&dbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim);
       hipMalloc((void**)&dx, sizeof(double) * nb * bsr_dim);
       hipMalloc((void**)&dy, sizeof(double) * mb * bsr_dim);

       hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
       hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
       hipMemcpy(dbsrVal, hbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim, hipMemcpyHostToDevice);
       hipMemcpy(dx, hx, sizeof(double) * nb * bsr_dim, hipMemcpyHostToDevice);

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Matrix fill mode
       hipsparseSetMatFillMode(descr, HIPSPARSE_FILL_MODE_LOWER);

       // Matrix diagonal type
       hipsparseSetMatDiagType(descr, HIPSPARSE_DIAG_TYPE_UNIT);

       // Matrix info structure
       bsrsv2Info_t info;
       hipsparseCreateBsrsv2Info(&info);

       // Obtain required buffer size
       int buffer_size;
       hipsparseDbsrsv2_bufferSize(handle,
                                   dir,
                                   trans,
                                   mb,
                                   nnzb,
                                   descr,
                                   dbsrVal,
                                   dbsrRowPtr,
                                   dbsrColInd,
                                   bsr_dim,
                                   info,
                                   &buffer_size);

       // Allocate temporary buffer
       void* dbuffer;
       hipMalloc(&dbuffer, buffer_size);

       // Perform analysis step
       hipsparseDbsrsv2_analysis(handle,
                                 dir,
                                 trans,
                                 mb,
                                 nnzb,
                                 descr,
                                 dbsrVal,
                                 dbsrRowPtr,
                                 dbsrColInd,
                                 bsr_dim,
                                 info,
                                 solve_policy,
                                 dbuffer);

       // Call dbsrsm to perform lower triangular solve LX = B
       hipsparseDbsrsv2_solve(handle,
                              dir,
                              trans,
                              mb,
                              nnzb,
                              &alpha,
                              descr,
                              dbsrVal,
                              dbsrRowPtr,
                              dbsrColInd,
                              bsr_dim,
                              info,
                              dx,
                              dy,
                              solve_policy,
                              dbuffer);

       // Check for zero pivots
       int    pivot;
       hipsparseStatus_t status = hipsparseXbsrsv2_zeroPivot(handle, info, &pivot);

       if(status == HIPSPARSE_STATUS_ZERO_PIVOT)
       {
           std::cout << "Found zero pivot in matrix row " << pivot << std::endl;
       }

       // Copy results back to the host
       hipMemcpy(hy, dy, sizeof(double) * mb * bsr_dim, hipMemcpyDeviceToHost);

       // Clear hipSPARSE
       hipsparseDestroyBsrsv2Info(info);
       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dbsrRowPtr);
       hipFree(dbsrColInd);
       hipFree(dbsrVal);
       hipFree(dx);
       hipFree(dy);
       hipFree(dbuffer);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        f (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseSbsrsv2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrsv2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <const float *>hip._util.types.Pointer.fromPyobj(f)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSbsrsv2_solve__retval,)


@cython.embedsignature(True)
def hipsparseDbsrsv2_solve(object handle, object dirA, object transA, int mb, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object f, object x, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        f (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDbsrsv2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrsv2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        <const double *>hip._util.types.Pointer.fromPyobj(f)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDbsrsv2_solve__retval,)


@cython.embedsignature(True)
def hipsparseCbsrsv2_solve(object handle, object dirA, object transA, int mb, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object f, object x, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        f (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCbsrsv2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrsv2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        float2.fromPyobj(f).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCbsrsv2_solve__retval,)


@cython.embedsignature(True)
def hipsparseZbsrsv2_solve(object handle, object dirA, object transA, int mb, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object f, object x, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsv2Info`/`~.object`):
            (undocumented)

        f (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZbsrsv2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrsv2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,mb,nnzb,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsv2Info.fromPyobj(info).getElementPtr(),
        double2.fromPyobj(f).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZbsrsv2_solve__retval,)


@cython.embedsignature(True)
def hipsparseSgemvi_bufferSize(object handle, object transA, int m, int n, int nnz, object pBufferSizeInBytes):
    r"""Dense matrix sparse vector multiplication

    ``hipsparseXgemvi_bufferSize`` returns the size of the temporary storage buffer in bytes
    required by hipsparseXgemvi(). The temporary storage buffer must be allocated by the
    user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseSgemvi_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSgemvi_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,nnz,
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSgemvi_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDgemvi_bufferSize(object handle, object transA, int m, int n, int nnz, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDgemvi_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDgemvi_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,nnz,
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDgemvi_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCgemvi_bufferSize(object handle, object transA, int m, int n, int nnz, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCgemvi_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCgemvi_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,nnz,
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCgemvi_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZgemvi_bufferSize(object handle, object transA, int m, int n, int nnz, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZgemvi_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZgemvi_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,nnz,
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZgemvi_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSgemvi(object handle, object transA, int m, int n, object alpha, object A, int lda, int nnz, object x, object xInd, object beta, object y, object idxBase, object pBuffer):
    r"""Dense matrix sparse vector multiplication

    ``hipsparseXgemvi`` multiplies the scalar :math:`\alpha` with a dense :math:`m \times n`
    matrix :math:`A` and the sparse vector :math:`x` and adds the result to the dense vector
    :math:`y` that is multiplied by the scalar :math:`\beta`, such that

    .. math::

       y := \alpha \cdot op(A) \cdot x + \beta \cdot y,

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``trans`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` is supported.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseSgemvi__retval = hipsparseStatus_t(chipsparse.hipsparseSgemvi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(y)._ptr,idxBase.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSgemvi__retval,)


@cython.embedsignature(True)
def hipsparseDgemvi(object handle, object transA, int m, int n, object alpha, object A, int lda, int nnz, object x, object xInd, object beta, object y, object idxBase, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseDgemvi__retval = hipsparseStatus_t(chipsparse.hipsparseDgemvi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(y)._ptr,idxBase.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDgemvi__retval,)


@cython.embedsignature(True)
def hipsparseCgemvi(object handle, object transA, int m, int n, object alpha, object A, int lda, int nnz, object x, object xInd, object beta, object y, object idxBase, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        y (`~.float2`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseCgemvi__retval = hipsparseStatus_t(chipsparse.hipsparseCgemvi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(A).getElementPtr(),lda,nnz,
        float2.fromPyobj(x).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(y).getElementPtr(),idxBase.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCgemvi__retval,)


@cython.embedsignature(True)
def hipsparseZgemvi(object handle, object transA, int m, int n, object alpha, object A, int lda, int nnz, object x, object xInd, object beta, object y, object idxBase, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        xInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        y (`~.double2`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseZgemvi__retval = hipsparseStatus_t(chipsparse.hipsparseZgemvi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(A).getElementPtr(),lda,nnz,
        double2.fromPyobj(x).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(xInd)._ptr,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(y).getElementPtr(),idxBase.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZgemvi__retval,)


@cython.embedsignature(True)
def hipsparseSbsrmm(object handle, object dirA, object transA, object transB, int mb, int n, int kb, int nnzb, object alpha, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object B, int ldb, object beta, object C, int ldc):
    r"""Sparse matrix dense matrix multiplication using BSR storage format

    ``hipsparseXbsrmm`` multiplies the scalar :math:`\alpha` with a sparse :math:`mb \times kb`
    matrix :math:`A`, defined in BSR storage format, and the dense :math:`k \times n`
    matrix :math:`B` (where :math:`k = block\_dim \times kb`) and adds the result to the dense
    :math:`m \times n` matrix :math:`C` (where :math:`m = block\_dim \times mb`) that
    is multiplied by the scalar :math:`\beta`, such that

    .. math::

       C := \alpha \cdot op(A) \cdot op(B) + \beta \cdot C,

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
       \end{array}
       \right.

    and

    .. math::

       op(B) = \left\{
       \begin{array}{ll}
           B,   & \text{if transB == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           B^T, & \text{if transB == HIPSPARSE_OPERATION_TRANSPOSE} \\
       \end{array}
       \right.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``transA`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` is supported.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       //     1 2 0 3 0 0
       // A = 0 4 5 0 0 0
       //     0 0 0 7 8 0
       //     0 0 1 2 4 1

       int blockDim = 2;
       int mb   = 2;
       int kb   = 3;
       int nnzb = 4;
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;

       int hbsrRowPtr[2 + 1]   = {0, 2, 4};
       int hbsrColInd[4]       = {0, 1, 1, 2};
       float hbsrVal[4 * 2 * 2] = {1, 2, 0, 4, 0, 3, 5, 0, 0, 7, 1, 2, 8, 0, 4, 1};

       // Set dimension n of B
       int n = 3;
       int m = mb * blockDim;
       int k = kb * blockDim;

       // Allocate and generate dense matrix B (k x n)
       float hB[6 * 3] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f,
                       11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f, 17.0f, 18.0f};

       int* dbsrRowPtr = NULL;
       int* dbsrColInd = NULL;
       float* dbsrVal = NULL;
       hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
       hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
       hipMalloc((void**)&dbsrVal, sizeof(float) * nnzb * blockDim * blockDim);
       hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
       hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
       hipMemcpy(dbsrVal, hbsrVal, sizeof(float) * nnzb * blockDim * blockDim, hipMemcpyHostToDevice);

       // Copy B to the device
       float* dB;
       hipMalloc((void**)&dB, sizeof(float) * k * n);
       hipMemcpy(dB, hB, sizeof(float) * k * n, hipMemcpyHostToDevice);

       // alpha and beta
       float alpha = 1.0f;
       float beta  = 0.0f;

       // Allocate memory for the resulting matrix C
       float* dC;
       hipMalloc((void**)&dC, sizeof(float) * m * n);

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Perform the matrix multiplication
       hipsparseSbsrmm(handle,
                       dir,
                       HIPSPARSE_OPERATION_NON_TRANSPOSE,
                       HIPSPARSE_OPERATION_NON_TRANSPOSE,
                       mb,
                       n,
                       kb,
                       nnzb,
                       &alpha,
                       descr,
                       dbsrVal,
                       dbsrRowPtr,
                       dbsrColInd,
                       blockDim,
                       dB,
                       k,
                       &beta,
                       dC,
                       m);

       // Copy results to host
       float hC[6 * 3];
       hipMemcpy(hC, dC, sizeof(float) * m * n, hipMemcpyDeviceToHost);

       hipFree(dbsrRowPtr);
       hipFree(dbsrColInd);
       hipFree(dbsrVal);
       hipFree(dB);
       hipFree(dC);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseSbsrmm__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transB.value,mb,n,kb,nnzb,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        <const float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc))
    return (_hipsparseSbsrmm__retval,)


@cython.embedsignature(True)
def hipsparseDbsrmm(object handle, object dirA, object transA, object transB, int mb, int n, int kb, int nnzb, object alpha, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object B, int ldb, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDbsrmm__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transB.value,mb,n,kb,nnzb,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        <const double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc))
    return (_hipsparseDbsrmm__retval,)


@cython.embedsignature(True)
def hipsparseCbsrmm(object handle, object dirA, object transA, object transB, int mb, int n, int kb, int nnzb, object alpha, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object B, int ldb, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        C (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCbsrmm__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transB.value,mb,n,kb,nnzb,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        float2.fromPyobj(B).getElementPtr(),ldb,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(C).getElementPtr(),ldc))
    return (_hipsparseCbsrmm__retval,)


@cython.embedsignature(True)
def hipsparseZbsrmm(object handle, object dirA, object transA, object transB, int mb, int n, int kb, int nnzb, object alpha, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object B, int ldb, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        kb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        C (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZbsrmm__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transB.value,mb,n,kb,nnzb,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        double2.fromPyobj(B).getElementPtr(),ldb,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(C).getElementPtr(),ldc))
    return (_hipsparseZbsrmm__retval,)


@cython.embedsignature(True)
def hipsparseScsrmm(object handle, object transA, int m, int n, int k, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object beta, object C, int ldc):
    r"""Sparse matrix dense matrix multiplication using CSR storage format

    ``hipsparseXcsrmm`` multiplies the scalar :math:`\alpha` with a sparse :math:`m \times k`
    matrix :math:`A`, defined in CSR storage format, and the dense :math:`k \times n`
    matrix :math:`B` and adds the result to the dense :math:`m \times n` matrix :math:`C` that
    is multiplied by the scalar :math:`\beta`, such that

    .. math::

       C := \alpha \cdot op(A) \cdot B + \beta \cdot C,

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if transA == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if transA == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    .. code-block::

       for(i = 0; i < ldc; ++i)
       {
           for(j = 0; j < n; ++j)
           {
               C[i][j] = beta * C[i][j];

               for(k = csrRowPtr[i]; k < csrRowPtr[i + 1]; ++k)
               {
                   C[i][j] += alpha * csrVal[k] * B[csrColInd[k]][j];
               }
           }
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       //     1 2 0 3 0 0
       // A = 0 4 5 0 0 0
       //     0 0 0 7 8 0
       //     0 0 1 2 4 1

       int m   = 4;
       int k   = 6;
       int nnz = 11;
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;

       int hcsrRowPtr[4 + 1] = {0, 3, 5, 7, 11};
       int hcsrColInd[11]    = {0, 1, 3, 1, 2, 3, 4, 2, 3, 4, 5};
       float hcsrVal[11]      = {1, 2, 3, 4, 5, 7, 8, 1, 2, 4, 1};

       // Set dimension n of B
       int n = 3;

       // Allocate and generate dense matrix B (k x n)
       float hB[6 * 3] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f,
                          11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f, 17.0f, 18.0f};

       int* dcsrRowPtr = NULL;
       int* dcsrColInd = NULL;
       float* dcsrVal = NULL;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       // Copy B to the device
       float* dB;
       hipMalloc((void**)&dB, sizeof(float) * k * n);
       hipMemcpy(dB, hB, sizeof(float) * k * n, hipMemcpyHostToDevice);

       // alpha and beta
       float alpha = 1.0f;
       float beta  = 0.0f;

       // Allocate memory for the resulting matrix C
       float* dC;
       hipMalloc((void**)&dC, sizeof(float) * m * n);

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Perform the matrix multiplication
       hipsparseScsrmm(handle,
                       HIPSPARSE_OPERATION_NON_TRANSPOSE,
                       m,
                       n,
                       k,
                       nnz,
                       &alpha,
                       descr,
                       dcsrVal,
                       dcsrRowPtr,
                       dcsrColInd,
                       dB,
                       k,
                       &beta,
                       dC,
                       m);

       // Copy results to host
       float hC[6 * 3];
       hipMemcpy(hC, dC, sizeof(float) * m * n, hipMemcpyDeviceToHost);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);
       hipFree(dB);
       hipFree(dC);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseScsrmm__retval = hipsparseStatus_t(chipsparse.hipsparseScsrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,k,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc))
    return (_hipsparseScsrmm__retval,)


@cython.embedsignature(True)
def hipsparseDcsrmm(object handle, object transA, int m, int n, int k, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDcsrmm__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,k,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc))
    return (_hipsparseDcsrmm__retval,)


@cython.embedsignature(True)
def hipsparseCcsrmm(object handle, object transA, int m, int n, int k, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        C (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCcsrmm__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,k,nnz,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        float2.fromPyobj(B).getElementPtr(),ldb,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(C).getElementPtr(),ldc))
    return (_hipsparseCcsrmm__retval,)


@cython.embedsignature(True)
def hipsparseZcsrmm(object handle, object transA, int m, int n, int k, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        C (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZcsrmm__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrmm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,m,n,k,nnz,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        double2.fromPyobj(B).getElementPtr(),ldb,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(C).getElementPtr(),ldc))
    return (_hipsparseZcsrmm__retval,)


@cython.embedsignature(True)
def hipsparseScsrmm2(object handle, object transA, object transB, int m, int n, int k, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object beta, object C, int ldc):
    r"""Sparse matrix dense matrix multiplication using CSR storage format

    ``hipsparseXcsrmm2`` multiplies the scalar :math:`\alpha` with a sparse :math:`m \times k`
    matrix :math:`A`, defined in CSR storage format, and the dense :math:`k \times n`
    matrix :math:`B` and adds the result to the dense :math:`m \times n` matrix :math:`C` that
    is multiplied by the scalar :math:`\beta`, such that

    .. math::

       C := \alpha \cdot op(A) \cdot op(B) + \beta \cdot C,

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if transA == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if transA == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    and

    .. math::

       op(B) = \left\{
       \begin{array}{ll}
           B,   & \text{if transB == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           B^T, & \text{if transB == HIPSPARSE_OPERATION_TRANSPOSE} \\
           B^H, & \text{if transB == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    .. code-block::

       for(i = 0; i < ldc; ++i)
       {
           for(j = 0; j < n; ++j)
           {
               C[i][j] = beta * C[i][j];

               for(k = csrRowPtr[i]; k < csrRowPtr[i + 1]; ++k)
               {
                   C[i][j] += alpha * csrVal[k] * B[csrColInd[k]][j];
               }
           }
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseScsrmm2__retval = hipsparseStatus_t(chipsparse.hipsparseScsrmm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc))
    return (_hipsparseScsrmm2__retval,)


@cython.embedsignature(True)
def hipsparseDcsrmm2(object handle, object transA, object transB, int m, int n, int k, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDcsrmm2__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrmm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc))
    return (_hipsparseDcsrmm2__retval,)


@cython.embedsignature(True)
def hipsparseCcsrmm2(object handle, object transA, object transB, int m, int n, int k, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        C (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCcsrmm2__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrmm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,nnz,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        float2.fromPyobj(B).getElementPtr(),ldb,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(C).getElementPtr(),ldc))
    return (_hipsparseCcsrmm2__retval,)


@cython.embedsignature(True)
def hipsparseZcsrmm2(object handle, object transA, object transB, int m, int n, int k, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        C (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZcsrmm2__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrmm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,nnz,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        double2.fromPyobj(B).getElementPtr(),ldb,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(C).getElementPtr(),ldc))
    return (_hipsparseZcsrmm2__retval,)


@cython.embedsignature(True)
def hipsparseXbsrsm2_zeroPivot(object handle, object info, object position):
    r"""Sparse triangular system solve using BSR storage format

    ``hipsparseXbsrsm2_zeroPivot`` returns ``HIPSPARSE_STATUS_ZERO_PIVOT`` , if either a
    structural or numerical zero has been found during hipsparseXbsrsm2_analysis() or
    hipsparseXbsrsm2_solve() computation. The first zero pivot :math:`j` at :math:`A_{j,j}`
    is stored in ``position,`` using same index base as the BSR matrix.

    ``position`` can be in host or device memory. If no zero pivot has been found,
    ``position`` is set to -1 and ``HIPSPARSE_STATUS_SUCCESS`` is returned instead.

    Note:
        ``hipsparseXbsrsm2_zeroPivot`` is a blocking function. It might influence
        performance negatively.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        position (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXbsrsm2_zeroPivot__retval = hipsparseStatus_t(chipsparse.hipsparseXbsrsm2_zeroPivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        bsrsm2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(position)._ptr))
    return (_hipsparseXbsrsm2_zeroPivot__retval,)


@cython.embedsignature(True)
def hipsparseSbsrsm2_bufferSize(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""Sparse triangular system solve using BSR storage format

    ``hipsparseXbsrsm2_buffer_size`` returns the size of the temporary storage buffer in bytes
    that is required by hipsparseXbsrsm2_analysis() and hipsparseXbsrsm2_solve(). The
    temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseSbsrsm2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrsm2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSbsrsm2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDbsrsm2_bufferSize(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDbsrsm2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrsm2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDbsrsm2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCbsrsm2_bufferSize(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCbsrsm2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrsm2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCbsrsm2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZbsrsm2_bufferSize(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZbsrsm2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrsm2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZbsrsm2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSbsrsm2_analysis(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""Sparse triangular system solve using BSR storage format

    ``hipsparseXbsrsm2_analysis`` performs the analysis step for hipsparseXbsrsm2_solve().

    Note:
        If the matrix sparsity pattern changes, the gathered information will become invalid.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseSbsrsm2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrsm2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSbsrsm2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseDbsrsm2_analysis(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDbsrsm2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrsm2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDbsrsm2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseCbsrsm2_analysis(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCbsrsm2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrsm2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCbsrsm2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseZbsrsm2_analysis(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZbsrsm2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrsm2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZbsrsm2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseSbsrsm2_solve(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object B, int ldb, object X, int ldx, object policy, object pBuffer):
    r"""Sparse triangular system solve using BSR storage format

    ``hipsparseXbsrsm2_solve`` solves a sparse triangular linear system of a sparse
    :math:`m \times m` matrix, defined in BSR storage format, a dense solution matrix
    :math:`X` and the right-hand side matrix :math:`B` that is multiplied by :math:`\alpha`, such that

    .. math::

       op(A) \cdot op(X) = \alpha \cdot op(B),

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if transA == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if transA == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    ,

    .. math::

       op(X) = \left\{
       \begin{array}{ll}
           X,   & \text{if transX == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           X^T, & \text{if transX == HIPSPARSE_OPERATION_TRANSPOSE} \\
           X^H, & \text{if transX == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    Note:
        The sparse BSR matrix has to be sorted.

    Note:
        Operation type of B and X must match, if :math:`op(B)=B, op(X)=X`.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``transA`` != ``HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE`` and
        ``transX`` != ``HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE`` is supported.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // A = ( 1.0  0.0  0.0  0.0 )
       //     ( 2.0  3.0  0.0  0.0 )
       //     ( 4.0  5.0  6.0  0.0 )
       //     ( 7.0  0.0  8.0  9.0 )
       //
       // with bsr_dim = 2
       //
       //      -------------------
       //   = | 1.0 0.0 | 0.0 0.0 |
       //     | 2.0 3.0 | 0.0 0.0 |
       //      -------------------
       //     | 4.0 5.0 | 6.0 0.0 |
       //     | 7.0 0.0 | 8.0 9.0 |
       //      -------------------

       // Number of rows and columns
       int m = 4;

       // Number of block rows and block columns
       int mb = 2;
       int nb = 2;

       // BSR block dimension
       int bsr_dim = 2;

       // Number of right-hand-sides
       int nrhs = 4;

       // Number of non-zero blocks
       int nnzb = 3;

       // BSR row pointers
       int hbsrRowPtr[3] = {0, 1, 3};

       // BSR column indices
       int hbsrColInd[3] = {0, 0, 1};

       // BSR values
       double hbsrVal[12] = {1.0, 2.0, 0.0, 3.0, 4.0, 7.0, 5.0, 0.0, 6.0, 8.0, 0.0, 9.0};

       // Storage scheme of the BSR blocks
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_COLUMN;

       // Transposition of the matrix and rhs matrix
       hipsparseOperation_t transA = HIPSPARSE_OPERATION_NON_TRANSPOSE;
       hipsparseOperation_t transX = HIPSPARSE_OPERATION_NON_TRANSPOSE;

       // Solve policy
       hipsparseSolvePolicy_t solve_policy = HIPSPARSE_SOLVE_POLICY_NO_LEVEL;

       // Scalar alpha and beta
       double alpha = 1.0;

       // rhs and solution matrix
       int ldb = nb * bsr_dim;
       int ldx = mb * bsr_dim;

       double hB[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
       double hX[16];

       // Offload data to device
       int* dbsrRowPtr;
       int* dbsrColInd;
       double*        dbsrVal;
       double*        dB;
       double*        dX;

       hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
       hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
       hipMalloc((void**)&dbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim);
       hipMalloc((void**)&dB, sizeof(double) * nb * bsr_dim * nrhs);
       hipMalloc((void**)&dX, sizeof(double) * mb * bsr_dim * nrhs);

       hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
       hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
       hipMemcpy(dbsrVal, hbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim, hipMemcpyHostToDevice);
       hipMemcpy(dB, hB, sizeof(double) * nb * bsr_dim * nrhs, hipMemcpyHostToDevice);

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Matrix fill mode
       hipsparseSetMatFillMode(descr, HIPSPARSE_FILL_MODE_LOWER);

       // Matrix diagonal type
       hipsparseSetMatDiagType(descr, HIPSPARSE_DIAG_TYPE_NON_UNIT);

       // Matrix info structure
       bsrsm2Info_t info;
       hipsparseCreateBsrsm2Info(&info);

       // Obtain required buffer size
       int buffer_size;
       hipsparseDbsrsm2_bufferSize(handle,
                                   dir,
                                   transA,
                                   transX,
                                   mb,
                                   nrhs,
                                   nnzb,
                                   descr,
                                   dbsrVal,
                                   dbsrRowPtr,
                                   dbsrColInd,
                                   bsr_dim,
                                   info,
                                   &buffer_size);

       // Allocate temporary buffer
       void* dbuffer;
       hipMalloc(&dbuffer, buffer_size);

       // Perform analysis step
       hipsparseDbsrsm2_analysis(handle,
                                 dir,
                                 transA,
                                 transX,
                                 mb,
                                 nrhs,
                                 nnzb,
                                 descr,
                                 dbsrVal,
                                 dbsrRowPtr,
                                 dbsrColInd,
                                 bsr_dim,
                                 info,
                                 solve_policy,
                                 dbuffer);

       // Call dbsrsm to perform lower triangular solve LX = B
       hipsparseDbsrsm2_solve(handle,
                              dir,
                              transA,
                              transX,
                              mb,
                              nrhs,
                              nnzb,
                              &alpha,
                              descr,
                              dbsrVal,
                              dbsrRowPtr,
                              dbsrColInd,
                              bsr_dim,
                              info,
                              dB,
                              ldb,
                              dX,
                              ldx,
                              solve_policy,
                              dbuffer);

       // Check for zero pivots
       int    pivot;
       hipsparseStatus_t status = hipsparseXbsrsm2_zeroPivot(handle, info, &pivot);

       if(status == HIPSPARSE_STATUS_ZERO_PIVOT)
       {
           std::cout << "Found zero pivot in matrix row " << pivot << std::endl;
       }

       // Copy result back to host
       hipMemcpy(hX, dX, sizeof(double) * mb * bsr_dim * nrhs, hipMemcpyDeviceToHost);

       // Clear hipSPARSE
       hipsparseDestroyBsrsm2Info(info);
       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dbsrRowPtr);
       hipFree(dbsrColInd);
       hipFree(dbsrVal);
       hipFree(dB);
       hipFree(dX);
       hipFree(dbuffer);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        X (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldx (`~.int`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseSbsrsm2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrsm2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),
        <const float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <float *>hip._util.types.Pointer.fromPyobj(X)._ptr,ldx,policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSbsrsm2_solve__retval,)


@cython.embedsignature(True)
def hipsparseDbsrsm2_solve(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object B, int ldb, object X, int ldx, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        X (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldx (`~.int`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDbsrsm2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrsm2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),
        <const double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <double *>hip._util.types.Pointer.fromPyobj(X)._ptr,ldx,policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDbsrsm2_solve__retval,)


@cython.embedsignature(True)
def hipsparseCbsrsm2_solve(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object B, int ldb, object X, int ldx, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        X (`~.float2`/`~.object`):
            (undocumented)

        ldx (`~.int`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCbsrsm2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrsm2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),
        float2.fromPyobj(B).getElementPtr(),ldb,
        float2.fromPyobj(X).getElementPtr(),ldx,policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCbsrsm2_solve__retval,)


@cython.embedsignature(True)
def hipsparseZbsrsm2_solve(object handle, object dirA, object transA, object transX, int mb, int nrhs, int nnzb, object alpha, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object B, int ldb, object X, int ldx, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transX (`~.hipsparseOperation_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrsm2Info`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        X (`~.double2`/`~.object`):
            (undocumented)

        ldx (`~.int`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transX' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZbsrsm2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrsm2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,transA.value,transX.value,mb,nrhs,nnzb,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrsm2Info.fromPyobj(info).getElementPtr(),
        double2.fromPyobj(B).getElementPtr(),ldb,
        double2.fromPyobj(X).getElementPtr(),ldx,policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZbsrsm2_solve__retval,)


@cython.embedsignature(True)
def hipsparseXcsrsm2_zeroPivot(object handle, object info, object position):
    r"""Sparse triangular system solve using CSR storage format

    ``hipsparseXcsrsm2_zeroPivot`` returns ``HIPSPARSE_STATUS_ZERO_PIVOT`` , if either a
    structural or numerical zero has been found during hipsparseXcsrsm2_analysis() or
    hipsparseXcsrsm2_solve() computation. The first zero pivot :math:`j` at :math:`A_{j,j}`
    is stored in ``position,`` using same index base as the CSR matrix.

    ``position`` can be in host or device memory. If no zero pivot has been found,
    ``position`` is set to -1 and ``HIPSPARSE_STATUS_SUCCESS`` is returned instead.

    Note:
        ``hipsparseXcsrsm2_zeroPivot`` is a blocking function. It might influence
        performance negatively.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        position (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcsrsm2_zeroPivot__retval = hipsparseStatus_t(chipsparse.hipsparseXcsrsm2_zeroPivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        csrsm2Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(position)._ptr))
    return (_hipsparseXcsrsm2_zeroPivot__retval,)


@cython.embedsignature(True)
def hipsparseScsrsm2_bufferSizeExt(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBufferSizeInBytes):
    r"""Sparse triangular system solve using CSR storage format

    ``hipsparseXcsrsm2_bufferSizeExt`` returns the size of the temporary storage buffer
    in bytes that is required by hipsparseXcsrsm2_analysis() and hipsparseXcsrsm2_solve().
    The temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseScsrsm2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseScsrsm2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsrsm2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDcsrsm2_bufferSizeExt(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDcsrsm2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrsm2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsrsm2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCcsrsm2_bufferSizeExt(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCcsrsm2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrsm2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        float2.fromPyobj(B).getElementPtr(),ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsrsm2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZcsrsm2_bufferSizeExt(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZcsrsm2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrsm2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        double2.fromPyobj(B).getElementPtr(),ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsrsm2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseScsrsm2_analysis(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBuffer):
    r"""Sparse triangular system solve using CSR storage format

    ``hipsparseXcsrsm2_analysis`` performs the analysis step for hipsparseXcsrsm2_solve().

    Note:
        If the matrix sparsity pattern changes, the gathered information will become invalid.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseScsrsm2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseScsrsm2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsrsm2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseDcsrsm2_analysis(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDcsrsm2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrsm2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsrsm2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseCcsrsm2_analysis(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCcsrsm2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrsm2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        float2.fromPyobj(B).getElementPtr(),ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsrsm2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseZcsrsm2_analysis(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZcsrsm2_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrsm2_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        double2.fromPyobj(B).getElementPtr(),ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsrsm2_analysis__retval,)


@cython.embedsignature(True)
def hipsparseScsrsm2_solve(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBuffer):
    r"""Sparse triangular system solve using CSR storage format

    ``hipsparseXcsrsm2_solve`` solves a sparse triangular linear system of a sparse
    :math:`m \times m` matrix, defined in CSR storage format, a dense solution matrix
    :math:`X` and the right-hand side matrix :math:`B` that is multiplied by :math:`\alpha`, such that

    .. math::

       op(A) \cdot op(X) = \alpha \cdot op(B),

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if transA == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if transA == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    ,

    .. math::

       op(B) = \left\{
       \begin{array}{ll}
           B,   & \text{if transB == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           B^T, & \text{if transB == HIPSPARSE_OPERATION_TRANSPOSE} \\
           B^H, & \text{if transB == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    and

    .. math::

       op(X) = \left\{
       \begin{array}{ll}
           X,   & \text{if transB == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           X^T, & \text{if transB == HIPSPARSE_OPERATION_TRANSPOSE} \\
           X^H, & \text{if transB == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    Note:
        The sparse CSR matrix has to be sorted. This can be achieved by calling
        hipsparseXcsrsort().

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``transA`` != ``HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE`` and
        ``transB`` != ``HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE`` is supported.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // A = ( 1.0  0.0  0.0  0.0 )
       //     ( 2.0  3.0  0.0  0.0 )
       //     ( 4.0  5.0  6.0  0.0 )
       //     ( 7.0  0.0  8.0  9.0 )

       // Number of rows and columns
       int m = 4;
       int n = 4;

       // Number of right-hand-sides
       int nrhs = 4;

       // Number of non-zeros
       int nnz = 9;

       // CSR row pointers
       int hcsrRowPtr[5] = {0, 1, 3, 6, 9};

       // CSR column indices
       int hcsrColInd[9] = {0, 0, 1, 0, 1, 2, 0, 2, 3};

       // CSR values
       double hcsrVal[9] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};

       // Transposition of the matrix and rhs matrix
       hipsparseOperation_t transA = HIPSPARSE_OPERATION_NON_TRANSPOSE;
       hipsparseOperation_t transB = HIPSPARSE_OPERATION_NON_TRANSPOSE;

       // Solve policy
       hipsparseSolvePolicy_t solve_policy = HIPSPARSE_SOLVE_POLICY_NO_LEVEL;

       // Scalar alpha and beta
       double alpha = 1.0;

       // rhs and solution matrix
       int ldb = n;

       double hB[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};

       // Offload data to device
       int* dcsrRowPtr;
       int* dcsrColInd;
       double*        dcsrVal;
       double*        dB;

       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(double) * nnz);
       hipMalloc((void**)&dB, sizeof(double) * n * nrhs);

       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(double) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dB, hB, sizeof(double) * n * nrhs, hipMemcpyHostToDevice);

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Matrix fill mode
       hipsparseSetMatFillMode(descr, HIPSPARSE_FILL_MODE_LOWER);

       // Matrix diagonal type
       hipsparseSetMatDiagType(descr, HIPSPARSE_DIAG_TYPE_NON_UNIT);

       // Matrix info structure
       csrsm2Info_t info;
       hipsparseCreateCsrsm2Info(&info);

       // Obtain required buffer size
       size_t buffer_size;
       hipsparseDcsrsm2_bufferSizeExt(handle,
                                      0,
                                      transA,
                                      transB,
                                      m,
                                      nrhs,
                                      nnz,
                                      &alpha,
                                      descr,
                                      dcsrVal,
                                      dcsrRowPtr,
                                      dcsrColInd,
                                      dB,
                                      ldb,
                                      info,
                                      solve_policy,
                                      &buffer_size);

       // Allocate temporary buffer
       void* dbuffer;
       hipMalloc(&dbuffer, buffer_size);

       // Perform analysis step
       hipsparseDcsrsm2_analysis(handle,
                                 0,
                                 transA,
                                 transB,
                                 m,
                                 nrhs,
                                 nnz,
                                 &alpha,
                                 descr,
                                 dcsrVal,
                                 dcsrRowPtr,
                                 dcsrColInd,
                                 dB,
                                 ldb,
                                 info,
                                 solve_policy,
                                 dbuffer);

       // Call dcsrsm to perform lower triangular solve LB = B
       hipsparseDcsrsm2_solve(handle,
                              0,
                              transA,
                              transB,
                              m,
                              nrhs,
                              nnz,
                              &alpha,
                              descr,
                              dcsrVal,
                              dcsrRowPtr,
                              dcsrColInd,
                              dB,
                              ldb,
                              info,
                              solve_policy,
                              dbuffer);

       // Check for zero pivots
       int    pivot;
       hipsparseStatus_t status = hipsparseXcsrsm2_zeroPivot(handle, info, &pivot);

       if(status == HIPSPARSE_STATUS_ZERO_PIVOT)
       {
           std::cout << "Found zero pivot in matrix row " << pivot << std::endl;
       }

       // Copy result back to host
       hipMemcpy(hB, dB, sizeof(double) * m * nrhs, hipMemcpyDeviceToHost);

       // Clear hipSPARSE
       hipsparseDestroyCsrsm2Info(info);
       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

       // Clear device memory
       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);
       hipFree(dB);
       hipFree(dbuffer);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseScsrsm2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseScsrsm2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsrsm2_solve__retval,)


@cython.embedsignature(True)
def hipsparseDcsrsm2_solve(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDcsrsm2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrsm2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsrsm2_solve__retval,)


@cython.embedsignature(True)
def hipsparseCcsrsm2_solve(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCcsrsm2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrsm2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        float2.fromPyobj(B).getElementPtr(),ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsrsm2_solve__retval,)


@cython.embedsignature(True)
def hipsparseZcsrsm2_solve(object handle, int algo, object transA, object transB, int m, int nrhs, int nnz, object alpha, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object B, int ldb, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nrhs (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        info (`~.csrsm2Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZcsrsm2_solve__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrsm2_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,transA.value,transB.value,m,nrhs,nnz,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        double2.fromPyobj(B).getElementPtr(),ldb,
        csrsm2Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsrsm2_solve__retval,)


@cython.embedsignature(True)
def hipsparseSgemmi(object handle, int m, int n, int k, int nnz, object alpha, object A, int lda, object cscValB, object cscColPtrB, object cscRowIndB, object beta, object C, int ldc):
    r"""Dense matrix sparse matrix multiplication using CSC storage format

    ``hipsparseXgemmi`` multiplies the scalar :math:`\alpha` with a dense :math:`m \times k`
    matrix :math:`A` and the sparse :math:`k \times n` matrix :math:`B`, defined in CSC
    storage format and adds the result to the dense :math:`m \times n` matrix :math:`C` that
    is multiplied by the scalar :math:`\beta`, such that

    .. math::

       C := \alpha \cdot A \cdot B + \beta \cdot C

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // A, B, and C are mk, kn, and mn
       int m = 3, n = 5, k = 4;
       int lda = m, ldc = m;
       int nnz_A = m * k, nnz_B = 10, nnz_C = m * n;

       // alpha and beta
       float alpha = 0.5f;
       float beta  = 0.25f;

       std::vector<int> hcscColPtr = {0, 2, 5, 7, 8, 10};
       std::vector<int> hcscRowInd = {0, 2, 0, 1, 3, 1, 3, 2, 0, 2};
       std::vector<float> hcsc_val     = {1, 6, 2, 4, 9, 5, 2, 7, 3, 8};

       std::vector<float> hA(nnz_A, 1.0f);
       std::vector<float> hC(nnz_C, 1.0f);

       int *dcscColPtr;
       int *dcscRowInd;
       float *dcsc_val;
       hipMalloc((void**)&dcscColPtr, sizeof(int) * (n + 1));
       hipMalloc((void**)&dcscRowInd, sizeof(int) * nnz_B);
       hipMalloc((void**)&dcsc_val, sizeof(float) * nnz_B);

       hipMemcpy(dcscColPtr, hcscColPtr.data(), sizeof(int) * (n + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcscRowInd, hcscRowInd.data(), sizeof(int) * nnz_B, hipMemcpyHostToDevice);
       hipMemcpy(dcsc_val, hcsc_val.data(), sizeof(float) * nnz_B, hipMemcpyHostToDevice);

       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Allocate memory for the matrix A
       float* dA;
       hipMalloc((void**)&dA, sizeof(float) * nnz_A);
       hipMemcpy(dA, hA.data(), sizeof(float) * nnz_A, hipMemcpyHostToDevice);

       // Allocate memory for the resulting matrix C
       float* dC;
       hipMalloc((void**)&dC, sizeof(float) * nnz_C);
       hipMemcpy(dC, hC.data(), sizeof(float) * nnz_C, hipMemcpyHostToDevice);

       // Perform operation
       hipsparseSgemmi(handle,
                       m,
                       n,
                       k,
                       nnz_B,
                       &alpha,
                       dA,
                       lda,
                       dcsc_val,
                       dcscColPtr,
                       dcscRowInd,
                       &beta,
                       dC,
                       ldc);

       // Copy device to host
       hipMemcpy(hC.data(), dC, sizeof(float) * nnz_C, hipMemcpyDeviceToHost);

       // Destroy matrix descriptors and handles
       hipsparseDestroy(handle);

       hipFree(dcscColPtr);
       hipFree(dcscRowInd);
       hipFree(dcsc_val);
       hipFree(dA);
       hipFree(dC);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        cscValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    _hipsparseSgemmi__retval = hipsparseStatus_t(chipsparse.hipsparseSgemmi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(cscValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscColPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscRowIndB)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc))
    return (_hipsparseSgemmi__retval,)


@cython.embedsignature(True)
def hipsparseDgemmi(object handle, int m, int n, int k, int nnz, object alpha, object A, int lda, object cscValB, object cscColPtrB, object cscRowIndB, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        cscValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    _hipsparseDgemmi__retval = hipsparseStatus_t(chipsparse.hipsparseDgemmi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(cscValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscColPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscRowIndB)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(C)._ptr,ldc))
    return (_hipsparseDgemmi__retval,)


@cython.embedsignature(True)
def hipsparseCgemmi(object handle, int m, int n, int k, int nnz, object alpha, object A, int lda, object cscValB, object cscColPtrB, object cscRowIndB, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        cscValB (`~.float2`/`~.object`):
            (undocumented)

        cscColPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        C (`~.float2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    _hipsparseCgemmi__retval = hipsparseStatus_t(chipsparse.hipsparseCgemmi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,nnz,
        float2.fromPyobj(alpha).getElementPtr(),
        float2.fromPyobj(A).getElementPtr(),lda,
        float2.fromPyobj(cscValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(cscColPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscRowIndB)._ptr,
        float2.fromPyobj(beta).getElementPtr(),
        float2.fromPyobj(C).getElementPtr(),ldc))
    return (_hipsparseCgemmi__retval,)


@cython.embedsignature(True)
def hipsparseZgemmi(object handle, int m, int n, int k, int nnz, object alpha, object A, int lda, object cscValB, object cscColPtrB, object cscRowIndB, object beta, object C, int ldc):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        cscValB (`~.double2`/`~.object`):
            (undocumented)

        cscColPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        C (`~.double2`/`~.object`):
            (undocumented)

        ldc (`~.int`):
            (undocumented)
    """
    _hipsparseZgemmi__retval = hipsparseStatus_t(chipsparse.hipsparseZgemmi(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,nnz,
        double2.fromPyobj(alpha).getElementPtr(),
        double2.fromPyobj(A).getElementPtr(),lda,
        double2.fromPyobj(cscValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(cscColPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscRowIndB)._ptr,
        double2.fromPyobj(beta).getElementPtr(),
        double2.fromPyobj(C).getElementPtr(),ldc))
    return (_hipsparseZgemmi__retval,)


@cython.embedsignature(True)
def hipsparseXcsrgeamNnz(object handle, int m, int n, object descrA, int nnzA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrRowPtrB, object csrColIndB, object descrC, object csrRowPtrC, object nnzTotalDevHostPtr):
    r"""Sparse matrix sparse matrix addition using CSR storage format

    ``hipsparseXcsrgeamNnz`` computes the total CSR non-zero elements and the CSR row
    offsets, that point to the start of every row of the sparse CSR matrix, of the
    resulting matrix C. It is assumed that ``csrRowPtrC`` has been allocated with
    size ``m+1.`` The desired index base in the output CSR matrix is set in the
    hipsparseMatDescr_t. See hipsparseSetMatIndexBase().

    For full code example, see hipsparseScsrgeam().

    Note:
        As indicated, nnzTotalDevHostPtr can point either to host or device memory. This is controlled
        by setting the pointer mode. See hipsparseSetPointerMode().

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``HIPSPARSE_MATRIX_TYPE_GENERAL`` is supported.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcsrgeamNnz__retval = hipsparseStatus_t(chipsparse.hipsparseXcsrgeamNnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr))
    return (_hipsparseXcsrgeamNnz__retval,)


@cython.embedsignature(True)
def hipsparseScsrgeam(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object beta, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""Sparse matrix sparse matrix addition using CSR storage format

    ``hipsparseXcsrgeam`` multiplies the scalar :math:`\alpha` with the sparse
    :math:`m \times n` matrix :math:`A`, defined in CSR storage format, multiplies the
    scalar :math:`\beta` with the sparse :math:`m \times n` matrix :math:`B`, defined in CSR
    storage format, and adds both resulting matrices to obtain the sparse
    :math:`m \times n` matrix :math:`C`, defined in CSR storage format, such that

    .. math::

       C := \alpha \cdot A + \beta \cdot B.

    Note:
        Both scalars :math:`\alpha` and :math:`beta` have to be valid.

    Note:
        Currently, only ``HIPSPARSE_MATRIX_TYPE_GENERAL`` is supported.

    Note:
        This function is non blocking and executed asynchronously with respect to the
        host. It may return before the actual computation has finished.

    Par:

    .. code-block::

       int m = 4;
       int n = 4;
       int nnzA = 9;
       int nnzB = 6;

       float alpha{1.0f};
       float beta{1.0f};

       // A, B, and C are mn

       // A
       // 1 0 0 2
       // 3 4 0 0
       // 5 6 7 8
       // 0 0 9 0
       std::vector<int> hcsrRowPtrA = {0, 2, 4, 8, 9};
       std::vector<int> hcsrColIndA = {0, 3, 0, 1, 0, 1, 2, 3, 2};
       std::vector<float> hcsrValA = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f};

       // B
       // 0 1 0 0
       // 1 0 1 0
       // 0 1 0 1
       // 0 0 1 0
       std::vector<int> hcsrRowPtrB = {0, 1, 3, 5, 6};
       std::vector<int> hcsrColIndB = {1, 0, 2, 1, 3, 2};
       std::vector<float> hcsrValB = {1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f};

       // Device memory management: Allocate and copy A, B
       int* dcsrRowPtrA;
       int* dcsrColIndA;
       float* dcsrValA;
       int* dcsrRowPtrB;
       int* dcsrColIndB;
       float* dcsrValB;
       int* dcsrRowPtrC;
       hipMalloc((void**)&dcsrRowPtrA, (m + 1) * sizeof(int));
       hipMalloc((void**)&dcsrColIndA, nnzA * sizeof(int));
       hipMalloc((void**)&dcsrValA, nnzA * sizeof(float));
       hipMalloc((void**)&dcsrRowPtrB, (m + 1) * sizeof(int));
       hipMalloc((void**)&dcsrColIndB, nnzB * sizeof(int));
       hipMalloc((void**)&dcsrValB, nnzB * sizeof(float));
       hipMalloc((void**)&dcsrRowPtrC, (m + 1) * sizeof(int));

       hipMemcpy(dcsrRowPtrA, hcsrRowPtrA.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColIndA, hcsrColIndA.data(), nnzA * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrValA, hcsrValA.data(), nnzA * sizeof(float), hipMemcpyHostToDevice);
       hipMemcpy(dcsrRowPtrB, hcsrRowPtrB.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColIndB, hcsrColIndB.data(), nnzB * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrValB, hcsrValB.data(), nnzB * sizeof(float), hipMemcpyHostToDevice);

       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t descrA;
       hipsparseCreateMatDescr(&descrA);

       hipsparseMatDescr_t descrB;
       hipsparseCreateMatDescr(&descrB);

       hipsparseMatDescr_t descrC;
       hipsparseCreateMatDescr(&descrC);

       int nnzC;
       hipsparseXcsrgeamNnz(handle,
                           m,
                           n,
                           descrA,
                           nnzA,
                           dcsrRowPtrA,
                           dcsrColIndA,
                           descrB,
                           nnzB,
                           dcsrRowPtrB,
                           dcsrColIndB,
                           descrC,
                           dcsrRowPtrC,
                           &nnzC);

       int* dcsrColIndC = nullptr;
       float* dcsrValC = nullptr;
       hipMalloc((void**)&dcsrColIndC, sizeof(int) * nnzC);
       hipMalloc((void**)&dcsrValC, sizeof(float) * nnzC);

       hipsparseScsrgeam(handle,
                         m,
                         n,
                         &alpha,
                         descrA,
                         nnzA,
                         dcsrValA,
                         dcsrRowPtrA,
                         dcsrColIndA,
                         &beta,
                         descrB,
                         nnzB,
                         dcsrValB,
                         dcsrRowPtrB,
                         dcsrColIndB,
                         descrC,
                         dcsrValC,
                         dcsrRowPtrC,
                         dcsrColIndC);

       hipFree(dcsrRowPtrA);
       hipFree(dcsrColIndA);
       hipFree(dcsrValA);
       hipFree(dcsrRowPtrB);
       hipFree(dcsrColIndB);
       hipFree(dcsrValB);
       hipFree(dcsrRowPtrC);
       hipFree(dcsrColIndC);
       hipFree(dcsrValC);

       hipsparseDestroyMatDescr(descrA);
       hipsparseDestroyMatDescr(descrB);
       hipsparseDestroyMatDescr(descrC);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsrgeam__retval = hipsparseStatus_t(chipsparse.hipsparseScsrgeam(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseScsrgeam__retval,)


@cython.embedsignature(True)
def hipsparseDcsrgeam(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object beta, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsrgeam__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrgeam(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseDcsrgeam__retval,)


@cython.embedsignature(True)
def hipsparseCcsrgeam(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object beta, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsrgeam__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrgeam(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        float2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        float2.fromPyobj(beta).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        float2.fromPyobj(csrValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        float2.fromPyobj(csrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseCcsrgeam__retval,)


@cython.embedsignature(True)
def hipsparseZcsrgeam(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object beta, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsrgeam__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrgeam(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        double2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        double2.fromPyobj(beta).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        double2.fromPyobj(csrValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        double2.fromPyobj(csrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseZcsrgeam__retval,)


@cython.embedsignature(True)
def hipsparseScsrgeam2_bufferSizeExt(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object beta, object descrB, int nnzB, object csrSortedValB, object csrSortedRowPtrB, object csrSortedColIndB, object descrC, object csrSortedValC, object csrSortedRowPtrC, object csrSortedColIndC, object pBufferSizeInBytes):
    r"""Sparse matrix sparse matrix multiplication using CSR storage format

    ``hipsparseXcsrgeam2_bufferSizeExt`` returns the size of the temporary storage buffer
    in bytes that is required by hipsparseXcsrgeam2Nnz() and hipsparseXcsrgeam2(). The
    temporary storage buffer must be allocated by the user.

    Note:
        Currently, only ``HIPSPARSE_MATRIX_TYPE_GENERAL`` is supported.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrSortedValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsrgeam2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseScsrgeam2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndC)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsrgeam2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDcsrgeam2_bufferSizeExt(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object beta, object descrB, int nnzB, object csrSortedValB, object csrSortedRowPtrB, object csrSortedColIndB, object descrC, object csrSortedValC, object csrSortedRowPtrC, object csrSortedColIndC, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrSortedValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsrgeam2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrgeam2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndC)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsrgeam2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCcsrgeam2_bufferSizeExt(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object beta, object descrB, int nnzB, object csrSortedValB, object csrSortedRowPtrB, object csrSortedColIndB, object descrC, object csrSortedValC, object csrSortedRowPtrC, object csrSortedColIndC, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrSortedValB (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValC (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsrgeam2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrgeam2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        float2.fromPyobj(beta).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        float2.fromPyobj(csrSortedValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        float2.fromPyobj(csrSortedValC).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndC)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsrgeam2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZcsrgeam2_bufferSizeExt(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object beta, object descrB, int nnzB, object csrSortedValB, object csrSortedRowPtrB, object csrSortedColIndB, object descrC, object csrSortedValC, object csrSortedRowPtrC, object csrSortedColIndC, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrSortedValB (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValC (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsrgeam2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrgeam2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        double2.fromPyobj(beta).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        double2.fromPyobj(csrSortedValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        double2.fromPyobj(csrSortedValC).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndC)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsrgeam2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseXcsrgeam2Nnz(object handle, int m, int n, object descrA, int nnzA, object csrSortedRowPtrA, object csrSortedColIndA, object descrB, int nnzB, object csrSortedRowPtrB, object csrSortedColIndB, object descrC, object csrSortedRowPtrC, object nnzTotalDevHostPtr, object workspace):
    r"""Sparse matrix sparse matrix addition using CSR storage format

    ``hipsparseXcsrgeam2Nnz`` computes the total CSR non-zero elements and the CSR row
    offsets, that point to the start of every row of the sparse CSR matrix, of the
    resulting matrix C. It is assumed that ``csrRowPtrC`` has been allocated with
    size ``m+1.`` The required buffer size can be obtained by hipsparseXcsrgeam2_bufferSizeExt().
    The desired index base in the output CSR matrix C is set in the hipsparseMatDescr_t
    ``descrC.`` See hipsparseSetMatIndexBase().

    Note:
        As indicated, nnzTotalDevHostPtr can point either to host or device memory. This is controlled
        by setting the pointer mode. See hipsparseSetPointerMode().

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Currently, only ``HIPSPARSE_MATRIX_TYPE_GENERAL`` is supported.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrSortedRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        workspace (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcsrgeam2Nnz__retval = hipsparseStatus_t(chipsparse.hipsparseXcsrgeam2Nnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(workspace)._ptr))
    return (_hipsparseXcsrgeam2Nnz__retval,)


@cython.embedsignature(True)
def hipsparseScsrgeam2(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object beta, object descrB, int nnzB, object csrSortedValB, object csrSortedRowPtrB, object csrSortedColIndB, object descrC, object csrSortedValC, object csrSortedRowPtrC, object csrSortedColIndC, object pBuffer):
    r"""Sparse matrix sparse matrix addition using CSR storage format

    ``hipsparseXcsrgeam2`` multiplies the scalar :math:`\alpha` with the sparse
    :math:`m \times n` matrix :math:`A`, defined in CSR storage format, multiplies the
    scalar :math:`\beta` with the sparse :math:`m \times n` matrix :math:`B`, defined in CSR
    storage format, and adds both resulting matrices to obtain the sparse
    :math:`m \times n` matrix :math:`C`, defined in CSR storage format, such that

    .. math::

       C := \alpha \cdot A + \beta \cdot B.

    Note:
        Both scalars :math:`\alpha` and :math:`beta` have to be valid.

    Note:
        Currently, only ``HIPSPARSE_MATRIX_TYPE_GENERAL`` is supported.

    Note:
        This function is non blocking and executed asynchronously with respect to the
        host. It may return before the actual computation has finished.

    Par:

    .. code-block::

       int m = 4;
       int n = 4;
       int nnzA = 9;
       int nnzB = 6;

       float alpha{1.0f};
       float beta{1.0f};

       // A, B, and C are mn

       // A
       // 1 0 0 2
       // 3 4 0 0
       // 5 6 7 8
       // 0 0 9 0
       std::vector<int> hcsrRowPtrA = {0, 2, 4, 8, 9};
       std::vector<int> hcsrColIndA = {0, 3, 0, 1, 0, 1, 2, 3, 2};
       std::vector<float> hcsrValA = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f};

       // B
       // 0 1 0 0
       // 1 0 1 0
       // 0 1 0 1
       // 0 0 1 0
       std::vector<int> hcsrRowPtrB = {0, 1, 3, 5, 6};
       std::vector<int> hcsrColIndB = {1, 0, 2, 1, 3, 2};
       std::vector<float> hcsrValB = {1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f};

       // Device memory management: Allocate and copy A, B
       int* dcsrRowPtrA;
       int* dcsrColIndA;
       float* dcsrValA;
       int* dcsrRowPtrB;
       int* dcsrColIndB;
       float* dcsrValB;
       int* dcsrRowPtrC;
       hipMalloc((void**)&dcsrRowPtrA, (m + 1) * sizeof(int));
       hipMalloc((void**)&dcsrColIndA, nnzA * sizeof(int));
       hipMalloc((void**)&dcsrValA, nnzA * sizeof(float));
       hipMalloc((void**)&dcsrRowPtrB, (m + 1) * sizeof(int));
       hipMalloc((void**)&dcsrColIndB, nnzB * sizeof(int));
       hipMalloc((void**)&dcsrValB, nnzB * sizeof(float));
       hipMalloc((void**)&dcsrRowPtrC, (m + 1) * sizeof(int));

       hipMemcpy(dcsrRowPtrA, hcsrRowPtrA.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColIndA, hcsrColIndA.data(), nnzA * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrValA, hcsrValA.data(), nnzA * sizeof(float), hipMemcpyHostToDevice);
       hipMemcpy(dcsrRowPtrB, hcsrRowPtrB.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColIndB, hcsrColIndB.data(), nnzB * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrValB, hcsrValB.data(), nnzB * sizeof(float), hipMemcpyHostToDevice);

       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t descrA;
       hipsparseCreateMatDescr(&descrA);

       hipsparseMatDescr_t descrB;
       hipsparseCreateMatDescr(&descrB);

       hipsparseMatDescr_t descrC;
       hipsparseCreateMatDescr(&descrC);

       size_t bufferSize;
       hipsparseScsrgeam2_bufferSizeExt(handle,
                                        m,
                                        n,
                                        &alpha,
                                        descrA,
                                        nnzA,
                                        dcsrValA,
                                        dcsrRowPtrA,
                                        dcsrColIndA,
                                        &beta,
                                        descrB,
                                        nnzB,
                                        dcsrValB,
                                        dcsrRowPtrB,
                                        dcsrColIndB,
                                        descrC,
                                        nullptr,
                                        dcsrRowPtrC,
                                        nullptr,
                                        &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       int nnzC;
       hipsparseXcsrgeam2Nnz(handle,
                           m,
                           n,
                           descrA,
                           nnzA,
                           dcsrRowPtrA,
                           dcsrColIndA,
                           descrB,
                           nnzB,
                           dcsrRowPtrB,
                           dcsrColIndB,
                           descrC,
                           dcsrRowPtrC,
                           &nnzC,
                           dbuffer);

       int* dcsrColIndC = nullptr;
       float* dcsrValC = nullptr;
       hipMalloc((void**)&dcsrColIndC, sizeof(int) * nnzC);
       hipMalloc((void**)&dcsrValC, sizeof(float) * nnzC);

       hipsparseScsrgeam2(handle,
                         m,
                         n,
                         &alpha,
                         descrA,
                         nnzA,
                         dcsrValA,
                         dcsrRowPtrA,
                         dcsrColIndA,
                         &beta,
                         descrB,
                         nnzB,
                         dcsrValB,
                         dcsrRowPtrB,
                         dcsrColIndB,
                         descrC,
                         dcsrValC,
                         dcsrRowPtrC,
                         dcsrColIndC,
                         dbuffer);

       hipFree(dcsrRowPtrA);
       hipFree(dcsrColIndA);
       hipFree(dcsrValA);
       hipFree(dcsrRowPtrB);
       hipFree(dcsrColIndB);
       hipFree(dcsrValB);
       hipFree(dcsrRowPtrC);
       hipFree(dcsrColIndC);
       hipFree(dcsrValC);

       hipFree(dbuffer);

       hipsparseDestroyMatDescr(descrA);
       hipsparseDestroyMatDescr(descrB);
       hipsparseDestroyMatDescr(descrC);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrSortedValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsrgeam2__retval = hipsparseStatus_t(chipsparse.hipsparseScsrgeam2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrSortedValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndC)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsrgeam2__retval,)


@cython.embedsignature(True)
def hipsparseDcsrgeam2(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object beta, object descrB, int nnzB, object csrSortedValB, object csrSortedRowPtrB, object csrSortedColIndB, object descrC, object csrSortedValC, object csrSortedRowPtrC, object csrSortedColIndC, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrSortedValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsrgeam2__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrgeam2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrSortedValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndC)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsrgeam2__retval,)


@cython.embedsignature(True)
def hipsparseCcsrgeam2(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object beta, object descrB, int nnzB, object csrSortedValB, object csrSortedRowPtrB, object csrSortedColIndB, object descrC, object csrSortedValC, object csrSortedRowPtrC, object csrSortedColIndC, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrSortedValB (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValC (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsrgeam2__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrgeam2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        float2.fromPyobj(beta).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        float2.fromPyobj(csrSortedValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        float2.fromPyobj(csrSortedValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndC)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsrgeam2__retval,)


@cython.embedsignature(True)
def hipsparseZcsrgeam2(object handle, int m, int n, object alpha, object descrA, int nnzA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object beta, object descrB, int nnzB, object csrSortedValB, object csrSortedRowPtrB, object csrSortedColIndB, object descrC, object csrSortedValC, object csrSortedRowPtrC, object csrSortedColIndC, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrSortedValB (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValC (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsrgeam2__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrgeam2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        double2.fromPyobj(beta).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        double2.fromPyobj(csrSortedValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        double2.fromPyobj(csrSortedValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndC)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsrgeam2__retval,)


@cython.embedsignature(True)
def hipsparseXcsrgemmNnz(object handle, object transA, object transB, int m, int n, int k, object descrA, int nnzA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrRowPtrB, object csrColIndB, object descrC, object csrRowPtrC, object nnzTotalDevHostPtr):
    r"""Sparse matrix sparse matrix multiplication using CSR storage format

    ``hipsparseXcsrgemmNnz`` computes the total CSR non-zero elements and the CSR row
    offsets, that point to the start of every row of the sparse CSR matrix, of the
    resulting multiplied matrix C. It is assumed that ``csrRowPtrC`` has been allocated
    with size ``m+1.`` The desired index base in the output CSR matrix C is set in the
    hipsparseMatDescr_t ``descrC.`` See hipsparseSetMatIndexBase().

    Note:
        As indicated, nnzTotalDevHostPtr can point either to host or device memory. This is controlled
        by setting the pointer mode. See hipsparseSetPointerMode().

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Please note, that for matrix products with more than 8192 intermediate products per
        row, additional temporary storage buffer is allocated by the algorithm.

    Note:
        Currently, only ``transA`` == ``transB`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` is
        supported.

    Note:
        Currently, only ``HIPSPARSE_MATRIX_TYPE_GENERAL`` is supported.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseXcsrgemmNnz__retval = hipsparseStatus_t(chipsparse.hipsparseXcsrgemmNnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr))
    return (_hipsparseXcsrgemmNnz__retval,)


@cython.embedsignature(True)
def hipsparseScsrgemm(object handle, object transA, object transB, int m, int n, int k, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""Sparse matrix sparse matrix multiplication using CSR storage format

    ``hipsparseXcsrgemm`` multiplies the sparse :math:`m \times k` matrix :math:`op(A)`, defined in
    CSR storage format with the sparse :math:`k \times n` matrix :math:`op(B)`, defined in CSR
    storage format, and stores the result in the sparse :math:`m \times n` matrix :math:`C`,
    defined in CSR storage format, such that

    .. math::

       C := op(A) \cdot op(B),

    with

    .. math::

       op(A) = \left\{
       \begin{array}{ll}
           A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           A^T, & \text{if transA == HIPSPARSE_OPERATION_TRANSPOSE} \\
           A^H, & \text{if transA == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    and

    .. math::

       op(B) = \left\{
       \begin{array}{ll}
           B,   & \text{if transB == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
           B^T, & \text{if transB == HIPSPARSE_OPERATION_TRANSPOSE} \\
           B^H, & \text{if transB == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
       \end{array}
       \right.

    Note:
        Currently, only ``transA`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` is supported.

    Note:
        Currently, only ``transB`` == ``HIPSPARSE_OPERATION_NON_TRANSPOSE`` is supported.

    Note:
        Currently, only ``HIPSPARSE_MATRIX_TYPE_GENERAL`` is supported.

    Note:
        This function is non blocking and executed asynchronously with respect to the
        host. It may return before the actual computation has finished.

    Note:
        Please note, that for matrix products with more than 4096 non-zero entries per
        row, additional temporary storage buffer is allocated by the algorithm.

    Par:

    .. code-block::

       int m = 4;
       int k = 3;
       int n = 2;
       int nnzA = 7;
       int nnzB = 3;

       hipsparseOperation_t transA = HIPSPARSE_OPERATION_NON_TRANSPOSE;
       hipsparseOperation_t transB = HIPSPARSE_OPERATION_NON_TRANSPOSE;

       // A, B, and C are mxk, kxn, and mn

       // A
       // 1 0 0
       // 3 4 0
       // 5 6 7
       // 0 0 9
       std::vector<int> hcsrRowPtrA = {0, 1, 3, 6, 7};
       std::vector<int> hcsrColIndA = {0, 0, 1, 0, 1, 2, 2};
       std::vector<float> hcsrValA = {1.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 9.0f};

       // B
       // 0 1
       // 1 0
       // 0 1
       std::vector<int> hcsrRowPtrB = {0, 1, 2, 3};
       std::vector<int> hcsrColIndB = {1, 0, 1};
       std::vector<float> hcsrValB = {1.0f, 1.0f, 1.0f};

       // Device memory management: Allocate and copy A, B
       int* dcsrRowPtrA;
       int* dcsrColIndA;
       float* dcsrValA;
       int* dcsrRowPtrB;
       int* dcsrColIndB;
       float* dcsrValB;
       int* dcsrRowPtrC;
       hipMalloc((void**)&dcsrRowPtrA, (m + 1) * sizeof(int));
       hipMalloc((void**)&dcsrColIndA, nnzA * sizeof(int));
       hipMalloc((void**)&dcsrValA, nnzA * sizeof(float));
       hipMalloc((void**)&dcsrRowPtrB, (m + 1) * sizeof(int));
       hipMalloc((void**)&dcsrColIndB, nnzB * sizeof(int));
       hipMalloc((void**)&dcsrValB, nnzB * sizeof(float));
       hipMalloc((void**)&dcsrRowPtrC, (m + 1) * sizeof(int));

       hipMemcpy(dcsrRowPtrA, hcsrRowPtrA.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColIndA, hcsrColIndA.data(), nnzA * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrValA, hcsrValA.data(), nnzA * sizeof(float), hipMemcpyHostToDevice);
       hipMemcpy(dcsrRowPtrB, hcsrRowPtrB.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColIndB, hcsrColIndB.data(), nnzB * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrValB, hcsrValB.data(), nnzB * sizeof(float), hipMemcpyHostToDevice);

       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t descrA;
       hipsparseCreateMatDescr(&descrA);

       hipsparseMatDescr_t descrB;
       hipsparseCreateMatDescr(&descrB);

       hipsparseMatDescr_t descrC;
       hipsparseCreateMatDescr(&descrC);

       int nnzC;
       hipsparseXcsrgemmNnz(handle,
                       transA,
                       transB,
                       m,
                       n,
                       k,
                       descrA,
                       nnzA,
                       dcsrRowPtrA,
                       dcsrColIndA,
                       descrB,
                       nnzB,
                       dcsrRowPtrB,
                       dcsrColIndB,
                       descrC,
                       dcsrRowPtrC,
                       &nnzC);

       int* dcsrColIndC = nullptr;
       float* dcsrValC = nullptr;
       hipMalloc((void**)&dcsrColIndC, sizeof(int) * nnzC);
       hipMalloc((void**)&dcsrValC, sizeof(float) * nnzC);

       hipsparseScsrgemm(handle,
                         transA,
                         transB,
                         m,
                         n,
                         k,
                         descrA,
                         nnzA,
                         dcsrValA,
                         dcsrRowPtrA,
                         dcsrColIndA,
                         descrB,
                         nnzB,
                         dcsrValB,
                         dcsrRowPtrB,
                         dcsrColIndB,
                         descrC,
                         dcsrValC,
                         dcsrRowPtrC,
                         dcsrColIndC);

       hipFree(dcsrRowPtrA);
       hipFree(dcsrColIndA);
       hipFree(dcsrValA);
       hipFree(dcsrRowPtrB);
       hipFree(dcsrColIndB);
       hipFree(dcsrValB);
       hipFree(dcsrRowPtrC);
       hipFree(dcsrColIndC);
       hipFree(dcsrValC);

       hipsparseDestroyMatDescr(descrA);
       hipsparseDestroyMatDescr(descrB);
       hipsparseDestroyMatDescr(descrC);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseScsrgemm__retval = hipsparseStatus_t(chipsparse.hipsparseScsrgemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseScsrgemm__retval,)


@cython.embedsignature(True)
def hipsparseDcsrgemm(object handle, object transA, object transB, int m, int n, int k, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseDcsrgemm__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrgemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseDcsrgemm__retval,)


@cython.embedsignature(True)
def hipsparseCcsrgemm(object handle, object transA, object transB, int m, int n, int k, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseCcsrgemm__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrgemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        float2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        float2.fromPyobj(csrValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        float2.fromPyobj(csrValC).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseCcsrgemm__retval,)


@cython.embedsignature(True)
def hipsparseZcsrgemm(object handle, object transA, object transB, int m, int n, int k, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        transA (`~.hipsparseOperation_t`):
            (undocumented)

        transB (`~.hipsparseOperation_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(transA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(transB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'transB' must be of type '_hipsparseOperation_t__Base'")
    _hipsparseZcsrgemm__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrgemm(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,transA.value,transB.value,m,n,k,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        double2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        double2.fromPyobj(csrValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        double2.fromPyobj(csrValC).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseZcsrgemm__retval,)


@cython.embedsignature(True)
def hipsparseScsrgemm2_bufferSizeExt(object handle, int m, int n, int k, object alpha, object descrA, int nnzA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrRowPtrB, object csrColIndB, object beta, object descrD, int nnzD, object csrRowPtrD, object csrColIndD, object info, object pBufferSizeInBytes):
    r"""Sparse matrix sparse matrix multiplication using CSR storage format

    ``hipsparseXcsrgemm2_bufferSizeExt`` returns the size of the temporary storage buffer
    in bytes that is required by hipsparseXcsrgemm2Nnz() and hipsparseXcsrgemm2(). The
    temporary storage buffer must be allocated by the user.

    Note:
        Please note, that for matrix products with more than 4096 non-zero entries per row,
        additional temporary storage buffer is allocated by the algorithm.

    Note:
        Please note, that for matrix products with more than 8192 intermediate products per
        row, additional temporary storage buffer is allocated by the algorithm.

    Note:
        Currently, only ``HIPSPARSE_MATRIX_TYPE_GENERAL`` is supported.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzD (`~.int`):
            (undocumented)

        csrRowPtrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrgemm2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsrgemm2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseScsrgemm2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrD)._ptr,nnzD,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndD)._ptr,
        csrgemm2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsrgemm2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDcsrgemm2_bufferSizeExt(object handle, int m, int n, int k, object alpha, object descrA, int nnzA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrRowPtrB, object csrColIndB, object beta, object descrD, int nnzD, object csrRowPtrD, object csrColIndD, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzD (`~.int`):
            (undocumented)

        csrRowPtrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrgemm2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsrgemm2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrgemm2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrD)._ptr,nnzD,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndD)._ptr,
        csrgemm2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsrgemm2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCcsrgemm2_bufferSizeExt(object handle, int m, int n, int k, object alpha, object descrA, int nnzA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrRowPtrB, object csrColIndB, object beta, object descrD, int nnzD, object csrRowPtrD, object csrColIndD, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        descrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzD (`~.int`):
            (undocumented)

        csrRowPtrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrgemm2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsrgemm2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrgemm2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        float2.fromPyobj(beta).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrD)._ptr,nnzD,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndD)._ptr,
        csrgemm2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsrgemm2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZcsrgemm2_bufferSizeExt(object handle, int m, int n, int k, object alpha, object descrA, int nnzA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrRowPtrB, object csrColIndB, object beta, object descrD, int nnzD, object csrRowPtrD, object csrColIndD, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        descrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzD (`~.int`):
            (undocumented)

        csrRowPtrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrgemm2Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsrgemm2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrgemm2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        double2.fromPyobj(beta).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrD)._ptr,nnzD,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndD)._ptr,
        csrgemm2Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsrgemm2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseXcsrgemm2Nnz(object handle, int m, int n, int k, object descrA, int nnzA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrRowPtrB, object csrColIndB, object descrD, int nnzD, object csrRowPtrD, object csrColIndD, object descrC, object csrRowPtrC, object nnzTotalDevHostPtr, object info, object pBuffer):
    r"""Sparse matrix sparse matrix multiplication using CSR storage format

    ``hipsparseXcsrgemm2Nnz`` computes the total CSR non-zero elements and the CSR row
    offsets, that point to the start of every row of the sparse CSR matrix, of the
    resulting multiplied matrix C. It is assumed that ``csrRowPtrC`` has been allocated
    with size ``m+1.`` The required buffer size can be obtained by hipsparseXcsrgemm2_bufferSizeExt().
    The desired index base in the output CSR matrix C is set in the hipsparseMatDescr_t
    ``descrC.`` See hipsparseSetMatIndexBase().

    Note:
        As indicated, nnzTotalDevHostPtr can point either to host or device memory. This is controlled
        by setting the pointer mode. See hipsparseSetPointerMode().

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Note:
        Please note, that for matrix products with more than 8192 intermediate products per
        row, additional temporary storage buffer is allocated by the algorithm.

    Note:
        Currently, only ``HIPSPARSE_MATRIX_TYPE_GENERAL`` is supported.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzD (`~.int`):
            (undocumented)

        csrRowPtrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrgemm2Info`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcsrgemm2Nnz__retval = hipsparseStatus_t(chipsparse.hipsparseXcsrgemm2Nnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrD)._ptr,nnzD,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndD)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        csrgemm2Info.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseXcsrgemm2Nnz__retval,)


@cython.embedsignature(True)
def hipsparseScsrgemm2(object handle, int m, int n, int k, object alpha, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object beta, object descrD, int nnzD, object csrValD, object csrRowPtrD, object csrColIndD, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object info, object pBuffer):
    r"""Sparse matrix sparse matrix multiplication using CSR storage format

    ``hipsparseXcsrgemm2`` multiplies the scalar :math:`\alpha` with the sparse
    :math:`m \times k` matrix :math:`A`, defined in CSR storage format, and the sparse
    :math:`k \times n` matrix :math:`B`, defined in CSR storage format, and adds the result
    to the sparse :math:`m \times n` matrix :math:`D` that is multiplied by :math:`\beta`. The
    final result is stored in the sparse :math:`m \times n` matrix :math:`C`, defined in CSR
    storage format, such
    that

    .. math::

       C := \alpha \cdot A \cdot B + \beta \cdot D

    Note:
        If :math:`\alpha == 0`, then :math:`C = \beta \cdot D` will be computed.

    Note:
        If :math:`\beta == 0`, then :math:`C = \alpha \cdot A \cdot B` will be computed.

    Note:
        math:`\alpha == beta == 0` is invalid.

    Note:
        Currently, only ``HIPSPARSE_MATRIX_TYPE_GENERAL`` is supported.

    Note:
        This function is non blocking and executed asynchronously with respect to the
        host. It may return before the actual computation has finished.

    Note:
        Please note, that for matrix products with more than 4096 non-zero entries per
        row, additional temporary storage buffer is allocated by the algorithm.

    Par:

    .. code-block::

       int m = 4;
       int k = 3;
       int n = 2;
       int nnzA = 7;
       int nnzB = 3;
       int nnzD = 6;

       float alpha{1.0f};
       float beta{1.0f};

       // A, B, and C are mxk, kxn, and mn

       // A
       // 1 0 0
       // 3 4 0
       // 5 6 7
       // 0 0 9
       std::vector<int> hcsrRowPtrA = {0, 1, 3, 6, 7};
       std::vector<int> hcsrColIndA = {0, 0, 1, 0, 1, 2, 2};
       std::vector<float> hcsrValA = {1.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 9.0f};

       // B
       // 0 1
       // 1 0
       // 0 1
       std::vector<int> hcsrRowPtrB = {0, 1, 2, 3};
       std::vector<int> hcsrColIndB = {1, 0, 1};
       std::vector<float> hcsrValB = {1.0f, 1.0f, 1.0f};

       // D
       // 0 1
       // 2 3
       // 4 5
       // 0 6
       std::vector<int> hcsrRowPtrD = {0, 1, 3, 5, 6};
       std::vector<int> hcsrColIndD = {1, 0, 1, 0, 1, 1};
       std::vector<float> hcsrValD = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};

       // Device memory management: Allocate and copy A, B
       int* dcsrRowPtrA;
       int* dcsrColIndA;
       float* dcsrValA;
       int* dcsrRowPtrB;
       int* dcsrColIndB;
       float* dcsrValB;
       int* dcsrRowPtrD;
       int* dcsrColIndD;
       float* dcsrValD;
       int* dcsrRowPtrC;
       hipMalloc((void**)&dcsrRowPtrA, (m + 1) * sizeof(int));
       hipMalloc((void**)&dcsrColIndA, nnzA * sizeof(int));
       hipMalloc((void**)&dcsrValA, nnzA * sizeof(float));
       hipMalloc((void**)&dcsrRowPtrB, (k + 1) * sizeof(int));
       hipMalloc((void**)&dcsrColIndB, nnzB * sizeof(int));
       hipMalloc((void**)&dcsrValB, nnzB * sizeof(float));
       hipMalloc((void**)&dcsrRowPtrD, (m + 1) * sizeof(int));
       hipMalloc((void**)&dcsrColIndD, nnzD * sizeof(int));
       hipMalloc((void**)&dcsrValD, nnzD * sizeof(float));
       hipMalloc((void**)&dcsrRowPtrC, (m + 1) * sizeof(int));

       hipMemcpy(dcsrRowPtrA, hcsrRowPtrA.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColIndA, hcsrColIndA.data(), nnzA * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrValA, hcsrValA.data(), nnzA * sizeof(float), hipMemcpyHostToDevice);
       hipMemcpy(dcsrRowPtrB, hcsrRowPtrB.data(), (k + 1) * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColIndB, hcsrColIndB.data(), nnzB * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrValB, hcsrValB.data(), nnzB * sizeof(float), hipMemcpyHostToDevice);
       hipMemcpy(dcsrRowPtrD, hcsrRowPtrD.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColIndD, hcsrColIndD.data(), nnzD * sizeof(int), hipMemcpyHostToDevice);
       hipMemcpy(dcsrValD, hcsrValD.data(), nnzD * sizeof(float), hipMemcpyHostToDevice);

       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t descrA;
       hipsparseCreateMatDescr(&descrA);

       hipsparseMatDescr_t descrB;
       hipsparseCreateMatDescr(&descrB);

       hipsparseMatDescr_t descrC;
       hipsparseCreateMatDescr(&descrC);

       hipsparseMatDescr_t descrD;
       hipsparseCreateMatDescr(&descrD);

       csrgemm2Info_t info;
       hipsparseCreateCsrgemm2Info(&info);

       size_t bufferSize;
       hipsparseScsrgemm2_bufferSizeExt(handle,
                                        m,
                                        n,
                                        k,
                                        &alpha,
                                        descrA,
                                        nnzA,
                                        dcsrRowPtrA,
                                        dcsrColIndA,
                                        descrB,
                                        nnzB,
                                        dcsrRowPtrB,
                                        dcsrColIndB,
                                        &beta,
                                        descrD,
                                        nnzD,
                                        dcsrRowPtrD,
                                        dcsrColIndD,
                                        info,
                                        &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       int nnzC;
       hipsparseXcsrgemm2Nnz(handle,
                       m,
                       n,
                       k,
                       descrA,
                       nnzA,
                       dcsrRowPtrA,
                       dcsrColIndA,
                       descrB,
                       nnzB,
                       dcsrRowPtrB,
                       dcsrColIndB,
                       descrD,
                       nnzD,
                       dcsrRowPtrD,
                       dcsrColIndD,
                       descrC,
                       dcsrRowPtrC,
                       &nnzC,
                       info,
                       dbuffer);

       int* dcsrColIndC = nullptr;
       float* dcsrValC = nullptr;
       hipMalloc((void**)&dcsrColIndC, sizeof(int) * nnzC);
       hipMalloc((void**)&dcsrValC, sizeof(float) * nnzC);

       hipsparseScsrgemm2(handle,
                         m,
                         n,
                         k,
                         &alpha,
                         descrA,
                         nnzA,
                         dcsrValA,
                         dcsrRowPtrA,
                         dcsrColIndA,
                         descrB,
                         nnzB,
                         dcsrValB,
                         dcsrRowPtrB,
                         dcsrColIndB,
                         &beta,
                         descrD,
                         nnzD,
                         dcsrValD,
                         dcsrRowPtrD,
                         dcsrColIndD,
                         descrC,
                         dcsrValC,
                         dcsrRowPtrC,
                         dcsrColIndC,
                         info,
                         dbuffer);

       hipFree(dcsrRowPtrA);
       hipFree(dcsrColIndA);
       hipFree(dcsrValA);
       hipFree(dcsrRowPtrB);
       hipFree(dcsrColIndB);
       hipFree(dcsrValB);
       hipFree(dcsrRowPtrC);
       hipFree(dcsrColIndC);
       hipFree(dcsrValC);
       hipFree(dcsrRowPtrD);
       hipFree(dcsrColIndD);
       hipFree(dcsrValD);

       hipFree(dbuffer);

       hipsparseDestroyMatDescr(descrA);
       hipsparseDestroyMatDescr(descrB);
       hipsparseDestroyMatDescr(descrC);
       hipsparseDestroyMatDescr(descrD);
       hipsparseDestroyCsrgemm2Info(info);

       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzD (`~.int`):
            (undocumented)

        csrValD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrgemm2Info`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsrgemm2__retval = hipsparseStatus_t(chipsparse.hipsparseScsrgemm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,
        <const float *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrD)._ptr,nnzD,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndD)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        csrgemm2Info.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsrgemm2__retval,)


@cython.embedsignature(True)
def hipsparseDcsrgemm2(object handle, int m, int n, int k, object alpha, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object beta, object descrD, int nnzD, object csrValD, object csrRowPtrD, object csrColIndD, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object info, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzD (`~.int`):
            (undocumented)

        csrValD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrgemm2Info`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsrgemm2__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrgemm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,
        <const double *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrD)._ptr,nnzD,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndD)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        csrgemm2Info.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsrgemm2__retval,)


@cython.embedsignature(True)
def hipsparseCcsrgemm2(object handle, int m, int n, int k, object alpha, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object beta, object descrD, int nnzD, object csrValD, object csrRowPtrD, object csrColIndD, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object info, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.float2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.float2`/`~.object`):
            (undocumented)

        descrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzD (`~.int`):
            (undocumented)

        csrValD (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrgemm2Info`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsrgemm2__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrgemm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,
        float2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        float2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        float2.fromPyobj(csrValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        float2.fromPyobj(beta).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrD)._ptr,nnzD,
        float2.fromPyobj(csrValD).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndD)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        float2.fromPyobj(csrValC).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        csrgemm2Info.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsrgemm2__retval,)


@cython.embedsignature(True)
def hipsparseZcsrgemm2(object handle, int m, int n, int k, object alpha, object descrA, int nnzA, object csrValA, object csrRowPtrA, object csrColIndA, object descrB, int nnzB, object csrValB, object csrRowPtrB, object csrColIndB, object beta, object descrD, int nnzD, object csrValD, object csrRowPtrD, object csrColIndD, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object info, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        k (`~.int`):
            (undocumented)

        alpha (`~.double2`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        csrValA (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzB (`~.int`):
            (undocumented)

        csrValB (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.double2`/`~.object`):
            (undocumented)

        descrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzD (`~.int`):
            (undocumented)

        csrValD (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndD (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrgemm2Info`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsrgemm2__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrgemm2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,k,
        double2.fromPyobj(alpha).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,nnzA,
        double2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrB)._ptr,nnzB,
        double2.fromPyobj(csrValB).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrB)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndB)._ptr,
        double2.fromPyobj(beta).getElementPtr(),
        <void *const>hip._util.types.Pointer.fromPyobj(descrD)._ptr,nnzD,
        double2.fromPyobj(csrValD).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrD)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndD)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        double2.fromPyobj(csrValC).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        csrgemm2Info.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsrgemm2__retval,)


@cython.embedsignature(True)
def hipsparseXbsrilu02_zeroPivot(object handle, object info, object position):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage
    format

    ``hipsparseXbsrilu02_zeroPivot`` returns ``HIPSPARSE_STATUS_ZERO_PIVOT`` , if either a
    structural or numerical zero has been found during hipsparseXbsrilu02_analysis() or
    hipsparseXbsrilu02() computation. The first zero pivot :math:`j` at :math:`A_{j,j}` is
    stored in ``position,`` using same index base as the BSR matrix.

    ``position`` can be in host or device memory. If no zero pivot has been found,
    ``position`` is set to -1 and ``HIPSPARSE_STATUS_SUCCESS`` is returned instead.

    Note:
        If a zero pivot is found, ``position`` :math:`=j` means that either the diagonal block
        :math:`A_{j,j}` is missing (structural zero) or the diagonal block :math:`A_{j,j}` is not
        invertible (numerical zero).

    Note:
        ``hipsparseXbsrilu02_zeroPivot`` is a blocking function. It might influence
        performance negatively.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        position (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXbsrilu02_zeroPivot__retval = hipsparseStatus_t(chipsparse.hipsparseXbsrilu02_zeroPivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        bsrilu02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(position)._ptr))
    return (_hipsparseXbsrilu02_zeroPivot__retval,)


@cython.embedsignature(True)
def hipsparseSbsrilu02_numericBoost(object handle, object info, int enable_boost, object tol, object boost_val):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage
    format

    ``hipsparseXbsrilu02_numericBoost`` enables the user to replace a numerical value in
    an incomplete LU factorization. ``tol`` is used to determine whether a numerical value
    is replaced by ``boost_val,`` such that :math:`A_{j,j} = \text{boost_val}` if
    :math:`\text{tol} \ge \left|A_{j,j}\right|`.

    Note:
        The boost value is enabled by setting ``enable_boost`` to 1 or disabled by
        setting ``enable_boost`` to 0.

    Note:
        ``tol`` and ``boost_val`` can be in host or device memory.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        enable_boost (`~.int`):
            (undocumented)

        tol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        boost_val (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSbsrilu02_numericBoost__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrilu02_numericBoost(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        bsrilu02Info.fromPyobj(info).getElementPtr(),enable_boost,
        <double *>hip._util.types.Pointer.fromPyobj(tol)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(boost_val)._ptr))
    return (_hipsparseSbsrilu02_numericBoost__retval,)


@cython.embedsignature(True)
def hipsparseDbsrilu02_numericBoost(object handle, object info, int enable_boost, object tol, object boost_val):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        enable_boost (`~.int`):
            (undocumented)

        tol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        boost_val (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDbsrilu02_numericBoost__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrilu02_numericBoost(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        bsrilu02Info.fromPyobj(info).getElementPtr(),enable_boost,
        <double *>hip._util.types.Pointer.fromPyobj(tol)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(boost_val)._ptr))
    return (_hipsparseDbsrilu02_numericBoost__retval,)


@cython.embedsignature(True)
def hipsparseCbsrilu02_numericBoost(object handle, object info, int enable_boost, object tol, object boost_val):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        enable_boost (`~.int`):
            (undocumented)

        tol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        boost_val (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipsparseCbsrilu02_numericBoost__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrilu02_numericBoost(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        bsrilu02Info.fromPyobj(info).getElementPtr(),enable_boost,
        <double *>hip._util.types.Pointer.fromPyobj(tol)._ptr,
        float2.fromPyobj(boost_val).getElementPtr()))
    return (_hipsparseCbsrilu02_numericBoost__retval,)


@cython.embedsignature(True)
def hipsparseZbsrilu02_numericBoost(object handle, object info, int enable_boost, object tol, object boost_val):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        enable_boost (`~.int`):
            (undocumented)

        tol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        boost_val (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipsparseZbsrilu02_numericBoost__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrilu02_numericBoost(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        bsrilu02Info.fromPyobj(info).getElementPtr(),enable_boost,
        <double *>hip._util.types.Pointer.fromPyobj(tol)._ptr,
        double2.fromPyobj(boost_val).getElementPtr()))
    return (_hipsparseZbsrilu02_numericBoost__retval,)


@cython.embedsignature(True)
def hipsparseSbsrilu02_bufferSize(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage
    format

    ``hipsparseXbsrilu02_bufferSize`` returns the size of the temporary storage buffer
    in bytes that is required by hipsparseXbsrilu02_analysis() and hipsparseXbsrilu02().
    The temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseSbsrilu02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrilu02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSbsrilu02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDbsrilu02_bufferSize(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseDbsrilu02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrilu02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDbsrilu02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCbsrilu02_bufferSize(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseCbsrilu02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrilu02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCbsrilu02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZbsrilu02_bufferSize(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseZbsrilu02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrilu02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZbsrilu02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSbsrilu02_analysis(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage
    format

    ``hipsparseXbsrilu02_analysis`` performs the analysis step for hipsparseXbsrilu02().

    Note:
        If the matrix sparsity pattern changes, the gathered information will become invalid.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseSbsrilu02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrilu02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSbsrilu02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseDbsrilu02_analysis(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDbsrilu02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrilu02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDbsrilu02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseCbsrilu02_analysis(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCbsrilu02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrilu02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCbsrilu02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseZbsrilu02_analysis(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZbsrilu02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrilu02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZbsrilu02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseSbsrilu02(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA_valM, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage
    format

    ``hipsparseXbsrilu02`` computes the incomplete LU factorization with 0 fill-ins and no
    pivoting of a sparse :math:`mb \times mb` BSR matrix :math:`A`, such that

    .. math::

       A \approx LU

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA_valM (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseSbsrilu02__retval = hipsparseStatus_t(chipsparse.hipsparseSbsrilu02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrSortedValA_valM)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSbsrilu02__retval,)


@cython.embedsignature(True)
def hipsparseDbsrilu02(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA_valM, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA_valM (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDbsrilu02__retval = hipsparseStatus_t(chipsparse.hipsparseDbsrilu02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrSortedValA_valM)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDbsrilu02__retval,)


@cython.embedsignature(True)
def hipsparseCbsrilu02(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA_valM, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA_valM (`~.float2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCbsrilu02__retval = hipsparseStatus_t(chipsparse.hipsparseCbsrilu02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrSortedValA_valM).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCbsrilu02__retval,)


@cython.embedsignature(True)
def hipsparseZbsrilu02(object handle, object dirA, int mb, int nnzb, object descrA, object bsrSortedValA_valM, object bsrSortedRowPtrA, object bsrSortedColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedValA_valM (`~.double2`/`~.object`):
            (undocumented)

        bsrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZbsrilu02__retval = hipsparseStatus_t(chipsparse.hipsparseZbsrilu02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrSortedValA_valM).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrSortedColIndA)._ptr,blockDim,
        bsrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZbsrilu02__retval,)


@cython.embedsignature(True)
def hipsparseXcsrilu02_zeroPivot(object handle, object info, object position):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using CSR
    storage format

    ``hipsparseXcsrilu02_zeroPivot`` returns ``HIPSPARSE_STATUS_ZERO_PIVOT`` , if either a
    structural or numerical zero has been found during hipsparseXcsrilu02() computation.
    The first zero pivot :math:`j` at :math:`A_{j,j}` is stored in ``position,`` using same
    index base as the CSR matrix.

    ``position`` can be in host or device memory. If no zero pivot has been found,
    ``position`` is set to -1 and ``HIPSPARSE_STATUS_SUCCESS`` is returned instead.

    Note:
        ``hipsparseXcsrilu02_zeroPivot`` is a blocking function. It might influence
        performance negatively.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        position (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcsrilu02_zeroPivot__retval = hipsparseStatus_t(chipsparse.hipsparseXcsrilu02_zeroPivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(position)._ptr))
    return (_hipsparseXcsrilu02_zeroPivot__retval,)


@cython.embedsignature(True)
def hipsparseScsrilu02_numericBoost(object handle, object info, int enable_boost, object tol, object boost_val):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using CSR storage
    format

    ``hipsparseXcsrilu02_numericBoost`` enables the user to replace a numerical value in
    an incomplete LU factorization. ``tol`` is used to determine whether a numerical value
    is replaced by ``boost_val,`` such that :math:`A_{j,j} = \text{boost_val}` if
    :math:`\text{tol} \ge \left|A_{j,j}\right|`.

    Note:
        The boost value is enabled by setting ``enable_boost`` to 1 or disabled by
        setting ``enable_boost`` to 0.

    Note:
        ``tol`` and ``boost_val`` can be in host or device memory.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        enable_boost (`~.int`):
            (undocumented)

        tol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        boost_val (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsrilu02_numericBoost__retval = hipsparseStatus_t(chipsparse.hipsparseScsrilu02_numericBoost(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),enable_boost,
        <double *>hip._util.types.Pointer.fromPyobj(tol)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(boost_val)._ptr))
    return (_hipsparseScsrilu02_numericBoost__retval,)


@cython.embedsignature(True)
def hipsparseDcsrilu02_numericBoost(object handle, object info, int enable_boost, object tol, object boost_val):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        enable_boost (`~.int`):
            (undocumented)

        tol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        boost_val (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsrilu02_numericBoost__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrilu02_numericBoost(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),enable_boost,
        <double *>hip._util.types.Pointer.fromPyobj(tol)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(boost_val)._ptr))
    return (_hipsparseDcsrilu02_numericBoost__retval,)


@cython.embedsignature(True)
def hipsparseCcsrilu02_numericBoost(object handle, object info, int enable_boost, object tol, object boost_val):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        enable_boost (`~.int`):
            (undocumented)

        tol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        boost_val (`~.float2`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsrilu02_numericBoost__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrilu02_numericBoost(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),enable_boost,
        <double *>hip._util.types.Pointer.fromPyobj(tol)._ptr,
        float2.fromPyobj(boost_val).getElementPtr()))
    return (_hipsparseCcsrilu02_numericBoost__retval,)


@cython.embedsignature(True)
def hipsparseZcsrilu02_numericBoost(object handle, object info, int enable_boost, object tol, object boost_val):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        enable_boost (`~.int`):
            (undocumented)

        tol (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        boost_val (`~.double2`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsrilu02_numericBoost__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrilu02_numericBoost(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),enable_boost,
        <double *>hip._util.types.Pointer.fromPyobj(tol)._ptr,
        double2.fromPyobj(boost_val).getElementPtr()))
    return (_hipsparseZcsrilu02_numericBoost__retval,)


@cython.embedsignature(True)
def hipsparseScsrilu02_bufferSize(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using CSR
    storage format

    ``hipsparseXcsrilu02_bufferSize`` returns the size of the temporary storage buffer
    in bytes that is required by hipsparseXcsrilu02_analysis() and hipsparseXcsrilu02_solve().
    The temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsrilu02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseScsrilu02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsrilu02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDcsrilu02_bufferSize(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsrilu02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrilu02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsrilu02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCcsrilu02_bufferSize(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsrilu02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrilu02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsrilu02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZcsrilu02_bufferSize(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsrilu02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrilu02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsrilu02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseScsrilu02_bufferSizeExt(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using CSR
    storage format

    ``hipsparseXcsrilu02_bufferSizeExt`` returns the size of the temporary storage buffer
    in bytes that is required by hipsparseXcsrilu02_analysis() and hipsparseXcsrilu02_solve().
    The temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsrilu02_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseScsrilu02_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsrilu02_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDcsrilu02_bufferSizeExt(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsrilu02_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrilu02_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsrilu02_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCcsrilu02_bufferSizeExt(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsrilu02_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrilu02_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsrilu02_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZcsrilu02_bufferSizeExt(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsrilu02_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrilu02_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsrilu02_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseScsrilu02_analysis(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using CSR
    storage format

    ``hipsparseXcsrilu02_analysis`` performs the analysis step for hipsparseXcsrilu02().

    Note:
        If the matrix sparsity pattern changes, the gathered information will become invalid.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseScsrilu02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseScsrilu02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsrilu02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseDcsrilu02_analysis(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDcsrilu02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrilu02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsrilu02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseCcsrilu02_analysis(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCcsrilu02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrilu02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsrilu02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseZcsrilu02_analysis(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZcsrilu02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrilu02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsrilu02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseScsrilu02(object handle, int m, int nnz, object descrA, object csrSortedValA_valM, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""Incomplete LU factorization with 0 fill-ins and no pivoting using CSR
    storage format

    ``hipsparseXcsrilu02`` computes the incomplete LU factorization with 0 fill-ins and no
    pivoting of a sparse :math:`m \times m` CSR matrix :math:`A`, such that

    .. math::

       A \approx LU

    Note:
        The sparse CSR matrix has to be sorted. This can be achieved by calling
        hipsparseXcsrsort().

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA_valM (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseScsrilu02__retval = hipsparseStatus_t(chipsparse.hipsparseScsrilu02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrSortedValA_valM)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsrilu02__retval,)


@cython.embedsignature(True)
def hipsparseDcsrilu02(object handle, int m, int nnz, object descrA, object csrSortedValA_valM, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA_valM (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDcsrilu02__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrilu02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrSortedValA_valM)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsrilu02__retval,)


@cython.embedsignature(True)
def hipsparseCcsrilu02(object handle, int m, int nnz, object descrA, object csrSortedValA_valM, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA_valM (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCcsrilu02__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrilu02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA_valM).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsrilu02__retval,)


@cython.embedsignature(True)
def hipsparseZcsrilu02(object handle, int m, int nnz, object descrA, object csrSortedValA_valM, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA_valM (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csrilu02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZcsrilu02__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrilu02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA_valM).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csrilu02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsrilu02__retval,)


@cython.embedsignature(True)
def hipsparseXbsric02_zeroPivot(object handle, object info, object position):
    r"""Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR
    storage format

    ``hipsparseXbsric02_zeroPivot`` returns ``HIPSPARSE_STATUS_ZERO_PIVOT`` , if either a
    structural or numerical zero has been found during hipsparseXbsric02_analysis() or
    hipsparseXbsric02() computation. The first zero pivot :math:`j` at :math:`A_{j,j}` is
    stored in ``position,`` using same index base as the BSR matrix.

    ``position`` can be in host or device memory. If no zero pivot has been found,
    ``position`` is set to -1 and ``HIPSPARSE_STATUS_SUCCESS`` is returned instead.

    Note:
        If a zero pivot is found, ``position=j`` means that either the diagonal block ``A(j,j)``
        is missing (structural zero) or the diagonal block ``A(j,j)`` is not positive definite
        (numerical zero).

    Note:
        ``hipsparseXbsric02_zeroPivot`` is a blocking function. It might influence
        performance negatively.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        position (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXbsric02_zeroPivot__retval = hipsparseStatus_t(chipsparse.hipsparseXbsric02_zeroPivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        bsric02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(position)._ptr))
    return (_hipsparseXbsric02_zeroPivot__retval,)


@cython.embedsignature(True)
def hipsparseSbsric02_bufferSize(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR
    storage format

    ``hipsparseXbsric02_bufferSize`` returns the size of the temporary storage buffer
    in bytes that is required by hipsparseXbsric02_analysis() and hipsparseXbsric02().
    The temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseSbsric02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSbsric02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSbsric02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDbsric02_bufferSize(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseDbsric02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDbsric02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDbsric02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCbsric02_bufferSize(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseCbsric02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCbsric02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCbsric02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZbsric02_bufferSize(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseZbsric02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZbsric02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZbsric02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSbsric02_analysis(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR
    storage format

    ``hipsparseXbsric02_analysis`` performs the analysis step for hipsparseXbsric02().

    Note:
        If the matrix sparsity pattern changes, the gathered information will become invalid.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseSbsric02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseSbsric02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSbsric02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseDbsric02_analysis(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDbsric02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseDbsric02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDbsric02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseCbsric02_analysis(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCbsric02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseCbsric02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCbsric02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseZbsric02_analysis(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZbsric02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseZbsric02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZbsric02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseSbsric02(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR
    storage format

    ``hipsparseXbsric02`` computes the incomplete Cholesky factorization with 0 fill-ins
    and no pivoting of a sparse :math:`mb \times mb` BSR matrix :math:`A`, such that

    .. math::

       A \approx LL^T

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseSbsric02__retval = hipsparseStatus_t(chipsparse.hipsparseSbsric02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSbsric02__retval,)


@cython.embedsignature(True)
def hipsparseDbsric02(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDbsric02__retval = hipsparseStatus_t(chipsparse.hipsparseDbsric02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDbsric02__retval,)


@cython.embedsignature(True)
def hipsparseCbsric02(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCbsric02__retval = hipsparseStatus_t(chipsparse.hipsparseCbsric02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCbsric02__retval,)


@cython.embedsignature(True)
def hipsparseZbsric02(object handle, object dirA, int mb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        info (`~.bsric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")                    
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZbsric02__retval = hipsparseStatus_t(chipsparse.hipsparseZbsric02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        bsric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZbsric02__retval,)


@cython.embedsignature(True)
def hipsparseXcsric02_zeroPivot(object handle, object info, object position):
    r"""Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR
    storage format

    ``hipsparseXcsric02_zeroPivot`` returns ``HIPSPARSE_STATUS_ZERO_PIVOT`` , if either a
    structural or numerical zero has been found during hipsparseXcsric02_analysis() or
    hipsparseXcsric02() computation. The first zero pivot :math:`j` at :math:`A_{j,j}`
    is stored in ``position,`` using same index base as the CSR matrix.

    ``position`` can be in host or device memory. If no zero pivot has been found,
    ``position`` is set to -1 and ``HIPSPARSE_STATUS_SUCCESS`` is returned instead.

    Note:
        ``hipsparseXcsric02_zeroPivot`` is a blocking function. It might influence
        performance negatively.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        position (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcsric02_zeroPivot__retval = hipsparseStatus_t(chipsparse.hipsparseXcsric02_zeroPivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(position)._ptr))
    return (_hipsparseXcsric02_zeroPivot__retval,)


@cython.embedsignature(True)
def hipsparseScsric02_bufferSize(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR
    storage format

    ``hipsparseXcsric02_bufferSize`` returns the size of the temporary storage buffer in bytes
    that is required by hipsparseXcsric02_analysis() and hipsparseXcsric02().

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsric02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseScsric02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsric02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDcsric02_bufferSize(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsric02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDcsric02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsric02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCcsric02_bufferSize(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsric02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCcsric02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsric02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZcsric02_bufferSize(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsric02_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZcsric02_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsric02_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseScsric02_bufferSizeExt(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR
    storage format

    ``hipsparseXcsric02_bufferSizeExt`` returns the size of the temporary storage buffer
    in bytes that is required by hipsparseXcsric02_analysis() and hipsparseXcsric02().

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsric02_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseScsric02_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsric02_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDcsric02_bufferSizeExt(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsric02_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDcsric02_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsric02_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCcsric02_bufferSizeExt(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsric02_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCcsric02_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsric02_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZcsric02_bufferSizeExt(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsric02_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZcsric02_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsric02_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseScsric02_analysis(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR
    storage format

    ``hipsparseXcsric02_analysis`` performs the analysis step for hipsparseXcsric02().

    Note:
        If the matrix sparsity pattern changes, the gathered information will become invalid.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseScsric02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseScsric02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsric02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseDcsric02_analysis(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDcsric02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseDcsric02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsric02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseCcsric02_analysis(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCcsric02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseCcsric02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsric02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseZcsric02_analysis(object handle, int m, int nnz, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZcsric02_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseZcsric02_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsric02_analysis__retval,)


@cython.embedsignature(True)
def hipsparseScsric02(object handle, int m, int nnz, object descrA, object csrSortedValA_valM, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR
    storage format

    ``hipsparseXcsric02`` computes the incomplete Cholesky factorization with 0 fill-ins
    and no pivoting of a sparse :math:`m \times m` CSR matrix :math:`A`, such that

    .. math::

       A \approx LL^T

    Note:
        The sparse CSR matrix has to be sorted. This can be achieved by calling
        hipsparseXcsrsort().

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA_valM (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseScsric02__retval = hipsparseStatus_t(chipsparse.hipsparseScsric02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrSortedValA_valM)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsric02__retval,)


@cython.embedsignature(True)
def hipsparseDcsric02(object handle, int m, int nnz, object descrA, object csrSortedValA_valM, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA_valM (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseDcsric02__retval = hipsparseStatus_t(chipsparse.hipsparseDcsric02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrSortedValA_valM)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsric02__retval,)


@cython.embedsignature(True)
def hipsparseCcsric02(object handle, int m, int nnz, object descrA, object csrSortedValA_valM, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA_valM (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseCcsric02__retval = hipsparseStatus_t(chipsparse.hipsparseCcsric02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA_valM).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsric02__retval,)


@cython.embedsignature(True)
def hipsparseZcsric02(object handle, int m, int nnz, object descrA, object csrSortedValA_valM, object csrSortedRowPtrA, object csrSortedColIndA, object info, object policy, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA_valM (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csric02Info`/`~.object`):
            (undocumented)

        policy (`~.hipsparseSolvePolicy_t`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(policy,_hipsparseSolvePolicy_t__Base):
        raise TypeError("argument 'policy' must be of type '_hipsparseSolvePolicy_t__Base'")
    _hipsparseZcsric02__retval = hipsparseStatus_t(chipsparse.hipsparseZcsric02(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA_valM).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        csric02Info.fromPyobj(info).getElementPtr(),policy.value,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsric02__retval,)


@cython.embedsignature(True)
def hipsparseSgtsv2_bufferSizeExt(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBufferSizeInBytes):
    r"""Tridiagonal solver with pivoting

    ``hipsparseXgtsv2_bufferSize`` returns the size of the temporary storage buffer
    in bytes that is required by hipsparseXgtsv2(). The temporary storage buffer must
    be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgtsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseSgtsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSgtsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDgtsv2_bufferSizeExt(object handle, int m, int n, object dl, object d, object du, object B, int db, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        db (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgtsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDgtsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(B)._ptr,db,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDgtsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCgtsv2_bufferSizeExt(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.float2`/`~.object`):
            (undocumented)

        d (`~.float2`/`~.object`):
            (undocumented)

        du (`~.float2`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgtsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCgtsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(dl).getElementPtr(),
        float2.fromPyobj(d).getElementPtr(),
        float2.fromPyobj(du).getElementPtr(),
        float2.fromPyobj(B).getElementPtr(),ldb,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCgtsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZgtsv2_bufferSizeExt(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.double2`/`~.object`):
            (undocumented)

        d (`~.double2`/`~.object`):
            (undocumented)

        du (`~.double2`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgtsv2_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZgtsv2_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(dl).getElementPtr(),
        double2.fromPyobj(d).getElementPtr(),
        double2.fromPyobj(du).getElementPtr(),
        double2.fromPyobj(B).getElementPtr(),ldb,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZgtsv2_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseSgtsv2(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBuffer):
    r"""Tridiagonal solver with pivoting

    ``hipsparseXgtsv2`` solves a tridiagonal system for multiple right hand sides using pivoting.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgtsv2__retval = hipsparseStatus_t(chipsparse.hipsparseSgtsv2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSgtsv2__retval,)


@cython.embedsignature(True)
def hipsparseDgtsv2(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgtsv2__retval = hipsparseStatus_t(chipsparse.hipsparseDgtsv2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDgtsv2__retval,)


@cython.embedsignature(True)
def hipsparseCgtsv2(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.float2`/`~.object`):
            (undocumented)

        d (`~.float2`/`~.object`):
            (undocumented)

        du (`~.float2`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgtsv2__retval = hipsparseStatus_t(chipsparse.hipsparseCgtsv2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(dl).getElementPtr(),
        float2.fromPyobj(d).getElementPtr(),
        float2.fromPyobj(du).getElementPtr(),
        float2.fromPyobj(B).getElementPtr(),ldb,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCgtsv2__retval,)


@cython.embedsignature(True)
def hipsparseZgtsv2(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.double2`/`~.object`):
            (undocumented)

        d (`~.double2`/`~.object`):
            (undocumented)

        du (`~.double2`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgtsv2__retval = hipsparseStatus_t(chipsparse.hipsparseZgtsv2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(dl).getElementPtr(),
        double2.fromPyobj(d).getElementPtr(),
        double2.fromPyobj(du).getElementPtr(),
        double2.fromPyobj(B).getElementPtr(),ldb,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZgtsv2__retval,)


@cython.embedsignature(True)
def hipsparseSgtsv2_nopivot_bufferSizeExt(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBufferSizeInBytes):
    r"""Tridiagonal solver (no pivoting)

    ``hipsparseXgtsv2_nopivot_bufferSizeExt`` returns the size of the temporary storage
    buffer in bytes that is required by hipsparseXgtsv2_nopivot(). The temporary storage
    buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgtsv2_nopivot_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseSgtsv2_nopivot_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSgtsv2_nopivot_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDgtsv2_nopivot_bufferSizeExt(object handle, int m, int n, object dl, object d, object du, object B, int db, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        db (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgtsv2_nopivot_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDgtsv2_nopivot_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(B)._ptr,db,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDgtsv2_nopivot_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCgtsv2_nopivot_bufferSizeExt(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.float2`/`~.object`):
            (undocumented)

        d (`~.float2`/`~.object`):
            (undocumented)

        du (`~.float2`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgtsv2_nopivot_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCgtsv2_nopivot_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(dl).getElementPtr(),
        float2.fromPyobj(d).getElementPtr(),
        float2.fromPyobj(du).getElementPtr(),
        float2.fromPyobj(B).getElementPtr(),ldb,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCgtsv2_nopivot_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZgtsv2_nopivot_bufferSizeExt(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.double2`/`~.object`):
            (undocumented)

        d (`~.double2`/`~.object`):
            (undocumented)

        du (`~.double2`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgtsv2_nopivot_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZgtsv2_nopivot_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(dl).getElementPtr(),
        double2.fromPyobj(d).getElementPtr(),
        double2.fromPyobj(du).getElementPtr(),
        double2.fromPyobj(B).getElementPtr(),ldb,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZgtsv2_nopivot_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseSgtsv2_nopivot(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBuffer):
    r"""Tridiagonal solver (no pivoting)

    ``hipsparseXgtsv2_nopivot`` solves a tridiagonal linear system for multiple right-hand sides

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgtsv2_nopivot__retval = hipsparseStatus_t(chipsparse.hipsparseSgtsv2_nopivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSgtsv2_nopivot__retval,)


@cython.embedsignature(True)
def hipsparseDgtsv2_nopivot(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgtsv2_nopivot__retval = hipsparseStatus_t(chipsparse.hipsparseDgtsv2_nopivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(B)._ptr,ldb,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDgtsv2_nopivot__retval,)


@cython.embedsignature(True)
def hipsparseCgtsv2_nopivot(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.float2`/`~.object`):
            (undocumented)

        d (`~.float2`/`~.object`):
            (undocumented)

        du (`~.float2`/`~.object`):
            (undocumented)

        B (`~.float2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgtsv2_nopivot__retval = hipsparseStatus_t(chipsparse.hipsparseCgtsv2_nopivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        float2.fromPyobj(dl).getElementPtr(),
        float2.fromPyobj(d).getElementPtr(),
        float2.fromPyobj(du).getElementPtr(),
        float2.fromPyobj(B).getElementPtr(),ldb,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCgtsv2_nopivot__retval,)


@cython.embedsignature(True)
def hipsparseZgtsv2_nopivot(object handle, int m, int n, object dl, object d, object du, object B, int ldb, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        dl (`~.double2`/`~.object`):
            (undocumented)

        d (`~.double2`/`~.object`):
            (undocumented)

        du (`~.double2`/`~.object`):
            (undocumented)

        B (`~.double2`/`~.object`):
            (undocumented)

        ldb (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgtsv2_nopivot__retval = hipsparseStatus_t(chipsparse.hipsparseZgtsv2_nopivot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        double2.fromPyobj(dl).getElementPtr(),
        double2.fromPyobj(d).getElementPtr(),
        double2.fromPyobj(du).getElementPtr(),
        double2.fromPyobj(B).getElementPtr(),ldb,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZgtsv2_nopivot__retval,)


@cython.embedsignature(True)
def hipsparseSgtsv2StridedBatch_bufferSizeExt(object handle, int m, object dl, object d, object du, object x, int batchCount, int batchStride, object pBufferSizeInBytes):
    r"""Strided Batch tridiagonal solver (no pivoting)

    ``hipsparseXgtsv2StridedBatch_bufferSizeExt`` returns the size of the temporary storage
    buffer in bytes that is required by hipsparseXgtsv2StridedBatch(). The temporary
    storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        batchStride (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgtsv2StridedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseSgtsv2StridedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        <const float *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,batchStride,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSgtsv2StridedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDgtsv2StridedBatch_bufferSizeExt(object handle, int m, object dl, object d, object du, object x, int batchCount, int batchStride, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        batchStride (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgtsv2StridedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDgtsv2StridedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        <const double *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,batchStride,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDgtsv2StridedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCgtsv2StridedBatch_bufferSizeExt(object handle, int m, object dl, object d, object du, object x, int batchCount, int batchStride, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.float2`/`~.object`):
            (undocumented)

        d (`~.float2`/`~.object`):
            (undocumented)

        du (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        batchStride (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgtsv2StridedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCgtsv2StridedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        float2.fromPyobj(dl).getElementPtr(),
        float2.fromPyobj(d).getElementPtr(),
        float2.fromPyobj(du).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),batchCount,batchStride,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCgtsv2StridedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZgtsv2StridedBatch_bufferSizeExt(object handle, int m, object dl, object d, object du, object x, int batchCount, int batchStride, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.double2`/`~.object`):
            (undocumented)

        d (`~.double2`/`~.object`):
            (undocumented)

        du (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        batchStride (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgtsv2StridedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZgtsv2StridedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        double2.fromPyobj(dl).getElementPtr(),
        double2.fromPyobj(d).getElementPtr(),
        double2.fromPyobj(du).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),batchCount,batchStride,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZgtsv2StridedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseSgtsv2StridedBatch(object handle, int m, object dl, object d, object du, object x, int batchCount, int batchStride, object pBuffer):
    r"""Strided Batch tridiagonal solver (no pivoting)

    ``hipsparseXgtsv2StridedBatch`` solves a batched tridiagonal linear system

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        batchStride (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgtsv2StridedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseSgtsv2StridedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        <const float *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,batchStride,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSgtsv2StridedBatch__retval,)


@cython.embedsignature(True)
def hipsparseDgtsv2StridedBatch(object handle, int m, object dl, object d, object du, object x, int batchCount, int batchStride, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        batchStride (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgtsv2StridedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseDgtsv2StridedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        <const double *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,batchStride,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDgtsv2StridedBatch__retval,)


@cython.embedsignature(True)
def hipsparseCgtsv2StridedBatch(object handle, int m, object dl, object d, object du, object x, int batchCount, int batchStride, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.float2`/`~.object`):
            (undocumented)

        d (`~.float2`/`~.object`):
            (undocumented)

        du (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        batchStride (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgtsv2StridedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseCgtsv2StridedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        float2.fromPyobj(dl).getElementPtr(),
        float2.fromPyobj(d).getElementPtr(),
        float2.fromPyobj(du).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),batchCount,batchStride,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCgtsv2StridedBatch__retval,)


@cython.embedsignature(True)
def hipsparseZgtsv2StridedBatch(object handle, int m, object dl, object d, object du, object x, int batchCount, int batchStride, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.double2`/`~.object`):
            (undocumented)

        d (`~.double2`/`~.object`):
            (undocumented)

        du (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        batchStride (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgtsv2StridedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseZgtsv2StridedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        double2.fromPyobj(dl).getElementPtr(),
        double2.fromPyobj(d).getElementPtr(),
        double2.fromPyobj(du).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),batchCount,batchStride,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZgtsv2StridedBatch__retval,)


@cython.embedsignature(True)
def hipsparseSgtsvInterleavedBatch_bufferSizeExt(object handle, int algo, int m, object dl, object d, object du, object x, int batchCount, object pBufferSizeInBytes):
    r"""Interleaved Batch tridiagonal solver

    ``hipsparseXgtsvInterleavedBatch_bufferSizeExt`` returns the size of the temporary storage
    buffer in bytes that is required by hipsparseXgtsvInterleavedBatch(). The temporary storage
    buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgtsvInterleavedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseSgtsvInterleavedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        <const float *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSgtsvInterleavedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDgtsvInterleavedBatch_bufferSizeExt(object handle, int algo, int m, object dl, object d, object du, object x, int batchCount, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgtsvInterleavedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDgtsvInterleavedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        <const double *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDgtsvInterleavedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCgtsvInterleavedBatch_bufferSizeExt(object handle, int algo, int m, object dl, object d, object du, object x, int batchCount, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.float2`/`~.object`):
            (undocumented)

        d (`~.float2`/`~.object`):
            (undocumented)

        du (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgtsvInterleavedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCgtsvInterleavedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        float2.fromPyobj(dl).getElementPtr(),
        float2.fromPyobj(d).getElementPtr(),
        float2.fromPyobj(du).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),batchCount,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCgtsvInterleavedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZgtsvInterleavedBatch_bufferSizeExt(object handle, int algo, int m, object dl, object d, object du, object x, int batchCount, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.double2`/`~.object`):
            (undocumented)

        d (`~.double2`/`~.object`):
            (undocumented)

        du (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgtsvInterleavedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZgtsvInterleavedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        double2.fromPyobj(dl).getElementPtr(),
        double2.fromPyobj(d).getElementPtr(),
        double2.fromPyobj(du).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),batchCount,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZgtsvInterleavedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseSgtsvInterleavedBatch(object handle, int algo, int m, object dl, object d, object du, object x, int batchCount, object pBuffer):
    r"""Interleaved Batch tridiagonal solver

    ``hipsparseXgtsvInterleavedBatch`` solves a batched tridiagonal linear system

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgtsvInterleavedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseSgtsvInterleavedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        <float *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSgtsvInterleavedBatch__retval,)


@cython.embedsignature(True)
def hipsparseDgtsvInterleavedBatch(object handle, int algo, int m, object dl, object d, object du, object x, int batchCount, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgtsvInterleavedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseDgtsvInterleavedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        <double *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDgtsvInterleavedBatch__retval,)


@cython.embedsignature(True)
def hipsparseCgtsvInterleavedBatch(object handle, int algo, int m, object dl, object d, object du, object x, int batchCount, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.float2`/`~.object`):
            (undocumented)

        d (`~.float2`/`~.object`):
            (undocumented)

        du (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgtsvInterleavedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseCgtsvInterleavedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        float2.fromPyobj(dl).getElementPtr(),
        float2.fromPyobj(d).getElementPtr(),
        float2.fromPyobj(du).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCgtsvInterleavedBatch__retval,)


@cython.embedsignature(True)
def hipsparseZgtsvInterleavedBatch(object handle, int algo, int m, object dl, object d, object du, object x, int batchCount, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        dl (`~.double2`/`~.object`):
            (undocumented)

        d (`~.double2`/`~.object`):
            (undocumented)

        du (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgtsvInterleavedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseZgtsvInterleavedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        double2.fromPyobj(dl).getElementPtr(),
        double2.fromPyobj(d).getElementPtr(),
        double2.fromPyobj(du).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZgtsvInterleavedBatch__retval,)


@cython.embedsignature(True)
def hipsparseSgpsvInterleavedBatch_bufferSizeExt(object handle, int algo, int m, object ds, object dl, object d, object du, object dw, object x, int batchCount, object pBufferSizeInBytes):
    r"""Interleaved Batch pentadiagonal solver

    ``hipsparseXgpsvInterleavedBatch_bufferSizeExt`` returns the size of the temporary storage
    buffer in bytes that is required by hipsparseXgpsvInterleavedBatch(). The temporary
    storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        ds (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dw (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgpsvInterleavedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseSgpsvInterleavedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        <const float *>hip._util.types.Pointer.fromPyobj(ds)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(dw)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSgpsvInterleavedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDgpsvInterleavedBatch_bufferSizeExt(object handle, int algo, int m, object ds, object dl, object d, object du, object dw, object x, int batchCount, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        ds (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dw (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgpsvInterleavedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDgpsvInterleavedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        <const double *>hip._util.types.Pointer.fromPyobj(ds)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(dw)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDgpsvInterleavedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCgpsvInterleavedBatch_bufferSizeExt(object handle, int algo, int m, object ds, object dl, object d, object du, object dw, object x, int batchCount, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        ds (`~.float2`/`~.object`):
            (undocumented)

        dl (`~.float2`/`~.object`):
            (undocumented)

        d (`~.float2`/`~.object`):
            (undocumented)

        du (`~.float2`/`~.object`):
            (undocumented)

        dw (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgpsvInterleavedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCgpsvInterleavedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        float2.fromPyobj(ds).getElementPtr(),
        float2.fromPyobj(dl).getElementPtr(),
        float2.fromPyobj(d).getElementPtr(),
        float2.fromPyobj(du).getElementPtr(),
        float2.fromPyobj(dw).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),batchCount,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCgpsvInterleavedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZgpsvInterleavedBatch_bufferSizeExt(object handle, int algo, int m, object ds, object dl, object d, object du, object dw, object x, int batchCount, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        ds (`~.double2`/`~.object`):
            (undocumented)

        dl (`~.double2`/`~.object`):
            (undocumented)

        d (`~.double2`/`~.object`):
            (undocumented)

        du (`~.double2`/`~.object`):
            (undocumented)

        dw (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgpsvInterleavedBatch_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZgpsvInterleavedBatch_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        double2.fromPyobj(ds).getElementPtr(),
        double2.fromPyobj(dl).getElementPtr(),
        double2.fromPyobj(d).getElementPtr(),
        double2.fromPyobj(du).getElementPtr(),
        double2.fromPyobj(dw).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),batchCount,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZgpsvInterleavedBatch_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseSgpsvInterleavedBatch(object handle, int algo, int m, object ds, object dl, object d, object du, object dw, object x, int batchCount, object pBuffer):
    r"""Interleaved Batch pentadiagonal solver

    ``hipsparseXgpsvInterleavedBatch`` solves a batched pentadiagonal linear system

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        ds (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dw (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgpsvInterleavedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseSgpsvInterleavedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        <float *>hip._util.types.Pointer.fromPyobj(ds)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(dw)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseSgpsvInterleavedBatch__retval,)


@cython.embedsignature(True)
def hipsparseDgpsvInterleavedBatch(object handle, int algo, int m, object ds, object dl, object d, object du, object dw, object x, int batchCount, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        ds (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dl (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        d (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        du (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dw (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgpsvInterleavedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseDgpsvInterleavedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        <double *>hip._util.types.Pointer.fromPyobj(ds)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(dl)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(d)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(du)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(dw)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(x)._ptr,batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDgpsvInterleavedBatch__retval,)


@cython.embedsignature(True)
def hipsparseCgpsvInterleavedBatch(object handle, int algo, int m, object ds, object dl, object d, object du, object dw, object x, int batchCount, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        ds (`~.float2`/`~.object`):
            (undocumented)

        dl (`~.float2`/`~.object`):
            (undocumented)

        d (`~.float2`/`~.object`):
            (undocumented)

        du (`~.float2`/`~.object`):
            (undocumented)

        dw (`~.float2`/`~.object`):
            (undocumented)

        x (`~.float2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgpsvInterleavedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseCgpsvInterleavedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        float2.fromPyobj(ds).getElementPtr(),
        float2.fromPyobj(dl).getElementPtr(),
        float2.fromPyobj(d).getElementPtr(),
        float2.fromPyobj(du).getElementPtr(),
        float2.fromPyobj(dw).getElementPtr(),
        float2.fromPyobj(x).getElementPtr(),batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCgpsvInterleavedBatch__retval,)


@cython.embedsignature(True)
def hipsparseZgpsvInterleavedBatch(object handle, int algo, int m, object ds, object dl, object d, object du, object dw, object x, int batchCount, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        algo (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        ds (`~.double2`/`~.object`):
            (undocumented)

        dl (`~.double2`/`~.object`):
            (undocumented)

        d (`~.double2`/`~.object`):
            (undocumented)

        du (`~.double2`/`~.object`):
            (undocumented)

        dw (`~.double2`/`~.object`):
            (undocumented)

        x (`~.double2`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgpsvInterleavedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseZgpsvInterleavedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,algo,m,
        double2.fromPyobj(ds).getElementPtr(),
        double2.fromPyobj(dl).getElementPtr(),
        double2.fromPyobj(d).getElementPtr(),
        double2.fromPyobj(du).getElementPtr(),
        double2.fromPyobj(dw).getElementPtr(),
        double2.fromPyobj(x).getElementPtr(),batchCount,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZgpsvInterleavedBatch__retval,)


@cython.embedsignature(True)
def hipsparseSnnz(object handle, object dirA, int m, int n, object descrA, object A, int lda, object nnzPerRowColumn, object nnzTotalDevHostPtr):
    r"""``hipsparseXnnz`` computes the number of nonzero elements per row or column and the total
    number of nonzero elements in a dense matrix.

    For example, given the dense matrix:

    .. math::

       \begin{bmatrix}
       1 & 0 & 0 & 2 \\
       3 & 4 & 0 & 0 \\
       5 & 0 & 6 & 7
       \end{bmatrix}

    then using ``dirA`` == ``HIPSPARSE_DIRECTION_ROW`` results in:

    .. math::

       \begin{align}
       \text{nnzPerRowColumn} &= \begin{bmatrix} 2 & 2 & 3 \end{bmatrix} \\
       \text{nnzTotalDevHostPtr} &= 7
       \end{align}

    while using ``dirA`` == ``HIPSPARSE_DIRECTION_COLUMN`` results in:

    .. math::

       \begin{align}
       \text{nnzPerRowColumn} &= \begin{bmatrix} 3 & 1 & 1 & 2 \end{bmatrix} \\
       \text{nnzTotalDevHostPtr} &= 7
       \end{align}

    Note:
        As indicated, nnzTotalDevHostPtr can point either to host or device memory. This is controlled
        by setting the pointer mode. See hipsparseSetPointerMode().

    Note:
        The routine does support asynchronous execution if the pointer mode is set to device.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        nnzPerRowColumn (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseSnnz__retval = hipsparseStatus_t(chipsparse.hipsparseSnnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.Pointer.fromPyobj(nnzPerRowColumn)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr))
    return (_hipsparseSnnz__retval,)


@cython.embedsignature(True)
def hipsparseDnnz(object handle, object dirA, int m, int n, object descrA, object A, int lda, object nnzPerRowColumn, object nnzTotalDevHostPtr):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        nnzPerRowColumn (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseDnnz__retval = hipsparseStatus_t(chipsparse.hipsparseDnnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <int *>hip._util.types.Pointer.fromPyobj(nnzPerRowColumn)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr))
    return (_hipsparseDnnz__retval,)


@cython.embedsignature(True)
def hipsparseCnnz(object handle, object dirA, int m, int n, object descrA, object A, int lda, object nnzPerRowColumn, object nnzTotalDevHostPtr):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        nnzPerRowColumn (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseCnnz__retval = hipsparseStatus_t(chipsparse.hipsparseCnnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(A).getElementPtr(),lda,
        <int *>hip._util.types.Pointer.fromPyobj(nnzPerRowColumn)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr))
    return (_hipsparseCnnz__retval,)


@cython.embedsignature(True)
def hipsparseZnnz(object handle, object dirA, int m, int n, object descrA, object A, int lda, object nnzPerRowColumn, object nnzTotalDevHostPtr):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        nnzPerRowColumn (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseZnnz__retval = hipsparseStatus_t(chipsparse.hipsparseZnnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(A).getElementPtr(),lda,
        <int *>hip._util.types.Pointer.fromPyobj(nnzPerRowColumn)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr))
    return (_hipsparseZnnz__retval,)


@cython.embedsignature(True)
def hipsparseSdense2csr(object handle, int m, int n, object descr, object A, int ld, object nnzPerRow, object csrVal, object csrRowPtr, object csrColInd):
    r"""``hipsparseXdense2csr`` converts the matrix A in dense format into a sparse matrix in CSR format.

    Given a dense, column ordered, matrix ``A`` with leading dimension ``ld`` where ``ld>=m,``
    ``hipsparseXdense2csr`` converts the matrix to a sparse CSR format matrix. All the parameters
    are assumed to have been pre-allocated by the user and the arrays are filled in based on number
    of nonzeros per row, which can be pre-computed with hipsparseXnnz(). The desired index base in
    the output CSR matrix is set in the ``hipsparseMatDescr_t`` . See hipsparseSetMatIndexBase().

    As an example, if using index base zero (i.e. the default) and the dense
    matrix:

    .. math::

       \begin{bmatrix}
       1 & 0 & 0 & 2 \\
       3 & 4 & 0 & 0 \\
       5 & 0 & 6 & 7
       \end{bmatrix}

    The conversion results in the CSR arrays:

    .. math::

       \begin{align}
       \text{csrRowPtr} &= \begin{bmatrix} 0 & 2 & 4 & 7 \end{bmatrix} \\
       \text{csrColInd} &= \begin{bmatrix} 0 & 3 & 0 & 1 & 0 & 2 & 3 \end{bmatrix} \\
       \text{csrVal} &= \begin{bmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 \end{bmatrix} \\
       \end{align}

    Note:
        It is executed asynchronously with respect to the host and may return control to the
        application on the host before the entire result is ready.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Dense matrix in column order
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       float hdense_A[15] = {1.0f, 0.0f, 6.0f, 2.0f, 4.0f, 0.0f, 0.0f, 5.0f, 0.0f, 3.0f, 0.0f, 7.0f, 0.0f, 0.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;

       float* ddense_A = nullptr;
       hipMalloc((void**)&ddense_A, sizeof(float) * m * n);
       hipMemcpy(ddense_A, hdense_A, sizeof(float) * m * n, hipMemcpyHostToDevice);

       // Allocate memory for the nnz_per_row_columns array
       int* dnnz_per_row;
       hipMalloc((void**)&dnnz_per_row, sizeof(int) * m);

       int nnz_A;
       hipsparseSnnz(handle, dir, m, n, descr, ddense_A, m, dnnz_per_row, &nnz_A);

       // Allocate sparse CSR matrix
       int* dcsrRowPtr = nullptr;
       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz_A);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz_A);

       hipsparseSdense2csr(handle, m, n, descr, ddense_A, m, dnnz_per_row, dcsrVal, dcsrRowPtr, dcsrColInd);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);
       hipFree(dnnz_per_row);
       hipFree(ddense_A);

       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)

        nnzPerRow (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSdense2csr__retval = hipsparseStatus_t(chipsparse.hipsparseSdense2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,ld,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerRow)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr))
    return (_hipsparseSdense2csr__retval,)


@cython.embedsignature(True)
def hipsparseDdense2csr(object handle, int m, int n, object descr, object A, int ld, object nnzPerRows, object csrCal, object csrRowPtr, object csrColInd):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)

        nnzPerRows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrCal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDdense2csr__retval = hipsparseStatus_t(chipsparse.hipsparseDdense2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,ld,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerRows)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrCal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr))
    return (_hipsparseDdense2csr__retval,)


@cython.embedsignature(True)
def hipsparseCdense2csr(object handle, int m, int n, object descr, object A, int ld, object nnzPerRow, object csrVal, object csrRowPtr, object csrColInd):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)

        nnzPerRow (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCdense2csr__retval = hipsparseStatus_t(chipsparse.hipsparseCdense2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        float2.fromPyobj(A).getElementPtr(),ld,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerRow)._ptr,
        float2.fromPyobj(csrVal).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr))
    return (_hipsparseCdense2csr__retval,)


@cython.embedsignature(True)
def hipsparseZdense2csr(object handle, int m, int n, object descr, object A, int ld, object nnzPerRows, object csrVal, object csrRowPtr, object csrColInd):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)

        nnzPerRows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZdense2csr__retval = hipsparseStatus_t(chipsparse.hipsparseZdense2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        double2.fromPyobj(A).getElementPtr(),ld,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerRows)._ptr,
        double2.fromPyobj(csrVal).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr))
    return (_hipsparseZdense2csr__retval,)


@cython.embedsignature(True)
def hipsparseSpruneDense2csr_bufferSize(object handle, int m, int n, object A, int lda, object threshold, object descr, object csrVal, object csrRowPtr, object csrColInd, object pBufferSizeInBytes):
    r"""``hipsparseSpruneDense2csr_bufferSize`` computes the the size of the user allocated temporary storage buffer
    used when converting a dense matrix to a pruned CSR matrix.

    Specifically given an input dense column ordered matrix A, with leading dimension ``lda`` where ``lda>=m,``
    the resulting pruned sparse CSR matrix C is computed using:

    .. math::

       |C(i,j)| = A(i, j) \text{  if |A(i, j)| > threshold}

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneDense2csr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneDense2csr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpruneDense2csr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDpruneDense2csr_bufferSize(object handle, int m, int n, object A, int lda, object threshold, object descr, object csrVal, object csrRowPtr, object csrColInd, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneDense2csr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneDense2csr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDpruneDense2csr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSpruneDense2csr_bufferSizeExt(object handle, int m, int n, object A, int lda, object threshold, object descr, object csrVal, object csrRowPtr, object csrColInd, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneDense2csr_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneDense2csr_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpruneDense2csr_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDpruneDense2csr_bufferSizeExt(object handle, int m, int n, object A, int lda, object threshold, object descr, object csrVal, object csrRowPtr, object csrColInd, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneDense2csr_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneDense2csr_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDpruneDense2csr_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseSpruneDense2csrNnz(object handle, int m, int n, object A, int lda, object threshold, object descr, object csrRowPtr, object nnzTotalDevHostPtr, object buffer):
    r"""``hipsparseXpruneDense2csrNnz`` function computes the number of nonzero elements per row and the total
    number of nonzero elements in a dense matrix once the elements less than the (non-negative) threshold are
    pruned from the matrix.

    Specifically given an input dense column ordered matrix A, with leading dimension ``lda`` where ``lda>=m,``
    the resulting pruned sparse CSR matrix C is computed using:

    .. math::

       |C(i,j)| = A(i, j) \text{  if |A(i, j)| > threshold}

    First the user must determine the size of the required temporary buffer using the routine
    ``hipsparseSpruneDense2csr_bufferSize`` and then allocate it. Next the user allocates ``csrRowPtr`` with size
    ``m+1.`` Then the passes both the temporary storage buffer as well as ``csrRowPtr`` to ``hipsparseXpruneDense2csrNnz``
    in order to determine the total number of non-zeros that will exist in the sparse CSR matrix C (after pruning has
    been performed on A) as well as fill the output CSR row pointer array ``csrRowPtr.``

    For example, given the dense matrix:

    .. math::

       \begin{bmatrix}
       6 & 2 & 3 & 7 \\
       5 & 6 & 7 & 8 \\
       5 & 4 & 8 & 1
       \end{bmatrix}

    and the ``threshold`` value 5, the resulting matrix after pruning is:

    .. math::

       \begin{bmatrix}
       6 & 0 & 0 & 7 \\
       0 & 6 & 7 & 8 \\
       0 & 0 & 8 & 0
       \end{bmatrix}

    and corresponding row pointer array and non-zero count:

    .. math::

       \begin{align}
       \text{csrRowPtr} &= \begin{bmatrix} 0 & 2 & 5 & 6 \end{bmatrix} \\
       \text{nnzTotalDevHostPtr} &= 6
       \end{align}

    Note:
        The routine does support asynchronous execution if the pointer mode is set to device.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneDense2csrNnz__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneDense2csrNnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseSpruneDense2csrNnz__retval,)


@cython.embedsignature(True)
def hipsparseDpruneDense2csrNnz(object handle, int m, int n, object A, int lda, object threshold, object descr, object csrRowPtr, object nnzTotalDevHostPtr, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneDense2csrNnz__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneDense2csrNnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseDpruneDense2csrNnz__retval,)


@cython.embedsignature(True)
def hipsparseSpruneDense2csr(object handle, int m, int n, object A, int lda, object threshold, object descr, object csrVal, object csrRowPtr, object csrColInd, object buffer):
    r"""``hipsparseXpruneDense2csr`` converts the matrix A in dense format into a sparse matrix in CSR format
    while pruning values that are less than the (non-negative) threshold. All the parameters are assumed
    to have been pre-allocated by the user.

    Specifically given an input dense column ordered matrix A, with leading dimension ``lda`` where ``lda>=m,``
    the resulting pruned sparse CSR matrix C is computed using:

    .. math::

       |C(i,j)| = A(i, j) \text{  if |A(i, j)| > threshold}

    The user first calls ``hipsparseXpruneDense2csr_bufferSize`` to determine the size of the required
    user allocate temporary storage buffer. The user then allocates this buffer. Next, the user
    allocates ``csrRowPtr`` to have ``m+1`` elements and then calls hipsparseXpruneDense2csrNnz()
    which fills in the ``csrRowPtr`` array and stores the number of elements that are larger than the
    pruning ``threshold`` in ``nnzTotalDevHostPtr.`` The user then allocates ``csrColInd`` and ``csrVal`` to
    have size ``nnzTotalDevHostPtr`` and completes the conversion by calling hipsparseXpruneDense2csr().

    For example, performing these steps with the dense input matrix A:

    .. math::

       \begin{bmatrix}
       6 & 2 & 3 & 7 \\
       5 & 6 & 7 & 8 \\
       5 & 4 & 8 & 1
       \end{bmatrix}

    and the ``threshold`` value 5, results in the pruned matrix C:

    .. math::

       \begin{bmatrix}
       6 & 0 & 0 & 7 \\
       0 & 6 & 7 & 8 \\
       0 & 0 & 8 & 0
       \end{bmatrix}

    and corresponding CSR row, column, and values arrays:

    .. math::

       \begin{align}
       \text{csrRowPtr} &= \begin{bmatrix} 0 & 2 & 5 & 6 \end{bmatrix} \\
       \text{csrColInd} &= \begin{bmatrix} 0 & 3 & 1 & 2 & 3 & 2 \end{bmatrix} \\
       \text{csrVal} &= \begin{bmatrix} 6 & 7 & 6 & 7 & 8 & 8 \end{bmatrix} \\
       \end{align}

    Note:
        The routine hipsparseXpruneDense2csr() is executed asynchronously with respect to the host and may
        return control to the application on the host before the entire result is ready.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Dense matrix in column order
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       float hdense_A[15] = {1.0f, 0.0f, 6.0f, 2.0f, 4.0f, 0.0f, 0.0f, 5.0f, 0.0f, 3.0f, 0.0f, 7.0f, 0.0f, 0.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int lda       = m;
       float threshold = 4.0f;

       float* ddense_A = nullptr;
       hipMalloc((void**)&ddense_A, sizeof(float) * lda * n);
       hipMemcpy(ddense_A, hdense_A, sizeof(float) * lda * n, hipMemcpyHostToDevice);

       // Allocate sparse CSR matrix
       int* dcsrRowPtr = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));

       size_t bufferSize;
       hipsparseSpruneDense2csr_bufferSize(handle, m, n, ddense_A, lda, &threshold, descr, nullptr, dcsrRowPtr, nullptr, &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       int nnz_A;
       hipsparseSpruneDense2csrNnz(handle, m, n, ddense_A, lda, &threshold, descr, dcsrRowPtr, &nnz_A, dbuffer);

       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz_A);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz_A);

       hipsparseSpruneDense2csr(handle, m, n, ddense_A, lda, &threshold, descr, dcsrVal, dcsrRowPtr, dcsrColInd, dbuffer);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);
       hipFree(ddense_A);
       hipFree(dbuffer);

       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneDense2csr__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneDense2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const float *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseSpruneDense2csr__retval,)


@cython.embedsignature(True)
def hipsparseDpruneDense2csr(object handle, int m, int n, object A, int lda, object threshold, object descr, object csrVal, object csrRowPtr, object csrColInd, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneDense2csr__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneDense2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,
        <const double *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseDpruneDense2csr__retval,)


@cython.embedsignature(True)
def hipsparseSpruneDense2csrByPercentage_bufferSize(object handle, int m, int n, object A, int lda, float percentage, object descr, object csrVal, object csrRowPtr, object csrColInd, object info, object pBufferSizeInBytes):
    r"""``hipsparseSpruneDense2csrByPercentage_bufferSize`` computes the size of the user allocated temporary
    storage buffer used when converting a dense matrix to a pruned CSR matrix where the pruning is done
    based on a percantage.

    When converting and pruning a dense matrix A to a CSR matrix by percentage the
    following steps are performed. First the user calls
    ``hipsparseXpruneDense2csrByPercentage_bufferSize`` which determines the size of the
    temporary storage buffer. Once determined, this buffer must be allocated by the user.
    Next the user allocates the csrRowPtr array to have ``m+1`` elements and calls
    ``hipsparseXpruneDense2csrNnzByPercentage.`` Finally the user finishes the conversion
    by allocating the csrColInd and csrVal arrays (whose size is determined by the value
    at ``nnzTotalDevHostPtr)`` and calling ``hipsparseXpruneDense2csrByPercentage.``

    The pruning by percentage works by first sorting the absolute values of the dense
    matrix ``A.`` We then determine a position in this sorted array by

    .. math::

       pos = ceil(m*n*(percentage/100)) - 1 \\
       pos = min(pos, m*n-1) \\
       pos = max(pos, 0) \\
       threshold = sorted_A[pos]

    Note:
        It is executed asynchronously with respect to the host
        and may return control to the application on the host before the entire result is
        ready.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneDense2csrByPercentage_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneDense2csrByPercentage_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpruneDense2csrByPercentage_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDpruneDense2csrByPercentage_bufferSize(object handle, int m, int n, object A, int lda, double percentage, object descr, object csrVal, object csrRowPtr, object csrColInd, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneDense2csrByPercentage_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneDense2csrByPercentage_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDpruneDense2csrByPercentage_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSpruneDense2csrByPercentage_bufferSizeExt(object handle, int m, int n, object A, int lda, float percentage, object descr, object csrVal, object csrRowPtr, object csrColInd, object info, object pBufferSizeInBytes):
    r"""This function computes the size of the user allocated temporary storage buffer used
    when converting and pruning by percentage a dense matrix to a CSR matrix.

    When converting and pruning a dense matrix A to a CSR matrix by percentage the
    following steps are performed. First the user calls
    ``hipsparseXpruneDense2csrByPercentage_bufferSizeExt`` which determines the size of the
    temporary storage buffer. Once determined, this buffer must be allocated by the user.
    Next the user allocates the csrRowPtr array to have ``m+1`` elements and calls
    ``hipsparseXpruneDense2csrNnzByPercentage.`` Finally the user finishes the conversion
    by allocating the csrColInd and csrVal arrays (whos size is determined by the value
    at ``nnzTotalDevHostPtr)`` and calling ``hipsparseXpruneDense2csrByPercentage.``

    The pruning by percentage works by first sorting the absolute values of the dense
    matrix ``A.`` We then determine a position in this sorted array by

    .. math::

       pos = ceil(m*n*(percentage/100)) - 1 \\
       pos = min(pos, m*n-1) \\
       pos = max(pos, 0) \\
       threshold = sorted_A[pos]

    Note:
        It is executed asynchronously with respect to the host
        and may return control to the application on the host before the entire result is
        ready.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneDense2csrByPercentage_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneDense2csrByPercentage_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpruneDense2csrByPercentage_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDpruneDense2csrByPercentage_bufferSizeExt(object handle, int m, int n, object A, int lda, double percentage, object descr, object csrVal, object csrRowPtr, object csrColInd, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneDense2csrByPercentage_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneDense2csrByPercentage_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDpruneDense2csrByPercentage_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseSpruneDense2csrNnzByPercentage(object handle, int m, int n, object A, int lda, float percentage, object descr, object csrRowPtr, object nnzTotalDevHostPtr, object info, object buffer):
    r"""This function computes the number of nonzero elements per row and the total number of
    nonzero elements in a dense matrix when converting and pruning by percentage a dense
    matrix to a CSR matrix.

    When converting and pruning a dense matrix A to a CSR matrix by percentage the
    following steps are performed. First the user calls
    ``hipsparseXpruneDense2csrByPercentage_bufferSize`` which determines the size of the
    temporary storage buffer. Once determined, this buffer must be allocated by the user.
    Next the user allocates the csrRowPtr array to have ``m+1`` elements and calls
    ``hipsparseXpruneDense2csrNnzByPercentage.`` Finally the user finishes the conversion
    by allocating the csrColInd and csrVal arrays (whos size is determined by the value
    at ``nnzTotalDevHostPtr)`` and calling ``hipsparseXpruneDense2csrByPercentage.``

    The pruning by percentage works by first sorting the absolute values of the dense
    matrix ``A.`` We then determine a position in this sorted array by

    .. math::

       pos = ceil(m*n*(percentage/100)) - 1 \\
       pos = min(pos, m*n-1) \\
       pos = max(pos, 0) \\
       threshold = sorted_A[pos]

    Note:
        The routine does support asynchronous execution if the
        pointer mode is set to device.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneDense2csrNnzByPercentage__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneDense2csrNnzByPercentage(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseSpruneDense2csrNnzByPercentage__retval,)


@cython.embedsignature(True)
def hipsparseDpruneDense2csrNnzByPercentage(object handle, int m, int n, object A, int lda, double percentage, object descr, object csrRowPtr, object nnzTotalDevHostPtr, object info, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneDense2csrNnzByPercentage__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneDense2csrNnzByPercentage(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseDpruneDense2csrNnzByPercentage__retval,)


@cython.embedsignature(True)
def hipsparseSpruneDense2csrByPercentage(object handle, int m, int n, object A, int lda, float percentage, object descr, object csrVal, object csrRowPtr, object csrColInd, object info, object buffer):
    r"""This function computes the number of nonzero elements per row and the total number of
    nonzero elements in a dense matrix when converting and pruning by percentage a dense
    matrix to a CSR matrix.

    When converting and pruning a dense matrix A to a CSR matrix by percentage the
    following steps are performed. First the user calls
    ``hipsparseXpruneDense2csrByPercentage_bufferSize`` which determines the size of the
    temporary storage buffer. Once determined, this buffer must be allocated by the user.
    Next the user allocates the csrRowPtr array to have ``m+1`` elements and calls
    ``hipsparseXpruneDense2csrNnzByPercentage.`` Finally the user finishes the conversion
    by allocating the csrColInd and csrVal arrays (whos size is determined by the value
    at ``nnzTotalDevHostPtr)`` and calling ``hipsparseXpruneDense2csrByPercentage.``

    The pruning by percentage works by first sorting the absolute values of the dense
    matrix ``A.`` We then determine a position in this sorted array by

    .. math::

       pos = ceil(m*n*(percentage/100)) - 1 \\
       pos = min(pos, m*n-1) \\
       pos = max(pos, 0) \\
       threshold = sorted_A[pos]

    Note:
        The routine does support asynchronous execution if the pointer mode is set to device.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Dense matrix in column order
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       float hdense_A[15] = {1.0f, 0.0f, 6.0f, 2.0f, 4.0f, 0.0f, 0.0f, 5.0f, 0.0f, 3.0f, 0.0f, 7.0f, 0.0f, 0.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int lda       = m;
       float percentage = 70.0f;

       float* ddense_A = nullptr;
       hipMalloc((void**)&ddense_A, sizeof(float) * lda * n);
       hipMemcpy(ddense_A, hdense_A, sizeof(float) * lda * n, hipMemcpyHostToDevice);

       // Allocate sparse CSR matrix
       int* dcsrRowPtr = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));

       pruneInfo_t info;
       hipsparseCreatePruneInfo(&info);

       size_t bufferSize;
       hipsparseSpruneDense2csrByPercentage_bufferSize(handle, m, n, ddense_A, lda, percentage, descr, nullptr, dcsrRowPtr, nullptr, info, &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       int nnz_A;
       hipsparseSpruneDense2csrNnzByPercentage(handle, m, n, ddense_A, lda, percentage, descr, dcsrRowPtr, &nnz_A, info, dbuffer);

       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz_A);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz_A);

       hipsparseSpruneDense2csrByPercentage(handle, m, n, ddense_A, lda, percentage, descr, dcsrVal, dcsrRowPtr, dcsrColInd, info, dbuffer);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);
       hipFree(ddense_A);
       hipFree(dbuffer);

       hipsparseDestroyPruneInfo(info);
       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneDense2csrByPercentage__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneDense2csrByPercentage(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseSpruneDense2csrByPercentage__retval,)


@cython.embedsignature(True)
def hipsparseDpruneDense2csrByPercentage(object handle, int m, int n, object A, int lda, double percentage, object descr, object csrVal, object csrRowPtr, object csrColInd, object info, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        lda (`~.int`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneDense2csrByPercentage__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneDense2csrByPercentage(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,lda,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseDpruneDense2csrByPercentage__retval,)


@cython.embedsignature(True)
def hipsparseSdense2csc(object handle, int m, int n, object descr, object A, int ld, object nnzPerColumn, object cscVal, object cscRowInd, object cscColPtr):
    r"""``hipsparseXdense2csc`` converts the matrix A in dense format into a sparse matrix in CSC format.

    Given a dense, column ordered, matrix ``A`` with leading dimension ``ld`` where ``ld>=m,``
    ``hipsparseXdense2csc`` converts the matrix to a sparse CSC format matrix.
    All the parameters are assumed to have been pre-allocated by the user and the arrays
    are filled in based on number of nonzeros per row, which can be pre-computed with hipsparseXnnz().
    We can set the desired index base in the output CSC matrix by setting it in the ``hipsparseMatDescr_t`` .
    See hipsparseSetMatIndexBase().

    As an example, if using index base zero (i.e. the default) and the dense
    matrix:

    .. math::

       \begin{bmatrix}
       1 & 0 & 0 & 2 \\
       3 & 4 & 0 & 0 \\
       5 & 0 & 6 & 7
       \end{bmatrix}

    where the ``A`` values have column ordering with leading dimension ``ld=m:``

    .. math::

       \text{A} &= \begin{bmatrix} 1 & 3 & 5 & 0 & 4 & 0 & 0 & 0 & 6 & 2 & 0 & 7 \end{bmatrix} \\

    the conversion results in the CSC arrays:

    .. math::

       \begin{align}
       \text{cscRowInd} &= \begin{bmatrix} 0 & 1 & 2 & 1 & 2 & 0 & 2 \end{bmatrix} \\
       \text{cscColPtr} &= \begin{bmatrix} 0 & 3 & 4 & 5 & 7 \end{bmatrix} \\
       \text{cscVal} &= \begin{bmatrix} 1 & 3 & 5 & 4 & 6 & 2 & 7 \end{bmatrix} \\
       \end{align}

    Note:
        It is executed asynchronously with respect to the host and may return control to the
        application on the host before the entire result is ready.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)

        nnzPerColumn (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSdense2csc__retval = hipsparseStatus_t(chipsparse.hipsparseSdense2csc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(A)._ptr,ld,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerColumn)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(cscVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr))
    return (_hipsparseSdense2csc__retval,)


@cython.embedsignature(True)
def hipsparseDdense2csc(object handle, int m, int n, object descr, object A, int ld, object nnzPerColumn, object cscVal, object cscRowInd, object cscColPtr):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)

        nnzPerColumn (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDdense2csc__retval = hipsparseStatus_t(chipsparse.hipsparseDdense2csc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(A)._ptr,ld,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerColumn)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(cscVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr))
    return (_hipsparseDdense2csc__retval,)


@cython.embedsignature(True)
def hipsparseCdense2csc(object handle, int m, int n, object descr, object A, int ld, object nnzPerColumn, object cscVal, object cscRowInd, object cscColPtr):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)

        nnzPerColumn (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscVal (`~.float2`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCdense2csc__retval = hipsparseStatus_t(chipsparse.hipsparseCdense2csc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        float2.fromPyobj(A).getElementPtr(),ld,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerColumn)._ptr,
        float2.fromPyobj(cscVal).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr))
    return (_hipsparseCdense2csc__retval,)


@cython.embedsignature(True)
def hipsparseZdense2csc(object handle, int m, int n, object descr, object A, int ld, object nnzPerColumn, object cscVal, object cscRowInd, object cscColPtr):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)

        nnzPerColumn (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscVal (`~.double2`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZdense2csc__retval = hipsparseStatus_t(chipsparse.hipsparseZdense2csc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        double2.fromPyobj(A).getElementPtr(),ld,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerColumn)._ptr,
        double2.fromPyobj(cscVal).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr))
    return (_hipsparseZdense2csc__retval,)


@cython.embedsignature(True)
def hipsparseScsr2dense(object handle, int m, int n, object descr, object csrVal, object csrRowPtr, object csrColInd, object A, int ld):
    r"""``hipsparseXcsr2dense`` function converts the sparse matrix in CSR format into a dense matrix.

    Given the input CSR matrix of size ``mxn,`` the routine writes the matrix to the dense array ``A`` such
    that ``A`` has leading dimension ``ld`` and is column ordered. This means that ``A`` has size ``ldxn`` where
    ``ld>=m.`` All the parameters are assumed to have been pre-allocated by the user. If the input CSR matrix
    has index base of one, it must be set in the ``hipsparseMatDescr_t`` . See hipsparseSetMatIndexBase()
    prior to calling ``hipsparseXcsr2dense.``

    For example, consider the sparse CSR matrix:

    .. math::

       \begin{align}
       \text{csrRowPtr} &= \begin{bmatrix} 0 & 2 & 4 & 7 \end{bmatrix} \\
       \text{csrColInd} &= \begin{bmatrix} 0 & 3 & 0 & 1 & 0 & 2 & 3 \end{bmatrix} \\
       \text{csrVal} &= \begin{bmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 \end{bmatrix} \\
       \end{align}

    ``hipsparseXcsr2dense`` is used to convert to the dense matrix:

    .. math::

       \begin{bmatrix}
       1 & 0 & 0 & 2 \\
       3 & 4 & 0 & 0 \\
       5 & 0 & 6 & 7
       \end{bmatrix}

    where the values in the ``A`` array are column ordered:

    .. math::

       \text{A} &= \begin{bmatrix} 1 & 3 & 5 & 0 & 4 & 0 & 0 & 0 & 6 & 2 & 0 & 7 \end{bmatrix} \\

    Note:
        It is executed asynchronously with respect to the host and may return control to the application
        on the host before the entire result is ready.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Sparse matrix in CSR format
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcsrRowPtr[4] = {0, 3, 5, 8};
       int hcsrColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
       float hcsrVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int ld        = 3;
       int nnz       = 8;

       int* dcsrRowPtr = nullptr;
       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);

       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       float* ddense_A = nullptr;
       hipMalloc((void**)&ddense_A, sizeof(float) * ld * n);

       hipsparseScsr2dense(handle, m, n, descr, dcsrVal, dcsrRowPtr, dcsrColInd, ddense_A, ld);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);
       hipFree(ddense_A);

       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)
    """
    _hipsparseScsr2dense__retval = hipsparseStatus_t(chipsparse.hipsparseScsr2dense(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(A)._ptr,ld))
    return (_hipsparseScsr2dense__retval,)


@cython.embedsignature(True)
def hipsparseDcsr2dense(object handle, int m, int n, object descr, object csrVal, object csrRowPtr, object csrColInd, object A, int ld):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)
    """
    _hipsparseDcsr2dense__retval = hipsparseStatus_t(chipsparse.hipsparseDcsr2dense(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(A)._ptr,ld))
    return (_hipsparseDcsr2dense__retval,)


@cython.embedsignature(True)
def hipsparseCcsr2dense(object handle, int m, int n, object descr, object csrVal, object csrRowPtr, object csrColInd, object A, int ld):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)
    """
    _hipsparseCcsr2dense__retval = hipsparseStatus_t(chipsparse.hipsparseCcsr2dense(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        float2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        float2.fromPyobj(A).getElementPtr(),ld))
    return (_hipsparseCcsr2dense__retval,)


@cython.embedsignature(True)
def hipsparseZcsr2dense(object handle, int m, int n, object descr, object csrVal, object csrRowPtr, object csrColInd, object A, int ld):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)
    """
    _hipsparseZcsr2dense__retval = hipsparseStatus_t(chipsparse.hipsparseZcsr2dense(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        double2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        double2.fromPyobj(A).getElementPtr(),ld))
    return (_hipsparseZcsr2dense__retval,)


@cython.embedsignature(True)
def hipsparseScsc2dense(object handle, int m, int n, object descr, object cscVal, object cscRowInd, object cscColPtr, object A, int ld):
    r"""``hipsparseXcsc2dense`` function converts the sparse matrix in CSC format into a dense matrix.

    Given the input CSC matrix of size ``mxn,`` the routine writes the matrix to the dense array ``A`` such
    that ``A`` has leading dimension ``ld`` and is column ordered. This means that ``A`` has size ``ldxn`` where
    ``ld>=m.`` All the parameters are assumed to have been pre-allocated by the user. If the input CSC matrix
    has index base of one, it must be set in the ``hipsparseMatDescr_t`` . See hipsparseSetMatIndexBase()
    prior to calling ``hipsparseXcsc2dense.``

    For example, consider the sparse CSC matrix:

    .. math::

       \begin{align}
       \text{cscRowInd} &= \begin{bmatrix} 0 & 1 & 2 & 1 & 2 & 0 & 2 \end{bmatrix} \\
       \text{cscColPtr} &= \begin{bmatrix} 0 & 3 & 4 & 5 & 7 \end{bmatrix} \\
       \text{cscVal} &= \begin{bmatrix} 1 & 3 & 5 & 4 & 6 & 2 & 7 \end{bmatrix} \\
       \end{align}

    ``hipsparseXcsc2dense`` is used to convert to the dense matrix:

    .. math::

       \begin{bmatrix}
       1 & 0 & 0 & 2 \\
       3 & 4 & 0 & 0 \\
       5 & 0 & 6 & 7
       \end{bmatrix}

    where the values in the ``A`` array are column ordered:

    .. math::

       \text{A} &= \begin{bmatrix} 1 & 3 & 5 & 0 & 4 & 0 & 0 & 0 & 6 & 2 & 0 & 7 \end{bmatrix} \\

    Note:
        It is executed asynchronously with respect to the host and may return control to the application
        on the host before the entire result is ready.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)
    """
    _hipsparseScsc2dense__retval = hipsparseStatus_t(chipsparse.hipsparseScsc2dense(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(cscVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(A)._ptr,ld))
    return (_hipsparseScsc2dense__retval,)


@cython.embedsignature(True)
def hipsparseDcsc2dense(object handle, int m, int n, object descr, object cscVal, object cscRowInd, object cscColPtr, object A, int ld):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)
    """
    _hipsparseDcsc2dense__retval = hipsparseStatus_t(chipsparse.hipsparseDcsc2dense(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(cscVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(A)._ptr,ld))
    return (_hipsparseDcsc2dense__retval,)


@cython.embedsignature(True)
def hipsparseCcsc2dense(object handle, int m, int n, object descr, object cscVal, object cscRowInd, object cscColPtr, object A, int ld):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscVal (`~.float2`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.float2`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)
    """
    _hipsparseCcsc2dense__retval = hipsparseStatus_t(chipsparse.hipsparseCcsc2dense(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        float2.fromPyobj(cscVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr,
        float2.fromPyobj(A).getElementPtr(),ld))
    return (_hipsparseCcsc2dense__retval,)


@cython.embedsignature(True)
def hipsparseZcsc2dense(object handle, int m, int n, object descr, object cscVal, object cscRowInd, object cscColPtr, object A, int ld):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscVal (`~.double2`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.double2`/`~.object`):
            (undocumented)

        ld (`~.int`):
            (undocumented)
    """
    _hipsparseZcsc2dense__retval = hipsparseStatus_t(chipsparse.hipsparseZcsc2dense(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descr)._ptr,
        double2.fromPyobj(cscVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr,
        double2.fromPyobj(A).getElementPtr(),ld))
    return (_hipsparseZcsc2dense__retval,)


@cython.embedsignature(True)
def hipsparseXcsr2bsrNnz(object handle, object dirA, int m, int n, object descrA, object csrRowPtrA, object csrColIndA, int blockDim, object descrC, object bsrRowPtrC, object bsrNnzb):
    r"""This function computes the number of nonzero block columns per row and the total number of nonzero blocks in a sparse
    BSR matrix given a sparse CSR matrix as input.

    Consider the matrix:

    .. math::

       \begin{bmatrix}
       1 & 0 & 0 & 2 \\
       3 & 4 & 0 & 0 \\
       5 & 0 & 6 & 7 \\
       1 & 2 & 3 & 4
       \end{bmatrix}

    stored as a sparse CSR matrix. This function computes both the BSR row pointer array as well as the total number
    of non-zero blocks that results when converting the CSR matrix to the BSR format. Assuming a block dimension of 2,
    the above matrix once converted to BSR format looks like:

    .. math::

        \left[
         \begin{array}{c | c}
           \begin{array}{c c}
            1 & 0 \\
            3 & 4
           \end{array} &
           \begin{array}{c c}
            0 & 2 \\
            0 & 0
           \end{array} \\
         \hline
           \begin{array}{c c}
            5 & 0 \\
            1 & 2
           \end{array} &
           \begin{array}{c c}
            6 & 7 \\
            3 & 4
           \end{array} \\
        \end{array}
       \right]

    and the resulting BSR row pointer array and total non-zero blocks once ``hipsparseXcsr2bsrNnz`` has been called:

    .. math::

       \begin{align}
       \text{bsrRowPtrC} &= \begin{bmatrix} 0 & 2 & 4 \end{bmatrix} \\
       \text{bsrNnzb} &= 4
       \end{align}

    In general, when converting a CSR matrix of size ``m`` x ``n`` to a BSR matrix, the resulting BSR matrix will have size
    ``mb`` x ``nb`` where ``mb`` and ``nb`` equal:

    .. math::

       \begin{align}
       \text{mb} &= \text{(m - 1) / blockDim + 1} \\
       \text{nb} &= \text{(n - 1) / blockDim + 1}
       \end{align}

    In particular, it may be the case that ``blockDim`` does not divide evenly into ``m`` and/or ``n.`` In these cases, the
    CSR matrix is expanded in size in order to fit full BSR blocks. For example, using the original CSR matrix and block
    dimension 3 instead of 2, the function ``hipsparseXcsr2bsrNnz`` computes the BSR row pointer array and total number of
    non-zero blocks for the BSR matrix:

    .. math::

        \left[
         \begin{array}{c | c}
           \begin{array}{c c c}
            1 & 0 & 0 \\
            3 & 4 & 0 \\
            5 & 0 & 6
           \end{array} &
           \begin{array}{c c c}
            2 & 0 & 0 \\
            0 & 0 & 0 \\
            7 & 0 & 0
           \end{array} \\
         \hline
           \begin{array}{c c c}
            1 & 2 & 3 \\
            0 & 0 & 0 \\
            0 & 0 & 0
           \end{array} &
           \begin{array}{c c c}
            4 & 0 & 0 \\
            0 & 0 & 0 \\
            0 & 0 & 0
           \end{array} \\
        \end{array}
       \right]

    Note:
        The routine does support asynchronous execution if the pointer mode is set to device.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrNnzb (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseXcsr2bsrNnz__retval = hipsparseStatus_t(chipsparse.hipsparseXcsr2bsrNnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,blockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrNnzb)._ptr))
    return (_hipsparseXcsr2bsrNnz__retval,)


@cython.embedsignature(True)
def hipsparseSnnz_compress(object handle, int m, object descrA, object csrValA, object csrRowPtrA, object nnzPerRow, object nnzC, float tol):
    r"""(No short description, might be part of a group.)

    This function is used as the first step in converting a CSR matrix to a compressed CSR matrix.

    Given a sparse CSR matrix and a non-negative tolerance, this function computes how many entries would be left
    in each row of the matrix if elements less than the tolerance were removed. It also computes the total number
    of remaining elements in the matrix.

    Specifically given an input sparse matrix A in CSR format, the resulting compressed sparse CSR matrix C is
    computed using:

    .. math::

       C(i,j) = A(i, j) \text{  if |A(i, j)| > tol}

    Note:
        In the case of complex matrices only the magnitude of the real part of ``tol`` is used.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Matrix descriptor
       hipsparseMatDescr_t descr_A;
       hipsparseCreateMatDescr(&descr_A);

       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       float tol = 4.2f;

       int m     = 3;
       int n     = 5;
       int nnz_A = 8;

       int hcsrRowPtr_A[4] = {0, 3, 5, 8};
       float hcsrVal_A[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};

       int* dcsrRowPtr_A = nullptr;
       float* dcsrVal_A = nullptr;
       hipMalloc((void**)&dcsrRowPtr_A, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrVal_A, sizeof(float) * nnz_A);

       hipMemcpy(dcsrRowPtr_A, hcsrRowPtr_A, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal_A, hcsrVal_A, sizeof(float) * nnz_A, hipMemcpyHostToDevice);

       // Allocate memory for the nnz_per_row array
       int* dnnz_per_row;
       hipMalloc((void**)&dnnz_per_row, sizeof(int) * m);

       // Call snnz_compress() which fills in nnz_per_row array and finds the number
       // of entries that will be in the compressed CSR matrix
       int nnz_C;
       hipsparseSnnz_compress(handle, m, descr_A, dcsrVal_A, dcsrRowPtr_A, dnnz_per_row, &nnz_C, tol);

       hipFree(dcsrRowPtr_A);
       hipFree(dcsrVal_A);
       hipFree(dnnz_per_row);

       hipsparseDestroyMatDescr(descr_A);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzPerRow (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        tol (`~.float`/`~.int`):
            (undocumented)
    """
    _hipsparseSnnz_compress__retval = hipsparseStatus_t(chipsparse.hipsparseSnnz_compress(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzPerRow)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzC)._ptr,tol))
    return (_hipsparseSnnz_compress__retval,)


@cython.embedsignature(True)
def hipsparseDnnz_compress(object handle, int m, object descrA, object csrValA, object csrRowPtrA, object nnzPerRow, object nnzC, double tol):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzPerRow (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        tol (`~.float`/`~.int`):
            (undocumented)
    """
    _hipsparseDnnz_compress__retval = hipsparseStatus_t(chipsparse.hipsparseDnnz_compress(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzPerRow)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzC)._ptr,tol))
    return (_hipsparseDnnz_compress__retval,)


@cython.embedsignature(True)
def hipsparseCnnz_compress(object handle, int m, object descrA, object csrValA, object csrRowPtrA, object nnzPerRow, object nnzC, object tol):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzPerRow (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        tol (`~.float2`):
            (undocumented)
    """
    _hipsparseCnnz_compress__retval = hipsparseStatus_t(chipsparse.hipsparseCnnz_compress(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzPerRow)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzC)._ptr,
        float2.fromPyobj(tol).getElementPtr()[0]))
    return (_hipsparseCnnz_compress__retval,)


@cython.embedsignature(True)
def hipsparseZnnz_compress(object handle, int m, object descrA, object csrValA, object csrRowPtrA, object nnzPerRow, object nnzC, object tol):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzPerRow (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        tol (`~.double2`):
            (undocumented)
    """
    _hipsparseZnnz_compress__retval = hipsparseStatus_t(chipsparse.hipsparseZnnz_compress(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzPerRow)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzC)._ptr,
        double2.fromPyobj(tol).getElementPtr()[0]))
    return (_hipsparseZnnz_compress__retval,)


@cython.embedsignature(True)
def hipsparseXcsr2coo(object handle, object csrRowPtr, int nnz, int m, object cooRowInd, object idxBase):
    r"""Convert a sparse CSR matrix into a sparse COO matrix

    ``hipsparseXcsr2coo`` converts the CSR array containing the row offsets, that point
    to the start of every row, into a COO array of row indices. All arrays are assumed
    to be allocated by the user prior to calling ``hipsparseXcsr2coo.``

    For example, given the CSR row pointer array (assuming zero index base):

    .. math::

       \begin{align}
       \text{csrRowPtr} &= \begin{bmatrix} 0 & 1 & 3 & 4 \end{bmatrix}
       \end{align}

    Calling ``hipsparseXcsr2coo()`` results in the COO row indices array:

    .. math::

       \begin{align}
       \text{cooRowInd} &= \begin{bmatrix} 0 & 1 & 1 & 2 \end{bmatrix}
       \end{align}

    Note:
        It can also be used to convert a CSC array containing the column offsets into a COO
        array of column indices.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        cooRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseXcsr2coo__retval = hipsparseStatus_t(chipsparse.hipsparseXcsr2coo(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,nnz,m,
        <int *>hip._util.types.Pointer.fromPyobj(cooRowInd)._ptr,idxBase.value))
    return (_hipsparseXcsr2coo__retval,)


@cython.embedsignature(True)
def hipsparseScsr2csc(object handle, int m, int n, int nnz, object csrSortedVal, object csrSortedRowPtr, object csrSortedColInd, object cscSortedVal, object cscSortedRowInd, object cscSortedColPtr, object copyValues, object idxBase):
    r"""Convert a sparse CSR matrix into a sparse CSC matrix

    ``hipsparseXcsr2csc`` converts a CSR matrix into a CSC matrix. ``hipsparseXcsr2csc``
    can also be used to convert a CSC matrix into a CSR matrix. ``copyValues`` decides
    whether ``cscSortedVal`` is being filled during conversion (``HIPSPARSE_ACTION_NUMERIC`` )
    or not (``HIPSPARSE_ACTION_SYMBOLIC`` ).

    For example given the matrix:

    .. math::

       \begin{bmatrix}
       1 & 0 & 0 & 2 \\
       3 & 4 & 0 & 0 \\
       5 & 0 & 6 & 7
       \end{bmatrix}

    Represented using the sparse CSR format as:

    .. math::

       \begin{align}
       \text{csrSortedRowPtr} &= \begin{bmatrix} 0 & 2 & 4 & 7 \end{bmatrix}
       \text{csrSortedColInd} &= \begin{bmatrix} 0 & 3 & 0 & 1 & 0 & 2 & 3 \end{bmatrix}
       \text{csrSortedVal} &= \begin{bmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 \end{bmatrix}
       \end{align}

    this function converts to sparse CSC format:

    .. math::

       \begin{align}
       \text{cscSortedRowInd} &= \begin{bmatrix} 0 & 1 & 2 & 1 & 2 & 0 & 2 \end{bmatrix}
       \text{cscSortedColPtr} &= \begin{bmatrix} 0 & 3 & 4 & 5 & 7 \end{bmatrix}
       \text{cscSortedVal} &= \begin{bmatrix} 1 & 3 & 5 & 4 & 6 & 2 & 7 \end{bmatrix}
       \end{align}

    Note:
        The resulting matrix can also be seen as the transpose of the input matrix.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Sparse matrix in CSR format
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcsrRowPtr[4] = {0, 3, 5, 8};
       int hcsrColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
       float hcsrVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int nnz       = 8;
       hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;
       hipsparseAction_t action = HIPSPARSE_ACTION_NUMERIC;

       int* dcsrRowPtr = nullptr;
       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);

       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       int* dcscRowInd = nullptr;
       int* dcscColPtr = nullptr;
       float* dcsc_val   = nullptr;
       hipMalloc((void**)&dcscRowInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcscColPtr, sizeof(int) * (n + 1));
       hipMalloc((void**)&dcsc_val, sizeof(float) * nnz);

       hipsparseScsr2csc(handle, m, n, nnz, dcsrVal, dcsrRowPtr, dcsrColInd, dcsc_val, dcscRowInd, dcscColPtr, action, base);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);

       hipFree(dcscRowInd);
       hipFree(dcscColPtr);
       hipFree(dcsc_val);

       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrSortedVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscSortedVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscSortedRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscSortedColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        copyValues (`~.hipsparseAction_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(copyValues,_hipsparseAction_t__Base):
        raise TypeError("argument 'copyValues' must be of type '_hipsparseAction_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseScsr2csc__retval = hipsparseStatus_t(chipsparse.hipsparseScsr2csc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColInd)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(cscSortedVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscSortedRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscSortedColPtr)._ptr,copyValues.value,idxBase.value))
    return (_hipsparseScsr2csc__retval,)


@cython.embedsignature(True)
def hipsparseDcsr2csc(object handle, int m, int n, int nnz, object csrSortedVal, object csrSortedRowPtr, object csrSortedColInd, object cscSortedVal, object cscSortedRowInd, object cscSortedColPtr, object copyValues, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrSortedVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscSortedVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscSortedRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscSortedColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        copyValues (`~.hipsparseAction_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(copyValues,_hipsparseAction_t__Base):
        raise TypeError("argument 'copyValues' must be of type '_hipsparseAction_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseDcsr2csc__retval = hipsparseStatus_t(chipsparse.hipsparseDcsr2csc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColInd)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(cscSortedVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscSortedRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscSortedColPtr)._ptr,copyValues.value,idxBase.value))
    return (_hipsparseDcsr2csc__retval,)


@cython.embedsignature(True)
def hipsparseCcsr2csc(object handle, int m, int n, int nnz, object csrSortedVal, object csrSortedRowPtr, object csrSortedColInd, object cscSortedVal, object cscSortedRowInd, object cscSortedColPtr, object copyValues, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrSortedVal (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscSortedVal (`~.float2`/`~.object`):
            (undocumented)

        cscSortedRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscSortedColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        copyValues (`~.hipsparseAction_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(copyValues,_hipsparseAction_t__Base):
        raise TypeError("argument 'copyValues' must be of type '_hipsparseAction_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseCcsr2csc__retval = hipsparseStatus_t(chipsparse.hipsparseCcsr2csc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        float2.fromPyobj(csrSortedVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColInd)._ptr,
        float2.fromPyobj(cscSortedVal).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(cscSortedRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscSortedColPtr)._ptr,copyValues.value,idxBase.value))
    return (_hipsparseCcsr2csc__retval,)


@cython.embedsignature(True)
def hipsparseZcsr2csc(object handle, int m, int n, int nnz, object csrSortedVal, object csrSortedRowPtr, object csrSortedColInd, object cscSortedVal, object cscSortedRowInd, object cscSortedColPtr, object copyValues, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrSortedVal (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscSortedVal (`~.double2`/`~.object`):
            (undocumented)

        cscSortedRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscSortedColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        copyValues (`~.hipsparseAction_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(copyValues,_hipsparseAction_t__Base):
        raise TypeError("argument 'copyValues' must be of type '_hipsparseAction_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseZcsr2csc__retval = hipsparseStatus_t(chipsparse.hipsparseZcsr2csc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        double2.fromPyobj(csrSortedVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColInd)._ptr,
        double2.fromPyobj(cscSortedVal).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(cscSortedRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscSortedColPtr)._ptr,copyValues.value,idxBase.value))
    return (_hipsparseZcsr2csc__retval,)


class _hipsparseCsr2CscAlg_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseCsr2CscAlg_t(_hipsparseCsr2CscAlg_t__Base):
    """hipsparseCsr2CscAlg_t

    Attributes:
        HIPSPARSE_CSR2CSC_ALG_DEFAULT:
            (undocumented)
        HIPSPARSE_CSR2CSC_ALG1:
            (undocumented)
        HIPSPARSE_CSR2CSC_ALG2:
            (undocumented)
    """
    HIPSPARSE_CSR2CSC_ALG_DEFAULT = chipsparse.HIPSPARSE_CSR2CSC_ALG_DEFAULT
    HIPSPARSE_CSR2CSC_ALG1 = chipsparse.HIPSPARSE_CSR2CSC_ALG1
    HIPSPARSE_CSR2CSC_ALG2 = chipsparse.HIPSPARSE_CSR2CSC_ALG2
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


@cython.embedsignature(True)
def hipsparseCsr2cscEx2_bufferSize(object handle, int m, int n, int nnz, object csrVal, object csrRowPtr, object csrColInd, object cscVal, object cscColPtr, object cscRowInd, object valType, object copyValues, object idxBase, object alg, object pBufferSizeInBytes):
    r"""This function computes the size of the user allocated temporary storage buffer used
    when converting a sparse CSR matrix into a sparse CSC matrix.

    ``hipsparseCsr2cscEx2_bufferSize`` calculates the required user allocated temporary buffer needed
    by ``hipsparseCsr2cscEx2`` to convert a CSR matrix into a CSC matrix. ``hipsparseCsr2cscEx2``
    can also be used to convert a CSC matrix into a CSR matrix. ``copyValues`` decides
    whether ``cscVal`` is being filled during conversion (``HIPSPARSE_ACTION_NUMERIC`` )
    or not (``HIPSPARSE_ACTION_SYMBOLIC`` ).

    Note:
        The resulting matrix can also be seen as the transpose of the input matrix.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valType (`~.hipDataType`):
            (undocumented)

        copyValues (`~.hipsparseAction_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        alg (`~.hipsparseCsr2CscAlg_t`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(valType,_hipDataType__Base):
        raise TypeError("argument 'valType' must be of type '_hipDataType__Base'")                    
    if not isinstance(copyValues,_hipsparseAction_t__Base):
        raise TypeError("argument 'copyValues' must be of type '_hipsparseAction_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(alg,_hipsparseCsr2CscAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseCsr2CscAlg_t__Base'")
    _hipsparseCsr2cscEx2_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCsr2cscEx2_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <const void *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cscVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,valType.value,copyValues.value,idxBase.value,alg.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCsr2cscEx2_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCsr2cscEx2(object handle, int m, int n, int nnz, object csrVal, object csrRowPtr, object csrColInd, object cscVal, object cscColPtr, object cscRowInd, object valType, object copyValues, object idxBase, object alg, object buffer):
    r"""Convert a sparse CSR matrix into a sparse CSC matrix

    ``hipsparseCsr2cscEx2`` converts a CSR matrix into a CSC matrix. ``hipsparseCsr2cscEx2``
    can also be used to convert a CSC matrix into a CSR matrix. ``copyValues`` decides
    whether ``cscVal`` is being filled during conversion (``HIPSPARSE_ACTION_NUMERIC`` )
    or not (``HIPSPARSE_ACTION_SYMBOLIC`` ).

    Note:
        The resulting matrix can also be seen as the transpose of the input matrix.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Sparse matrix in CSR format
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcsrRowPtr[4] = {0, 3, 5, 8};
       int hcsrColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
       float hcsrVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int nnz       = 8;
       hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;
       hipsparseAction_t action = HIPSPARSE_ACTION_NUMERIC;
       hipsparseCsr2CscAlg_t alg = HIPSPARSE_CSR2CSC_ALG_DEFAULT;

       int* dcsrRowPtr = nullptr;
       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);

       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       int* dcscRowInd = nullptr;
       int* dcscColPtr = nullptr;
       float* dcsc_val   = nullptr;
       hipMalloc((void**)&dcscRowInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcscColPtr, sizeof(int) * (n + 1));
       hipMalloc((void**)&dcsc_val, sizeof(float) * nnz);

       size_t bufferSize;
       hipsparseCsr2cscEx2_bufferSize(handle,
                                      m,
                                      n,
                                      nnz,
                                      dcsrVal,
                                      dcsrRowPtr,
                                      dcsrColInd,
                                      dcsc_val,
                                      dcscColPtr,
                                      dcscRowInd,
                                      HIP_R_32F,
                                      action,
                                      base,
                                      alg,
                                      &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       hipsparseCsr2cscEx2(handle,
                           m,
                           n,
                           nnz,
                           dcsrVal,
                           dcsrRowPtr,
                           dcsrColInd,
                           dcsc_val,
                           dcscColPtr,
                           dcscRowInd,
                           HIP_R_32F,
                           action,
                           base,
                           alg,
                           dbuffer);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);

       hipFree(dcscRowInd);
       hipFree(dcscColPtr);
       hipFree(dcsc_val);

       hipFree(dbuffer);

       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valType (`~.hipDataType`):
            (undocumented)

        copyValues (`~.hipsparseAction_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        alg (`~.hipsparseCsr2CscAlg_t`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(valType,_hipDataType__Base):
        raise TypeError("argument 'valType' must be of type '_hipDataType__Base'")                    
    if not isinstance(copyValues,_hipsparseAction_t__Base):
        raise TypeError("argument 'copyValues' must be of type '_hipsparseAction_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(alg,_hipsparseCsr2CscAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseCsr2CscAlg_t__Base'")
    _hipsparseCsr2cscEx2__retval = hipsparseStatus_t(chipsparse.hipsparseCsr2cscEx2(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <const void *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cscVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,valType.value,copyValues.value,idxBase.value,alg.value,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseCsr2cscEx2__retval,)


@cython.embedsignature(True)
def hipsparseScsr2hyb(object handle, int m, int n, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object hybA, int userEllWidth, object partitionType):
    r"""Convert a sparse CSR matrix into a sparse HYB matrix

    ``hipsparseXcsr2hyb`` converts a CSR matrix into a HYB matrix. It is assumed
    that ``hyb`` has been initialized with hipsparseCreateHybMat().

    Note:
        This function requires a significant amount of storage for the HYB matrix,
        depending on the matrix structure.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Sparse matrix in CSR format
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcsrRowPtr[4] = {0, 3, 5, 8};
       int hcsrColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
       float hcsrVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int nnz       = 8;
       int userEllWidth = 2;
       hipsparseHybPartition_t partitionType = HIPSPARSE_HYB_PARTITION_AUTO;

       int* dcsrRowPtr = nullptr;
       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);

       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       hipsparseHybMat_t hyb;
       hipsparseCreateHybMat(&hyb);

       hipsparseScsr2hyb(handle, m, n, descr, dcsrVal, dcsrRowPtr, dcsrColInd, hyb, userEllWidth, partitionType);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);

       hipsparseDestroyHybMat(hyb);
       hipsparseDestroyMatDescr(descr);

       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        userEllWidth (`~.int`):
            (undocumented)

        partitionType (`~.hipsparseHybPartition_t`):
            (undocumented)
    """
    if not isinstance(partitionType,_hipsparseHybPartition_t__Base):
        raise TypeError("argument 'partitionType' must be of type '_hipsparseHybPartition_t__Base'")
    _hipsparseScsr2hyb__retval = hipsparseStatus_t(chipsparse.hipsparseScsr2hyb(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(hybA)._ptr,userEllWidth,partitionType.value))
    return (_hipsparseScsr2hyb__retval,)


@cython.embedsignature(True)
def hipsparseDcsr2hyb(object handle, int m, int n, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object hybA, int userEllWidth, object partitionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        userEllWidth (`~.int`):
            (undocumented)

        partitionType (`~.hipsparseHybPartition_t`):
            (undocumented)
    """
    if not isinstance(partitionType,_hipsparseHybPartition_t__Base):
        raise TypeError("argument 'partitionType' must be of type '_hipsparseHybPartition_t__Base'")
    _hipsparseDcsr2hyb__retval = hipsparseStatus_t(chipsparse.hipsparseDcsr2hyb(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(hybA)._ptr,userEllWidth,partitionType.value))
    return (_hipsparseDcsr2hyb__retval,)


@cython.embedsignature(True)
def hipsparseCcsr2hyb(object handle, int m, int n, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object hybA, int userEllWidth, object partitionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        userEllWidth (`~.int`):
            (undocumented)

        partitionType (`~.hipsparseHybPartition_t`):
            (undocumented)
    """
    if not isinstance(partitionType,_hipsparseHybPartition_t__Base):
        raise TypeError("argument 'partitionType' must be of type '_hipsparseHybPartition_t__Base'")
    _hipsparseCcsr2hyb__retval = hipsparseStatus_t(chipsparse.hipsparseCcsr2hyb(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(hybA)._ptr,userEllWidth,partitionType.value))
    return (_hipsparseCcsr2hyb__retval,)


@cython.embedsignature(True)
def hipsparseZcsr2hyb(object handle, int m, int n, object descrA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA, object hybA, int userEllWidth, object partitionType):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        userEllWidth (`~.int`):
            (undocumented)

        partitionType (`~.hipsparseHybPartition_t`):
            (undocumented)
    """
    if not isinstance(partitionType,_hipsparseHybPartition_t__Base):
        raise TypeError("argument 'partitionType' must be of type '_hipsparseHybPartition_t__Base'")
    _hipsparseZcsr2hyb__retval = hipsparseStatus_t(chipsparse.hipsparseZcsr2hyb(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(hybA)._ptr,userEllWidth,partitionType.value))
    return (_hipsparseZcsr2hyb__retval,)


@cython.embedsignature(True)
def hipsparseSgebsr2gebsc_bufferSize(object handle, int mb, int nb, int nnzb, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object pBufferSizeInBytes):
    r"""Convert a sparse GEBSR matrix into a sparse GEBSC matrix

    ``hipsparseXgebsr2gebsc_bufferSize`` returns the size of the temporary storage buffer
    required by hipsparseXgebsr2gebsc() and is the first step in converting a sparse matrix
    in GEBSR format to a sparse matrix in GEBSC format. Once the size of the temporary storage
    buffer has been determined, it must be allocated by the user.

    See hipsparseSgebsr2gebsc() for a complete code example.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        bsrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSgebsr2gebsc_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSgebsr2gebsc_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mb,nb,nnzb,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSgebsr2gebsc_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDgebsr2gebsc_bufferSize(object handle, int mb, int nb, int nnzb, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        bsrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDgebsr2gebsc_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDgebsr2gebsc_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mb,nb,nnzb,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDgebsr2gebsc_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCgebsr2gebsc_bufferSize(object handle, int mb, int nb, int nnzb, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        bsrVal (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCgebsr2gebsc_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCgebsr2gebsc_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mb,nb,nnzb,
        float2.fromPyobj(bsrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCgebsr2gebsc_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZgebsr2gebsc_bufferSize(object handle, int mb, int nb, int nnzb, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        bsrVal (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZgebsr2gebsc_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZgebsr2gebsc_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mb,nb,nnzb,
        double2.fromPyobj(bsrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZgebsr2gebsc_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSgebsr2gebsc(object handle, int mb, int nb, int nnzb, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object bscVal, object bscRowInd, object bscColPtr, object copyValues, object idxBase, object temp_buffer):
    r"""Convert a sparse GEBSR matrix into a sparse GEBSC matrix

    ``hipsparseXgebsr2gebsc`` converts a GEBSR matrix into a GEBSC matrix. ``hipsparseXgebsr2gebsc``
    can also be used to convert a GEBSC matrix into a GEBSR matrix. ``copyValues`` decides
    whether ``bscVal`` is being filled during conversion (``HIPSPARSE_ACTION_NUMERIC`` )
    or not (``HIPSPARSE_ACTION_SYMBOLIC`` ).

    ``hipsparseXgebsr2gebsc`` requires extra temporary storage buffer that has to be allocated
    by the user. Storage buffer size can be determined by hipsparseXgebsr2gebsc_bufferSize().

    For example, given the GEBSR matrix:

    .. math::

        \left[
         \begin{array}{c | c}
           \begin{array}{c c}
            1 & 2 \\
            3 & 4 \\
            6 & 0
           \end{array} &
           \begin{array}{c c}
            0 & 2 \\
            0 & 0 \\
            3 & 4
           \end{array} \\
         \hline
           \begin{array}{c c}
            5 & 0 \\
            1 & 2 \\
            3 & 4
           \end{array} &
           \begin{array}{c c}
            6 & 7 \\
            3 & 4 \\
            3 & 4
           \end{array} \\
        \end{array}
       \right]

    represented with the arrays:

    .. math::

       \begin{align}
       \text{bsrRowPtr} &= \begin{bmatrix} 0 & 2 & 4 \end{bmatrix} \\
       \text{bsrColInd} &= \begin{bmatrix} 0 & 1 & 0 & 1 \end{bmatrix} \\
       \text{bsrVal} &= \begin{bmatrix} 1 & 2 & 3 & 4 & 6 & 0 & 0 & 2 & 0 & 0 & 3 & 4 & 5 & 0 & 1 & 2 & 3 & 4 & 6 & 7 & 3 & 4 & 3 & 4 \end{bmatrix}
       \end{align}

    this function converts the matrix to GEBSC format:

    .. math::

       \begin{align}
       \text{bscRowInd} &= \begin{bmatrix} 0 & 1 & 0 & 1 \end{bmatrix} \\
       \text{bscColPtr} &= \begin{bmatrix} 0 & 2 & 4 \end{bmatrix} \\
       \text{bscVal} &= \begin{bmatrix} 1 & 2 & 3 & 4 & 6 & 0 & 5 & 0 & 1 & 2 & 3 & 4 & 0 & 2 & 0 & 0 & 3 & 4 & 6 & 7 & 3 & 4 & 3 & 4 \end{bmatrix}
       \end{align}

    Note:
        The resulting matrix can also be seen as the transpose of the input matrix.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Sparse matrix in BSR format
       //     1 2 | 0 3 | 0 0
       //     0 4 | 5 0 | 0 1
       // A = 6 0 | 0 7 | 8 0
       //     ---------------
       //     0 0 | 3 0 | 2 2
       //     1 0 | 0 0 | 4 3
       //     7 2 | 0 0 | 1 4
       int hbsrRowPtr[3] = {0, 3, 6};
       int hbsrColInd[6] = {0, 1, 2, 0, 1, 2};
       float hbsrVal[36]  = {1.0f, 2.0f, 0.0f, 4.0f, 6.0f, 0.0f,
                              0.0f, 3.0f, 5.0f, 0.0f, 0.0f, 7.0f,
                              0.0f, 0.0f, 0.0f, 1.0f, 8.0f, 0.0f,
                              0.0f, 0.0f, 1.0f, 0.0f, 7.0f, 2.0f,
                              3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f,
                              2.0f, 2.0f, 4.0f, 3.0f, 1.0f, 4.0f};

       int m           = 6;
       int n           = 6;
       int rowBlockDim = 3;
       int colBlockDim = 2;
       int nnzb        = 6;
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;
       hipsparseAction_t    action = HIPSPARSE_ACTION_NUMERIC;
       hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;

       int mb = (m + rowBlockDim - 1) / rowBlockDim;
       int nb = (n + colBlockDim - 1) / colBlockDim;

       int* dbsrRowPtr = nullptr;
       int* dbsrColInd = nullptr;
       float* dbsrVal = nullptr;
       hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
       hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
       hipMalloc((void**)&dbsrVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb);

       hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
       hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
       hipMemcpy(dbsrVal, hbsrVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb, hipMemcpyHostToDevice);

       int* dbscRowInd = nullptr;
       int* dbscColPtr = nullptr;
       float* dbscVal = nullptr;
       hipMalloc((void**)&dbscRowInd, sizeof(int) * nnzb);
       hipMalloc((void**)&dbscColPtr, sizeof(int) * (nb + 1));
       hipMalloc((void**)&dbscVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb);

       size_t bufferSize;
       hipsparseSgebsr2gebsc_bufferSize(handle,
                                        mb,
                                        nb,
                                        nnzb,
                                        dbsrVal,
                                        dbsrRowPtr,
                                        dbsrColInd,
                                        rowBlockDim,
                                        colBlockDim,
                                        &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       hipsparseSgebsr2gebsc(handle,
                             mb,
                             nb,
                             nnzb,
                             dbsrVal,
                             dbsrRowPtr,
                             dbsrColInd,
                             rowBlockDim,
                             colBlockDim,
                             dbscVal,
                             dbscRowInd,
                             dbscColPtr,
                             action,
                             base,
                             dbuffer);

       hipFree(dbsrRowPtr);
       hipFree(dbsrColInd);
       hipFree(dbsrVal);

       hipFree(dbscRowInd);
       hipFree(dbscColPtr);
       hipFree(dbscVal);

       hipFree(dbuffer);

       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        bsrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        bscVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        copyValues (`~.hipsparseAction_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        temp_buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(copyValues,_hipsparseAction_t__Base):
        raise TypeError("argument 'copyValues' must be of type '_hipsparseAction_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseSgebsr2gebsc__retval = hipsparseStatus_t(chipsparse.hipsparseSgebsr2gebsc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mb,nb,nnzb,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        <float *>hip._util.types.Pointer.fromPyobj(bscVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bscRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bscColPtr)._ptr,copyValues.value,idxBase.value,
        <void *>hip._util.types.Pointer.fromPyobj(temp_buffer)._ptr))
    return (_hipsparseSgebsr2gebsc__retval,)


@cython.embedsignature(True)
def hipsparseDgebsr2gebsc(object handle, int mb, int nb, int nnzb, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object bscVal, object bscRowInd, object bscColPtr, object copyValues, object idxBase, object temp_buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        bsrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        bscVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        copyValues (`~.hipsparseAction_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        temp_buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(copyValues,_hipsparseAction_t__Base):
        raise TypeError("argument 'copyValues' must be of type '_hipsparseAction_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseDgebsr2gebsc__retval = hipsparseStatus_t(chipsparse.hipsparseDgebsr2gebsc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mb,nb,nnzb,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        <double *>hip._util.types.Pointer.fromPyobj(bscVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bscRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bscColPtr)._ptr,copyValues.value,idxBase.value,
        <void *>hip._util.types.Pointer.fromPyobj(temp_buffer)._ptr))
    return (_hipsparseDgebsr2gebsc__retval,)


@cython.embedsignature(True)
def hipsparseCgebsr2gebsc(object handle, int mb, int nb, int nnzb, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object bscVal, object bscRowInd, object bscColPtr, object copyValues, object idxBase, object temp_buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        bsrVal (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        bscVal (`~.float2`/`~.object`):
            (undocumented)

        bscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        copyValues (`~.hipsparseAction_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        temp_buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(copyValues,_hipsparseAction_t__Base):
        raise TypeError("argument 'copyValues' must be of type '_hipsparseAction_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseCgebsr2gebsc__retval = hipsparseStatus_t(chipsparse.hipsparseCgebsr2gebsc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mb,nb,nnzb,
        float2.fromPyobj(bsrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        float2.fromPyobj(bscVal).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(bscRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bscColPtr)._ptr,copyValues.value,idxBase.value,
        <void *>hip._util.types.Pointer.fromPyobj(temp_buffer)._ptr))
    return (_hipsparseCgebsr2gebsc__retval,)


@cython.embedsignature(True)
def hipsparseZgebsr2gebsc(object handle, int mb, int nb, int nnzb, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object bscVal, object bscRowInd, object bscColPtr, object copyValues, object idxBase, object temp_buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        bsrVal (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        bscVal (`~.double2`/`~.object`):
            (undocumented)

        bscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        copyValues (`~.hipsparseAction_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        temp_buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(copyValues,_hipsparseAction_t__Base):
        raise TypeError("argument 'copyValues' must be of type '_hipsparseAction_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseZgebsr2gebsc__retval = hipsparseStatus_t(chipsparse.hipsparseZgebsr2gebsc(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,mb,nb,nnzb,
        double2.fromPyobj(bsrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        double2.fromPyobj(bscVal).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(bscRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bscColPtr)._ptr,copyValues.value,idxBase.value,
        <void *>hip._util.types.Pointer.fromPyobj(temp_buffer)._ptr))
    return (_hipsparseZgebsr2gebsc__retval,)


@cython.embedsignature(True)
def hipsparseScsr2gebsr_bufferSize(object handle, object dir, int m, int n, object csr_descr, object csrVal, object csrRowPtr, object csrColInd, int rowBlockDim, int colBlockDim, object pBufferSizeInBytes):
    r"""Convert a sparse CSR matrix into a sparse GEBSR matrix

    ``hipsparseXcsr2gebsr_bufferSize`` returns the size of the temporary buffer that
    is required by ``hipsparseXcsr2gebcsrNnz`` and ``hipsparseXcsr2gebcsr.`` Once the
    temporary buffer size has been determined, it must be allocated by the user prior
    to calling ``hipsparseXcsr2gebcsrNnz`` and ``hipsparseXcsr2gebcsr.``

    See hipsparseScsr2gebsr() for complete code example.

    Note:
        The routine does support asynchronous execution if the pointer mode is set to device.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        csr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseScsr2gebsr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseScsr2gebsr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(csr_descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,rowBlockDim,colBlockDim,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsr2gebsr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDcsr2gebsr_bufferSize(object handle, object dir, int m, int n, object csr_descr, object csrVal, object csrRowPtr, object csrColInd, int rowBlockDim, int colBlockDim, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        csr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseDcsr2gebsr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDcsr2gebsr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(csr_descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,rowBlockDim,colBlockDim,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsr2gebsr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCcsr2gebsr_bufferSize(object handle, object dir, int m, int n, object csr_descr, object csrVal, object csrRowPtr, object csrColInd, int rowBlockDim, int colBlockDim, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        csr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseCcsr2gebsr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCcsr2gebsr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(csr_descr)._ptr,
        float2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,rowBlockDim,colBlockDim,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsr2gebsr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZcsr2gebsr_bufferSize(object handle, object dir, int m, int n, object csr_descr, object csrVal, object csrRowPtr, object csrColInd, int rowBlockDim, int colBlockDim, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        csr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseZcsr2gebsr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZcsr2gebsr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(csr_descr)._ptr,
        double2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,rowBlockDim,colBlockDim,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsr2gebsr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseXcsr2gebsrNnz(object handle, object dir, int m, int n, object csr_descr, object csrRowPtr, object csrColInd, object bsr_descr, object bsrRowPtr, int rowBlockDim, int colBlockDim, object bsrNnzDevhost, object pbuffer):
    r"""This function computes the number of nonzero block columns per row and the total number of nonzero blocks in a sparse
    GEBSR matrix given a sparse CSR matrix as input.

    This is the second step in conveting a CSR matrix to a GEBSR matrix. The user must first call
    ``hipsparseXcsr2gebsr_bufferSize`` to determine the size of the required temporary storage buffer. The user then
    allocates this buffer as well as the ``bsrRowPtr`` array ( size ``mb+1`` ) and passes both to
    ``hipsparseXcsr2gebsrNnz().`` This second step then computes the number of nonzero block columns per row and the
    total number of nonzero blocks.

    In general, when converting a CSR matrix of size ``m`` x ``n`` to a GEBSR matrix, the resulting GEBSR matrix will have size
    ``mb`` x ``nb`` where ``mb`` and ``nb`` equal:

    .. math::

       \begin{align}
       \text{mb} &= \text{(m - 1) / rowBlockDim + 1} \\
       \text{nb} &= \text{(n - 1) / colBlockDim + 1}
       \end{align}

    For example given a matrix:

    .. math::

       \begin{bmatrix}
       1 & 0 & 0 & 2 & 4 & 0 \\
       3 & 4 & 0 & 0 & 5 & 1 \\
       5 & 0 & 6 & 7 & 6 & 2
       \end{bmatrix}

    represented in CSR format with the arrays:

    .. math::

       \begin{align}
       \text{csrRowPtr} &= \begin{bmatrix} 0 & 3 & 7 & 12 \end{bmatrix} \\
       \text{csrColInd} &= \begin{bmatrix} 0 & 3 & 4 & 0 & 1 & 4 & 5 & 0 & 2 & 3 & 4 & 5 \end{bmatrix} \\
       \text{csrVal} &= \begin{bmatrix} 1 & 2 & 4 & 3 & 4 & 5 & 1 & 5 & 6 & 7 & 6 & 2 \end{bmatrix}
       \end{align}

    the ``bsrRowPtr`` array and total nonzero block count will be filled with:

    .. math::

       \begin{align}
       \text{bsrRowPtr} &= \begin{bmatrix} 0 & 3 \end{bmatrix} \\
       \text{*bsrNnzDevhost} &= 3
       \end{align}

    Note:
        As indicated, bsrNnzDevhost can point either to host or device memory. This is controlled
        by setting the pointer mode. See hipsparseSetPointerMode().

    It may be the case that ``rowBlockDim`` does not divide evenly into ``m`` and/or that ``colBlockDim`` does not divide
    evenly into ``n.`` In these cases, the CSR matrix is expanded in size in order to fit full GEBSR blocks. For example,
    using the original CSR matrix but this time with ``rowBlockDim=2`` and ``colBlockDim=3,`` the function
    ``hipsparseXcsr2gebsrNnz`` computes the GEBSR row pointer array and total number of non-zero blocks for the GEBSR matrix:

    .. math::

        \left[
         \begin{array}{c | c}
           \begin{array}{c c c}
            1 & 0 & 0 \\
            3 & 4 & 0
           \end{array} &
           \begin{array}{c c c}
            2 & 4 & 0 \\
            0 & 5 & 1
           \end{array} \\
         \hline
           \begin{array}{c c c}
            5 & 0 & 6 \\
            0 & 0 & 0
           \end{array} &
           \begin{array}{c c c}
            7 & 6 & 2 \\
            0 & 0 & 0
           \end{array}
        \end{array}
       \right]

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        csr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        bsrNnzDevhost (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pbuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseXcsr2gebsrNnz__retval = hipsparseStatus_t(chipsparse.hipsparseXcsr2gebsrNnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(csr_descr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(bsr_descr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,rowBlockDim,colBlockDim,
        <int *>hip._util.types.Pointer.fromPyobj(bsrNnzDevhost)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(pbuffer)._ptr))
    return (_hipsparseXcsr2gebsrNnz__retval,)


@cython.embedsignature(True)
def hipsparseScsr2gebsr(object handle, object dir, int m, int n, object csr_descr, object csrVal, object csrRowPtr, object csrColInd, object bsr_descr, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object pbuffer):
    r"""Convert a sparse CSR matrix into a sparse GEBSR matrix

    ``hipsparseXcsr2gebsr`` converts a CSR matrix into a GEBSR matrix. It is assumed,
    that ``bsrVal,`` ``bsrColInd`` and ``bsrRowPtr`` are allocated. Allocation size
    for ``bsrRowPtr`` is computed as ``mb+1`` where ``mb`` is the number of block rows in
    the GEBSR matrix. The number of nonzero blocks in the resulting GEBSR matrix
    is computed using ``hipsparseXcsr2gebsrNnz`` which also fills in ``bsrRowPtr.``

    In more detail, ``hipsparseXcsr2gebsr`` is the third and final step on the conversion from CSR to GEBSR.
    The user first determines the size of the required user allocated temporary storage buffer using
    ``hipsparseXcsr2gebsr_bufferSize.`` The user then allocates this buffer as well as the row pointer array
    ``bsrRowPtr`` with size ``mb+1,`` where ``mb`` is the number of block rows in the GEBSR matrix and ``nb`` is
    the number of block columns in GEBSR matrix:

    .. math::

       \begin{align}
       \text{mb} &= \text{(m - 1) / rowBlockDim + 1} \\
       \text{nb} &= \text{(n - 1) / colBlockDim + 1}
       \end{align}

    Both the temporary storage buffer and the GEBSR row pointer array are then passed to ``hipsparseXcsr2gebsrNnz``
    which fills the GEBSR row pointer array ``bsrRowPtr`` and also computes the number of nonzero blocks,
    ``bsr_nnz,`` that will exist in the GEBSR matrix. The user then allocates both the GEBSR column indices array
    ``bsrColInd`` with size ``bsr_nnz`` as well as the GEBSR values array ``bsrVal`` with size
    ``bsr_nnz*rowBlockDim*colBlockDim.`` Finally, with all arrays allocated, the conversion is completed by calling
    ``hipsparseXcsr2gebsr.``

    For example, assuming the matrix:

    .. math::

       \begin{bmatrix}
       1 & 0 & 0 & 2 & 4 & 0 \\
       3 & 4 & 0 & 0 & 5 & 1 \\
       5 & 0 & 6 & 7 & 6 & 2
       \end{bmatrix}

    represented in CSR format with the arrays:

    .. math::

       \begin{align}
       \text{csrRowPtr} &= \begin{bmatrix} 0 & 3 & 7 & 12 \end{bmatrix} \\
       \text{csrColInd} &= \begin{bmatrix} 0 & 3 & 4 & 0 & 1 & 4 & 5 & 0 & 2 & 3 & 4 & 5 \end{bmatrix} \\
       \text{csrVal} &= \begin{bmatrix} 1 & 2 & 4 & 3 & 4 & 5 & 1 & 5 & 6 & 7 & 6 & 2 \end{bmatrix}
       \end{align}

    then using ``rowBlockDim=3`` and ``colBlockDim=2,`` the final GEBSR matrix is:

    .. math::

        \left[
         \begin{array}{c | c}
           \begin{array}{c c}
            1 & 0 \\
            3 & 4 \\
            3 & 0
           \end{array} &
           \begin{array}{c c}
            0 & 2 \\
            0 & 0 \\
            6 & 7
           \end{array} &
           \begin{array}{c c}
            4 & 0 \\
            5 & 1 \\
            6 & 2
           \end{array}
        \end{array}
       \right]

    and is represented with the arrays:

    .. math::

       \begin{align}
       \text{bsrRowPtr} &= \begin{bmatrix} 0 & 3 \end{bmatrix} \\
       \text{bsrColInd} &= \begin{bmatrix} 0 & 1 & 2 \end{bmatrix} \\
       \text{bsrVal} &= \begin{bmatrix} 1 & 0 & 3 & 4 & 3 & 0 & 0 & 2 & 0 & 0 & 6 & 7 & 4 & 0 & 5 & 1 & 6 & 2 \end{bmatrix}
       \end{align}

    The above example assumes that the blocks are row ordered. If instead the blocks are column ordered, the ``bsrVal`` arrays
    becomes:

    .. math::

       \begin{align}
       \text{bsrVal} &= \begin{bmatrix} 1 & 3 & 3 & 0 & 4 & 0 & 0 & 0 & 6 & 2 & 0 & 7 & 4 & 5 & 6 & 0 & 1 & 2 \end{bmatrix}
       \end{align}

    The block order direction is determined by ``dir.``

    It may be the case that ``rowBlockDim`` does not divide evenly into ``m`` and/or that ``colBlockDim`` does not divide
    evenly into ``n.`` In these cases, the CSR matrix is expanded in size in order to fit full GEBSR blocks. For example,
    using the original CSR matrix but this time with ``rowBlockDim=2`` and ``colBlockDim=3,`` the resulting GEBSR matrix
    would looks like:

    .. math::

        \left[
         \begin{array}{c | c}
           \begin{array}{c c c}
            1 & 0 & 0 \\
            3 & 4 & 0
           \end{array} &
           \begin{array}{c c c}
            2 & 4 & 0 \\
            0 & 5 & 1
           \end{array} \\
         \hline
           \begin{array}{c c c}
            5 & 0 & 6 \\
            0 & 0 & 0
           \end{array} &
           \begin{array}{c c c}
            7 & 6 & 2 \\
            0 & 0 & 0
           \end{array}
        \end{array}
       \right]

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t csr_descr;
       hipsparseCreateMatDescr(&csr_descr);

       hipsparseMatDescr_t bsr_descr;
       hipsparseCreateMatDescr(&bsr_descr);

       // Sparse matrix in CSR format
       //     1 2 0 3 0 0
       //     0 4 5 0 0 1
       // A = 6 0 0 7 8 0
       //     0 0 3 0 2 2
       //     1 0 0 0 4 3
       //     7 2 0 0 1 4
       int hcsrRowPtr[7] = {0, 3, 6, 9, 12, 15, 19};
       int hcsrColInd[19] = {0, 1, 3, 1, 2, 5, 0, 3, 4, 2, 4, 5, 0, 4, 5, 0, 1, 4, 5};
       float hcsrVal[19]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 1.0f, 6.0f, 7.0f, 8.0f, 3.0f, 2.0f, 2.0f,
                              1.0f, 4.0f, 3.0f, 7.0f, 2.0f, 1.0f, 4.0f};

       int m           = 6;
       int n           = 6;
       int nnz         = 19;
       int rowBlockDim = 3;
       int colBlockDim = 2;
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;
       hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;

       int mb = (m + rowBlockDim - 1) / rowBlockDim;
       int nb = (n + colBlockDim - 1) / colBlockDim;

       int* dcsrRowPtr = nullptr;
       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);

       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       int* dbsrRowPtr = nullptr;
       hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));

       size_t bufferSize;
       hipsparseScsr2gebsr_bufferSize(handle,
                                      dir,
                                      m,
                                      n,
                                      csr_descr,
                                      dcsrVal,
                                      dcsrRowPtr,
                                      dcsrColInd,
                                      rowBlockDim,
                                      colBlockDim,
                                      &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       int nnzb;
       hipsparseXcsr2gebsrNnz(handle,
                              dir,
                              m,
                              n,
                              csr_descr,
                              dcsrRowPtr,
                              dcsrColInd,
                              bsr_descr,
                              dbsrRowPtr,
                              rowBlockDim,
                              colBlockDim,
                              &nnzb,
                              dbuffer);

       int* dbsrColInd = nullptr;
       float* dbsrVal = nullptr;
       hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
       hipMalloc((void**)&dbsrVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb);

       hipsparseScsr2gebsr(handle,
                           dir,
                           m,
                           n,
                           csr_descr,
                           dcsrVal,
                           dcsrRowPtr,
                           dcsrColInd,
                           bsr_descr,
                           dbsrVal,
                           dbsrRowPtr,
                           dbsrColInd,
                           rowBlockDim,
                           colBlockDim,
                           dbuffer);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);

       hipFree(dbsrRowPtr);
       hipFree(dbsrColInd);
       hipFree(dbsrVal);

       hipFree(dbuffer);

       hipsparseDestroyMatDescr(csr_descr);
       hipsparseDestroyMatDescr(bsr_descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        csr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pbuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseScsr2gebsr__retval = hipsparseStatus_t(chipsparse.hipsparseScsr2gebsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(csr_descr)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(bsr_descr)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        <void *>hip._util.types.Pointer.fromPyobj(pbuffer)._ptr))
    return (_hipsparseScsr2gebsr__retval,)


@cython.embedsignature(True)
def hipsparseDcsr2gebsr(object handle, object dir, int m, int n, object csr_descr, object csrVal, object csrRowPtr, object csrColInd, object bsr_descr, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object pbuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        csr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pbuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseDcsr2gebsr__retval = hipsparseStatus_t(chipsparse.hipsparseDcsr2gebsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(csr_descr)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(bsr_descr)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrVal)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        <void *>hip._util.types.Pointer.fromPyobj(pbuffer)._ptr))
    return (_hipsparseDcsr2gebsr__retval,)


@cython.embedsignature(True)
def hipsparseCcsr2gebsr(object handle, object dir, int m, int n, object csr_descr, object csrVal, object csrRowPtr, object csrColInd, object bsr_descr, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object pbuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        csr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrVal (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pbuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseCcsr2gebsr__retval = hipsparseStatus_t(chipsparse.hipsparseCcsr2gebsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(csr_descr)._ptr,
        float2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(bsr_descr)._ptr,
        float2.fromPyobj(bsrVal).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        <void *>hip._util.types.Pointer.fromPyobj(pbuffer)._ptr))
    return (_hipsparseCcsr2gebsr__retval,)


@cython.embedsignature(True)
def hipsparseZcsr2gebsr(object handle, object dir, int m, int n, object csr_descr, object csrVal, object csrRowPtr, object csrColInd, object bsr_descr, object bsrVal, object bsrRowPtr, object bsrColInd, int rowBlockDim, int colBlockDim, object pbuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dir (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        csr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsr_descr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrVal (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        pbuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dir,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dir' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseZcsr2gebsr__retval = hipsparseStatus_t(chipsparse.hipsparseZcsr2gebsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dir.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(csr_descr)._ptr,
        double2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(bsr_descr)._ptr,
        double2.fromPyobj(bsrVal).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColInd)._ptr,rowBlockDim,colBlockDim,
        <void *>hip._util.types.Pointer.fromPyobj(pbuffer)._ptr))
    return (_hipsparseZcsr2gebsr__retval,)


@cython.embedsignature(True)
def hipsparseScsr2bsr(object handle, object dirA, int m, int n, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, int blockDim, object descrC, object bsrValC, object bsrRowPtrC, object bsrColIndC):
    r"""Convert a sparse CSR matrix into a sparse BSR matrix

    ``hipsparseXcsr2bsr`` completes the conversion of a CSR matrix into a BSR matrix.
    It is assumed, that ``bsrValC,`` ``bsrColIndC`` and ``bsrRowPtrC`` are allocated. The
    allocation size for ``bsrRowPtr`` is computed as ``mb+1`` where ``mb`` is the number of
    block rows in the BSR matrix defined as:

    .. math::

       \begin{align}
       \text{mb} &= \text{(m - 1) / blockDim + 1}
       \end{align}

    The allocation size for ``bsrColIndC,`` i.e. ``bsrNnzb,`` is computed using
    ``hipsparseXcsr2bsrNnz()`` which also fills the ``bsrRowPtrC`` array. The allocation size
    for ``bsrValC`` is then equal to:

    .. math::

       \text{bsrNnzb * blockDim * blockDim}

    For example, given the CSR matrix:

    .. math::

       \begin{bmatrix}
       1 & 0 & 0 & 2 \\
       3 & 4 & 0 & 0 \\
       5 & 0 & 6 & 7 \\
       1 & 2 & 3 & 4
       \end{bmatrix}

    The resulting BSR matrix using block dimension 2 would look like:

    .. math::

        \left[
         \begin{array}{c | c}
           \begin{array}{c c}
            1 & 0 \\
            3 & 4
           \end{array} &
           \begin{array}{c c}
            0 & 2 \\
            0 & 0
           \end{array} \\
         \hline
           \begin{array}{c c}
            5 & 0 \\
            1 & 2
           \end{array} &
           \begin{array}{c c}
            6 & 7 \\
            3 & 4
           \end{array} \\
        \end{array}
       \right]

    The call to ``hipsparseXcsr2bsrNnz`` results in the BSR row pointer array:

    .. math::

       \begin{align}
       \text{bsrRowPtrC} &= \begin{bmatrix} 0 & 2 & 4 \end{bmatrix} \\
       \end{align}

    and the call to ``hipsparseXcsr2bsr`` completes the conversion resulting in the BSR column indices and values arrays:

    .. math::

       \begin{align}
       \text{bsrColIndC} &= \begin{bmatrix} 0 & 1 & 0 & 1 \end{bmatrix} \\
       \text{bsrValC} &= \begin{bmatrix} 1 & 0 & 3 & 4 & 0 & 2 & 0 & 0 & 5 & 0 & 1 & 2 & 6 & 7 & 3 & 4 \end{bmatrix} \\
       \end{align}

    The ``dirA`` parameter determines the order of the BSR block values. The example above uses row order. Using column ordering
    would result instead in the BSR values array:

    .. math::

       \text{bsrValC} &= \begin{bmatrix} 1 & 3 & 0 & 4 & 0 & 0 & 2 & 0 & 5 & 1 & 0 & 2 & 6 & 3 & 7 & 4 \end{bmatrix} \\

    Note:
        ``hipsparseXcsr2bsr`` requires extra temporary storage that is allocated internally if
        ``blockDim>16``

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Matrix descriptor
       hipsparseMatDescr_t csr_descr;
       hipsparseCreateMatDescr(&csr_descr);

       hipsparseMatDescr_t bsr_descr;
       hipsparseCreateMatDescr(&bsr_descr);

       // Sparse matrix in CSR format
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcsrRowPtr[4] = {0, 3, 5, 8};
       int hcsrColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
       float hcsrVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int nnz       = 8;
       int blockDim  = 3;
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;

       int mb = (m + blockDim - 1) / blockDim;
       int nb = (n + blockDim - 1) / blockDim;

       int* dcsrRowPtr = nullptr;
       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);

       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       int* dbsrRowPtr = nullptr;
       hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));

       int nnzb;
       hipsparseXcsr2bsrNnz(handle, dir, m, n, csr_descr, dcsrRowPtr, dcsrColInd, blockDim, bsr_descr, dbsrRowPtr, &nnzb);

       int* dbsrColInd = nullptr;
       float* dbsrVal = nullptr;
       hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
       hipMalloc((void**)&dbsrVal, sizeof(float) * blockDim * blockDim * nnzb);

       hipsparseScsr2bsr(handle, dir, m, n, csr_descr, dcsrVal, dcsrRowPtr, dcsrColInd, blockDim, bsr_descr, dbsrVal, dbsrRowPtr, dbsrColInd);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);

       hipFree(dbsrRowPtr);
       hipFree(dbsrColInd);
       hipFree(dbsrVal);

       hipsparseDestroyMatDescr(csr_descr);
       hipsparseDestroyMatDescr(bsr_descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseScsr2bsr__retval = hipsparseStatus_t(chipsparse.hipsparseScsr2bsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,blockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColIndC)._ptr))
    return (_hipsparseScsr2bsr__retval,)


@cython.embedsignature(True)
def hipsparseDcsr2bsr(object handle, object dirA, int m, int n, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, int blockDim, object descrC, object bsrValC, object bsrRowPtrC, object bsrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseDcsr2bsr__retval = hipsparseStatus_t(chipsparse.hipsparseDcsr2bsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,blockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColIndC)._ptr))
    return (_hipsparseDcsr2bsr__retval,)


@cython.embedsignature(True)
def hipsparseCcsr2bsr(object handle, object dirA, int m, int n, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, int blockDim, object descrC, object bsrValC, object bsrRowPtrC, object bsrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValC (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseCcsr2bsr__retval = hipsparseStatus_t(chipsparse.hipsparseCcsr2bsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,blockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        float2.fromPyobj(bsrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColIndC)._ptr))
    return (_hipsparseCcsr2bsr__retval,)


@cython.embedsignature(True)
def hipsparseZcsr2bsr(object handle, object dirA, int m, int n, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, int blockDim, object descrC, object bsrValC, object bsrRowPtrC, object bsrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValC (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseZcsr2bsr__retval = hipsparseStatus_t(chipsparse.hipsparseZcsr2bsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,blockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        double2.fromPyobj(bsrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColIndC)._ptr))
    return (_hipsparseZcsr2bsr__retval,)


@cython.embedsignature(True)
def hipsparseSbsr2csr(object handle, object dirA, int mb, int nb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""Convert a sparse BSR matrix into a sparse CSR matrix

    ``hipsparseXbsr2csr`` converts a BSR matrix into a CSR matrix. It is assumed,
    that ``csrValC,`` ``csrColIndC`` and ``csrRowPtrC`` are allocated. Allocation size
    for ``csrRowPtrC`` is computed by the number of block rows multiplied by the block
    dimension plus one. Allocation for ``csrValC`` and ``csrColInd`` is computed by the
    the number of blocks in the BSR matrix multiplied by the block dimension squared.

    For example, given the BSR matrix using block dimension 2:

    .. math::

        \left[
         \begin{array}{c | c}
           \begin{array}{c c}
            1 & 0 \\
            3 & 4
           \end{array} &
           \begin{array}{c c}
            0 & 2 \\
            0 & 0
           \end{array} \\
         \hline
           \begin{array}{c c}
            5 & 0 \\
            1 & 2
           \end{array} &
           \begin{array}{c c}
            6 & 7 \\
            3 & 4
           \end{array} \\
        \end{array}
       \right]

    The resulting CSR matrix row pointer, column indices, and values arrays are:

    .. math::

       \begin{align}
       \text{csrRowPtrC} &= \begin{bmatrix} 0 & 4 & 8 & 12 & 16 \end{bmatrix} \\
       \text{csrColIndC} &= \begin{bmatrix} 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 \end{bmatrix} \\
       \text{csrValC} &= \begin{bmatrix} 1 & 0 & 0 & 2 & 3 & 4 & 0 & 0 & 5 & 0 & 6 & 7 & 1 & 2 & 3 & 4 \end{bmatrix} \\
       \end{align}

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t csr_descr;
       hipsparseCreateMatDescr(&csr_descr);

       hipsparseMatDescr_t bsr_descr;
       hipsparseCreateMatDescr(&bsr_descr);

       // Sparse matrix in BSR format
       //     1 2 | 0 3 | 0 0
       //     0 4 | 5 0 | 0 1
       //     ---------------
       // A = 6 0 | 0 7 | 8 0
       //     0 0 | 3 0 | 2 2
       //     ---------------
       //     1 0 | 0 0 | 4 3
       //     7 2 | 0 0 | 1 4
       int hbsrRowPtr[4] = {0, 3, 6, 8};
       int hbsrColInd[8] = {0, 1, 2, 0, 1, 2, 0, 2};
       float hbsrVal[32]  = {1.0f, 2.0f, 0.0f, 4.0f,
                               0.0f, 3.0f, 5.0f, 0.0f,
                               0.0f, 0.0f, 0.0f, 1.0f,
                               6.0f, 0.0f, 0.0f, 0.0f,
                               0.0f, 7.0f, 3.0f, 0.0f,
                               8.0f, 0.0f, 2.0f, 2.0f,
                               1.0f, 0.0f, 7.0f, 2.0f,
                               4.0f, 3.0f, 1.0f, 4.0f};

       int m        = 6;
       int n        = 6;
       int nnz      = 32;
       int mb       = 3;
       int nb       = 3;
       int nnzb     = 8;
       int blockDim = 2;
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;

       int* dbsrRowPtr = nullptr;
       int* dbsrColInd = nullptr;
       float* dbsrVal = nullptr;
       hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
       hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
       hipMalloc((void**)&dbsrVal, sizeof(float) * blockDim * blockDim * nnzb);

       hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
       hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
       hipMemcpy(dbsrVal, hbsrVal, sizeof(float) * blockDim * blockDim * nnzb, hipMemcpyHostToDevice);

       int* dcsrRowPtr = nullptr;
       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);

       hipsparseSbsr2csr(handle,
                         dir,
                         mb,
                         nb,
                         bsr_descr,
                         dbsrVal,
                         dbsrRowPtr,
                         dbsrColInd,
                         blockDim,
                         csr_descr,
                         dcsrVal,
                         dcsrRowPtr,
                         dcsrColInd);

       hipFree(dbsrRowPtr);
       hipFree(dbsrColInd);
       hipFree(dbsrVal);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);

       hipsparseDestroyMatDescr(csr_descr);
       hipsparseDestroyMatDescr(bsr_descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseSbsr2csr__retval = hipsparseStatus_t(chipsparse.hipsparseSbsr2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseSbsr2csr__retval,)


@cython.embedsignature(True)
def hipsparseDbsr2csr(object handle, object dirA, int mb, int nb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseDbsr2csr__retval = hipsparseStatus_t(chipsparse.hipsparseDbsr2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseDbsr2csr__retval,)


@cython.embedsignature(True)
def hipsparseCbsr2csr(object handle, object dirA, int mb, int nb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseCbsr2csr__retval = hipsparseStatus_t(chipsparse.hipsparseCbsr2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        float2.fromPyobj(csrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseCbsr2csr__retval,)


@cython.embedsignature(True)
def hipsparseZbsr2csr(object handle, object dirA, int mb, int nb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int blockDim, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        blockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseZbsr2csr__retval = hipsparseStatus_t(chipsparse.hipsparseZbsr2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,blockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        double2.fromPyobj(csrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseZbsr2csr__retval,)


@cython.embedsignature(True)
def hipsparseSgebsr2csr(object handle, object dirA, int mb, int nb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDim, int colBlockDim, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""Convert a sparse GEBSR matrix into a sparse CSR matrix

    ``hipsparseXgebsr2csr`` converts a GEBSR matrix into a CSR matrix. It is assumed,
    that ``csrValC,`` ``csrColIndC`` and ``csrRowPtrC`` are already allocated prior to
    calling ``hipsparseXgebsr2csr.`` Allocation size for ``csrRowPtrC`` equals
    ``m+1`` where:

    .. math::

       \begin{align}
       \text{m} &= \text{mb * rowBlockDim} \\
       \text{n} &= \text{nb * colBlockDim}
       \end{align}

    Allocation size for ``csrValC`` and ``csrColIndC`` is computed by the the number of blocks in the GEBSR
    matrix, ``nnzb,`` multiplied by the product of the block dimensions, i.e. ``nnz=nnzb*rocBlockDim*colBlockDim.``

    For example, given the GEBSR matrix:

    .. math::

        \left[
         \begin{array}{c | c | c}
           \begin{array}{c c}
            6 & 2 \\
            1 & 4 \\
            5 & 4
           \end{array} &
           \begin{array}{c c}
            0 & 3 \\
            5 & 0 \\
            0 & 7
           \end{array} &
           \begin{array}{c c}
            0 & 0 \\
            0 & 0 \\
            0 & 0
           \end{array} \\
         \hline
           \begin{array}{c c}
            0 & 0 \\
            0 & 0 \\
            0 & 0
           \end{array} &
           \begin{array}{c c}
            3 & 0 \\
            0 & 0 \\
            0 & 7
           \end{array} &
           \begin{array}{c c}
            2 & 2 \\
            4 & 3 \\
            1 & 4
           \end{array} \\
        \end{array}
       \right]

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t csr_descr;
       hipsparseCreateMatDescr(&csr_descr);

       hipsparseMatDescr_t bsr_descr;
       hipsparseCreateMatDescr(&bsr_descr);

       // Sparse matrix in GEBSR format
       //     1 2 | 0 3 | 0 0
       //     0 4 | 5 0 | 0 1
       // A = 6 0 | 0 7 | 8 0
       //     ---------------
       //     0 0 | 3 0 | 2 2
       //     1 0 | 0 0 | 4 3
       //     7 2 | 0 0 | 1 4
       int hbsrRowPtr[3] = {0, 3, 6};
       int hbsrColInd[6] = {0, 1, 2, 0, 1, 2};
       float hbsrVal[36]  = {1.0f, 2.0f, 0.0f, 4.0f, 6.0f, 0.0f,
                              0.0f, 3.0f, 5.0f, 0.0f, 0.0f, 7.0f,
                              0.0f, 0.0f, 0.0f, 1.0f, 8.0f, 0.0f,
                              0.0f, 0.0f, 1.0f, 0.0f, 7.0f, 2.0f,
                              3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f,
                              2.0f, 2.0f, 4.0f, 3.0f, 1.0f, 4.0f};

       int m        = 6;
       int n        = 6;
       int nnz      = 36;
       int mb       = 2;
       int nb       = 3;
       int nnzb     = 6;
       int rowBlockDim = 3;
       int colBlockDim = 2;
       hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;

       int* dbsrRowPtr = nullptr;
       int* dbsrColInd = nullptr;
       float* dbsrVal = nullptr;
       hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
       hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
       hipMalloc((void**)&dbsrVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb);

       hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
       hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
       hipMemcpy(dbsrVal, hbsrVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb, hipMemcpyHostToDevice);

       int* dcsrRowPtr = nullptr;
       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);

       hipsparseSgebsr2csr(handle,
                           dir,
                           mb,
                           nb,
                           bsr_descr,
                           dbsrVal,
                           dbsrRowPtr,
                           dbsrColInd,
                           rowBlockDim,
                           colBlockDim,
                           csr_descr,
                           dcsrVal,
                           dcsrRowPtr,
                           dcsrColInd);

       hipFree(dbsrRowPtr);
       hipFree(dbsrColInd);
       hipFree(dbsrVal);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);

       hipsparseDestroyMatDescr(csr_descr);
       hipsparseDestroyMatDescr(bsr_descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseSgebsr2csr__retval = hipsparseStatus_t(chipsparse.hipsparseSgebsr2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDim,colBlockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseSgebsr2csr__retval,)


@cython.embedsignature(True)
def hipsparseDgebsr2csr(object handle, object dirA, int mb, int nb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDim, int colBlockDim, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseDgebsr2csr__retval = hipsparseStatus_t(chipsparse.hipsparseDgebsr2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDim,colBlockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseDgebsr2csr__retval,)


@cython.embedsignature(True)
def hipsparseCgebsr2csr(object handle, object dirA, int mb, int nb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDim, int colBlockDim, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseCgebsr2csr__retval = hipsparseStatus_t(chipsparse.hipsparseCgebsr2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDim,colBlockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        float2.fromPyobj(csrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseCgebsr2csr__retval,)


@cython.embedsignature(True)
def hipsparseZgebsr2csr(object handle, object dirA, int mb, int nb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDim, int colBlockDim, object descrC, object csrValC, object csrRowPtrC, object csrColIndC):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDim (`~.int`):
            (undocumented)

        colBlockDim (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseZgebsr2csr__retval = hipsparseStatus_t(chipsparse.hipsparseZgebsr2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDim,colBlockDim,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        double2.fromPyobj(csrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr))
    return (_hipsparseZgebsr2csr__retval,)


@cython.embedsignature(True)
def hipsparseScsr2csr_compress(object handle, int m, int n, object descrA, object csrValA, object csrColIndA, object csrRowPtrA, int nnzA, object nnzPerRow, object csrValC, object csrColIndC, object csrRowPtrC, float tol):
    r"""Convert a sparse CSR matrix into a compressed sparse CSR matrix

    ``hipsparseXcsr2csr_compress`` converts a CSR matrix into a compressed CSR matrix by
    removing entries in the input CSR matrix that are below a non-negative threshold ``tol:``

    .. math::

       C(i,j) = A(i, j) \text{  if |A(i, j)| > tol}

    Note:
        In the case of complex matrices only the magnitude of the real part of ``tol`` is used.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Matrix descriptor
       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Sparse matrix in CSR format
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcsrRowPtrA[4] = {0, 3, 5, 8};
       int hcsrColIndA[8] = {0, 1, 3, 1, 2, 0, 3, 4};
       float hcsrValA[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};

       int m    = 3;
       int n    = 5;
       int nnzA = 8;

       float tol = 5.9f;

       int* dcsrRowPtrA = nullptr;
       int* dcsrColIndA = nullptr;
       float* dcsrValA = nullptr;
       hipMalloc((void**)&dcsrRowPtrA, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColIndA, sizeof(int) * nnzA);
       hipMalloc((void**)&dcsrValA, sizeof(float) * nnzA);

       hipMemcpy(dcsrRowPtrA, hcsrRowPtrA, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColIndA, hcsrColIndA, sizeof(int) * nnzA, hipMemcpyHostToDevice);
       hipMemcpy(dcsrValA, hcsrValA, sizeof(float) * nnzA, hipMemcpyHostToDevice);

       // Allocate memory for the nnz_per_row array
       int* dnnz_per_row;
       hipMalloc((void**)&dnnz_per_row, sizeof(int) * m);

       // Call snnz_compress() which fills in nnz_per_row array and finds the number
       // of entries that will be in the compressed CSR matrix
       int nnzC;
       hipsparseSnnz_compress(handle, m, descr, dcsrValA, dcsrRowPtrA, dnnz_per_row, &nnzC, tol);

       int* dcsrRowPtrC = nullptr;
       int* dcsrColIndC = nullptr;
       float* dcsrValC = nullptr;
       hipMalloc((void**)&dcsrRowPtrC, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColIndC, sizeof(int) * nnzC);
       hipMalloc((void**)&dcsrValC, sizeof(float) * nnzC);

       hipsparseScsr2csr_compress(handle,
                                  m,
                                  n,
                                  descr,
                                  dcsrValA,
                                  dcsrColIndA,
                                  dcsrRowPtrA,
                                  nnzA,
                                  dnnz_per_row,
                                  dcsrValC,
                                  dcsrColIndC,
                                  dcsrRowPtrC,
                                  tol);

       hipFree(dcsrRowPtrA);
       hipFree(dcsrColIndA);
       hipFree(dcsrValA);

       hipFree(dcsrRowPtrC);
       hipFree(dcsrColIndC);
       hipFree(dcsrValC);

       hipFree(dnnz_per_row);

       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        nnzPerRow (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        tol (`~.float`/`~.int`):
            (undocumented)
    """
    _hipsparseScsr2csr_compress__retval = hipsparseStatus_t(chipsparse.hipsparseScsr2csr_compress(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerRow)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,tol))
    return (_hipsparseScsr2csr_compress__retval,)


@cython.embedsignature(True)
def hipsparseDcsr2csr_compress(object handle, int m, int n, object descrA, object csrValA, object csrColIndA, object csrRowPtrA, int nnzA, object nnzPerRow, object csrValC, object csrColIndC, object csrRowPtrC, double tol):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        nnzPerRow (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        tol (`~.float`/`~.int`):
            (undocumented)
    """
    _hipsparseDcsr2csr_compress__retval = hipsparseStatus_t(chipsparse.hipsparseDcsr2csr_compress(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerRow)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,tol))
    return (_hipsparseDcsr2csr_compress__retval,)


@cython.embedsignature(True)
def hipsparseCcsr2csr_compress(object handle, int m, int n, object descrA, object csrValA, object csrColIndA, object csrRowPtrA, int nnzA, object nnzPerRow, object csrValC, object csrColIndC, object csrRowPtrC, object tol):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.float2`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        nnzPerRow (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.float2`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        tol (`~.float2`):
            (undocumented)
    """
    _hipsparseCcsr2csr_compress__retval = hipsparseStatus_t(chipsparse.hipsparseCcsr2csr_compress(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerRow)._ptr,
        float2.fromPyobj(csrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        float2.fromPyobj(tol).getElementPtr()[0]))
    return (_hipsparseCcsr2csr_compress__retval,)


@cython.embedsignature(True)
def hipsparseZcsr2csr_compress(object handle, int m, int n, object descrA, object csrValA, object csrColIndA, object csrRowPtrA, int nnzA, object nnzPerRow, object csrValC, object csrColIndC, object csrRowPtrC, object tol):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.double2`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        nnzPerRow (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.double2`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        tol (`~.double2`):
            (undocumented)
    """
    _hipsparseZcsr2csr_compress__retval = hipsparseStatus_t(chipsparse.hipsparseZcsr2csr_compress(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,nnzA,
        <const int *>hip._util.types.Pointer.fromPyobj(nnzPerRow)._ptr,
        double2.fromPyobj(csrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        double2.fromPyobj(tol).getElementPtr()[0]))
    return (_hipsparseZcsr2csr_compress__retval,)


@cython.embedsignature(True)
def hipsparseSpruneCsr2csr_bufferSize(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object threshold, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object pBufferSizeInBytes):
    r"""Convert and prune sparse CSR matrix into a sparse CSR matrix

    ``hipsparseXpruneCsr2csr_bufferSize`` returns the size of the temporary buffer that
    is required by ``hipsparseXpruneCsr2csrNnz`` and hipsparseXpruneCsr2csr. The
    temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneCsr2csr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneCsr2csr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpruneCsr2csr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDpruneCsr2csr_bufferSize(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object threshold, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneCsr2csr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneCsr2csr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDpruneCsr2csr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSpruneCsr2csr_bufferSizeExt(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object threshold, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object pBufferSizeInBytes):
    r"""Convert and prune sparse CSR matrix into a sparse CSR matrix

    ``hipsparseXpruneCsr2csr_bufferSizeExt`` returns the size of the temporary buffer that
    is required by ``hipsparseXpruneCsr2csrNnz`` and hipsparseXpruneCsr2csr. The
    temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneCsr2csr_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneCsr2csr_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpruneCsr2csr_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDpruneCsr2csr_bufferSizeExt(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object threshold, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneCsr2csr_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneCsr2csr_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDpruneCsr2csr_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseSpruneCsr2csrNnz(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object threshold, object descrC, object csrRowPtrC, object nnzTotalDevHostPtr, object buffer):
    r"""Convert and prune sparse CSR matrix into a sparse CSR matrix

    ``hipsparseXpruneCsr2csrNnz`` computes the number of nonzero elements per row and the total
    number of nonzero elements in a sparse CSR matrix once elements less than the threshold are
    pruned from the matrix.

    Note:
        The routine does support asynchronous execution if the pointer mode is set to device.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneCsr2csrNnz__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneCsr2csrNnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseSpruneCsr2csrNnz__retval,)


@cython.embedsignature(True)
def hipsparseDpruneCsr2csrNnz(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object threshold, object descrC, object csrRowPtrC, object nnzTotalDevHostPtr, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneCsr2csrNnz__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneCsr2csrNnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseDpruneCsr2csrNnz__retval,)


@cython.embedsignature(True)
def hipsparseSpruneCsr2csr(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object threshold, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object buffer):
    r"""Convert and prune sparse CSR matrix into a sparse CSR matrix

    This function converts the sparse CSR matrix A into a sparse CSR matrix C by pruning values in A
    that are less than the threshold. All the parameters are assumed to have been pre-allocated by the user.
    The user first calls hipsparseXpruneCsr2csr_bufferSize() to determine the size of the buffer used
    by hipsparseXpruneCsr2csrNnz() and hipsparseXpruneCsr2csr() which the user then allocates. The user then
    allocates ``csrRowPtrC`` to have ``m+1`` elements and then calls hipsparseXpruneCsr2csrNnz() which fills
    in the ``csrRowPtrC`` array stores then number of elements that are larger than the pruning ``threshold``
    in ``nnzTotalDevHostPtr.`` The user then calls hipsparseXpruneCsr2csr() to complete the conversion. It
    is executed asynchronously with respect to the host and may return control to the application on the host
    before the entire result is ready.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneCsr2csr__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneCsr2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseSpruneCsr2csr__retval,)


@cython.embedsignature(True)
def hipsparseDpruneCsr2csr(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object threshold, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        threshold (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneCsr2csr__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneCsr2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(threshold)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseDpruneCsr2csr__retval,)


@cython.embedsignature(True)
def hipsparseSpruneCsr2csrByPercentage_bufferSize(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, float percentage, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object info, object pBufferSizeInBytes):
    r"""Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix

    ``hipsparseXpruneCsr2csrByPercentage_bufferSize`` returns the size of the temporary buffer that
    is required by ``hipsparseXpruneCsr2csrNnzByPercentage.``
    The temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneCsr2csrByPercentage_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneCsr2csrByPercentage_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpruneCsr2csrByPercentage_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDpruneCsr2csrByPercentage_bufferSize(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, double percentage, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneCsr2csrByPercentage_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneCsr2csrByPercentage_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDpruneCsr2csrByPercentage_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSpruneCsr2csrByPercentage_bufferSizeExt(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, float percentage, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object info, object pBufferSizeInBytes):
    r"""Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix

    ``hipsparseXpruneCsr2csrByPercentage_bufferSizeExt`` returns the size of the temporary buffer that
    is required by ``hipsparseXpruneCsr2csrNnzByPercentage.``
    The temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneCsr2csrByPercentage_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneCsr2csrByPercentage_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpruneCsr2csrByPercentage_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDpruneCsr2csrByPercentage_bufferSizeExt(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, double percentage, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneCsr2csrByPercentage_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneCsr2csrByPercentage_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDpruneCsr2csrByPercentage_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseSpruneCsr2csrNnzByPercentage(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, float percentage, object descrC, object csrRowPtrC, object nnzTotalDevHostPtr, object info, object buffer):
    r"""Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix

    ``hipsparseXpruneCsr2csrNnzByPercentage`` computes the number of nonzero elements per row and the total
    number of nonzero elements in a sparse CSR matrix once elements less than the threshold are
    pruned from the matrix.

    Note:
        The routine does support asynchronous execution if the pointer mode is set to device.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneCsr2csrNnzByPercentage__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneCsr2csrNnzByPercentage(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseSpruneCsr2csrNnzByPercentage__retval,)


@cython.embedsignature(True)
def hipsparseDpruneCsr2csrNnzByPercentage(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, double percentage, object descrC, object csrRowPtrC, object nnzTotalDevHostPtr, object info, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneCsr2csrNnzByPercentage__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneCsr2csrNnzByPercentage(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseDpruneCsr2csrNnzByPercentage__retval,)


@cython.embedsignature(True)
def hipsparseSpruneCsr2csrByPercentage(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, float percentage, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object info, object buffer):
    r"""Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix

    This function converts the sparse CSR matrix A into a sparse CSR matrix C by pruning values in A
    that are less than the threshold. All the parameters are assumed to have been pre-allocated by the user.
    The user first calls hipsparseXpruneCsr2csr_bufferSize() to determine the size of the buffer used
    by hipsparseXpruneCsr2csrNnz() and hipsparseXpruneCsr2csr() which the user then allocates. The user then
    allocates ``csrRowPtrC`` to have ``m+1`` elements and then calls hipsparseXpruneCsr2csrNnz() which fills
    in the ``csrRowPtrC`` array stores then number of elements that are larger than the pruning ``threshold``
    in ``nnzTotalDevHostPtr.`` The user then calls hipsparseXpruneCsr2csr() to complete the conversion. It
    is executed asynchronously with respect to the host and may return control to the application on the host
    before the entire result is ready.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpruneCsr2csrByPercentage__retval = hipsparseStatus_t(chipsparse.hipsparseSpruneCsr2csrByPercentage(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseSpruneCsr2csrByPercentage__retval,)


@cython.embedsignature(True)
def hipsparseDpruneCsr2csrByPercentage(object handle, int m, int n, int nnzA, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, double percentage, object descrC, object csrValC, object csrRowPtrC, object csrColIndC, object info, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnzA (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        percentage (`~.float`/`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.pruneInfo`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDpruneCsr2csrByPercentage__retval = hipsparseStatus_t(chipsparse.hipsparseDpruneCsr2csrByPercentage(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnzA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,percentage,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrValC)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColIndC)._ptr,
        pruneInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseDpruneCsr2csrByPercentage__retval,)


@cython.embedsignature(True)
def hipsparseShyb2csr(object handle, object descrA, object hybA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA):
    r"""Convert a sparse HYB matrix into a sparse CSR matrix

    ``hipsparseXhyb2csr`` converts a HYB matrix into a CSR matrix.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseShyb2csr__retval = hipsparseStatus_t(chipsparse.hipsparseShyb2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(hybA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr))
    return (_hipsparseShyb2csr__retval,)


@cython.embedsignature(True)
def hipsparseDhyb2csr(object handle, object descrA, object hybA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDhyb2csr__retval = hipsparseStatus_t(chipsparse.hipsparseDhyb2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(hybA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrSortedValA)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr))
    return (_hipsparseDhyb2csr__retval,)


@cython.embedsignature(True)
def hipsparseChyb2csr(object handle, object descrA, object hybA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.float2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseChyb2csr__retval = hipsparseStatus_t(chipsparse.hipsparseChyb2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(hybA)._ptr,
        float2.fromPyobj(csrSortedValA).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr))
    return (_hipsparseChyb2csr__retval,)


@cython.embedsignature(True)
def hipsparseZhyb2csr(object handle, object descrA, object hybA, object csrSortedValA, object csrSortedRowPtrA, object csrSortedColIndA):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        hybA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedValA (`~.double2`/`~.object`):
            (undocumented)

        csrSortedRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrSortedColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZhyb2csr__retval = hipsparseStatus_t(chipsparse.hipsparseZhyb2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(hybA)._ptr,
        double2.fromPyobj(csrSortedValA).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedRowPtrA)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrSortedColIndA)._ptr))
    return (_hipsparseZhyb2csr__retval,)


@cython.embedsignature(True)
def hipsparseXcoo2csr(object handle, object cooRowInd, int nnz, int m, object csrRowPtr, object idxBase):
    r"""Convert a sparse COO matrix into a sparse CSR matrix

    ``hipsparseXcoo2csr`` converts the COO array containing the row indices into a
    CSR array of row offsets, that point to the start of every row.
    It is assumed that the COO row index array is sorted and that all arrays have been allocated
    prior to calling hipsparseXcoo2csr.

    For example, given the COO row indices array:

    .. math::

       \begin{align}
       \text{cooRowInd} &= \begin{bmatrix} 0 & 0 & 1 & 2 & 2 & 4 & 4 & 4 \end{bmatrix}
       \end{align}

    the resulting CSR row pointer array after calling ``hipsparseXcoo2csr`` is:

    .. math::

       \begin{align}
       \text{csrRowPtr} &= \begin{bmatrix} 0 & 2 & 3 & 5 & 8 \end{bmatrix}
       \end{align}

    Note:
        It can also be used, to convert a COO array containing the column indices into
        a CSC array of column offsets, that point to the start of every column. Then, it is
        assumed that the COO column index array is sorted, instead.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Sparse matrix in COO format
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcooRowInd[8] = {0, 0, 0, 1, 1, 2, 2, 2};
       int hcooColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
       float hcooVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int nnz       = 8;
       hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;

       int* dcooRowInd = nullptr;
       int* dcooColInd = nullptr;
       hipMalloc((void**)&dcooRowInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcooColInd, sizeof(int) * nnz);

       hipMemcpy(dcooRowInd, hcooRowInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcooColInd, hcooColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);

       int* dcsrRowPtr = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));

       hipsparseXcoo2csr(handle, dcooRowInd, nnz, m, dcsrRowPtr, base);

       hipFree(dcooRowInd);
       hipFree(dcooColInd);

       hipFree(dcsrRowPtr);

       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)
    """
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")
    _hipsparseXcoo2csr__retval = hipsparseStatus_t(chipsparse.hipsparseXcoo2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cooRowInd)._ptr,nnz,m,
        <int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,idxBase.value))
    return (_hipsparseXcoo2csr__retval,)


@cython.embedsignature(True)
def hipsparseCreateIdentityPermutation(object handle, int n, object p):
    r"""Create the identity map

    ``hipsparseCreateIdentityPermutation`` stores the identity map in ``p,`` such that
    :math:`p = 0:1:(n-1)`.

    .. code-block::

       for(i = 0; i < n; ++i)
       {
           p[i] = i;
       }

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       int n = 10;

       int* dperm = nullptr;
       hipMalloc((void**)&dperm, sizeof(int) * n);

       hipsparseCreateIdentityPermutation(handle, n, dperm);

       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        p (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCreateIdentityPermutation__retval = hipsparseStatus_t(chipsparse.hipsparseCreateIdentityPermutation(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,n,
        <int *>hip._util.types.Pointer.fromPyobj(p)._ptr))
    return (_hipsparseCreateIdentityPermutation__retval,)


@cython.embedsignature(True)
def hipsparseXcsrsort_bufferSizeExt(object handle, int m, int n, int nnz, object csrRowPtr, object csrColInd, object pBufferSizeInBytes):
    r"""Sort a sparse CSR matrix

    ``hipsparseXcsrsort_bufferSizeExt`` returns the size of the temporary storage buffer
    in bytes required by hipsparseXcsrsort(). The temporary storage buffer must be allocated by
    the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcsrsort_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseXcsrsort_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseXcsrsort_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseXcsrsort(object handle, int m, int n, int nnz, object descrA, object csrRowPtr, object csrColInd, object P, object pBuffer):
    r"""Sort a sparse CSR matrix

    ``hipsparseXcsrsort`` sorts a matrix in CSR format. The sorted permutation vector
    ``perm`` can be used to obtain sorted ``csrVal`` array. In this case, ``perm`` must be
    initialized as the identity permutation, see hipsparseCreateIdentityPermutation(). To
    apply the permutation vector to the CSR values, see hipsparse hipsparseSgthr().

    ``hipsparseXcsrsort`` requires extra temporary storage buffer that has to be allocated by
    the user. Storage buffer size can be determined by hipsparseXcsrsort_bufferSizeExt().

    Note:
        ``perm`` can be ``NULL`` if a sorted permutation vector is not required.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Sparse matrix in CSR format (columns unsorted)
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcsrRowPtr[4] = {0, 3, 5, 8};
       int hcsrColInd[8] = {3, 1, 0, 2, 1, 0, 4, 3};
       float hcsrVal[8]  = {3.0f, 2.0f, 1.0f, 5.0f, 4.0f, 6.0f, 8.0f, 7.0f};

       int m         = 3;
       int n         = 5;
       int nnz       = 8;

       int* dcsrRowPtr = nullptr;
       int* dcsrColInd = nullptr;
       float* dcsrVal = nullptr;
       hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
       hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);

       hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       size_t bufferSize;
       hipsparseXcsrsort_bufferSizeExt(handle,
                                       m,
                                       n,
                                       nnz,
                                       dcsrRowPtr,
                                       dcsrColInd,
                                       &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       int* dperm = nullptr;
       hipMalloc((void**)&dperm, sizeof(int) * nnz);
       hipsparseCreateIdentityPermutation(handle, nnz, dperm);

       hipsparseXcsrsort(handle,
                         m,
                         n,
                         nnz,
                         descr,
                         dcsrRowPtr,
                         dcsrColInd,
                         dperm,
                         dbuffer);

       float* dcsrValSorted = nullptr;
       hipMalloc((void**)&dcsrValSorted, sizeof(float) * nnz);
       hipsparseSgthr(handle, nnz, dcsrVal, dcsrValSorted, dperm, HIPSPARSE_INDEX_BASE_ZERO);

       hipFree(dcsrRowPtr);
       hipFree(dcsrColInd);
       hipFree(dcsrVal);
       hipFree(dcsrValSorted);

       hipFree(dbuffer);
       hipFree(dperm);

       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        P (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcsrsort__retval = hipsparseStatus_t(chipsparse.hipsparseXcsrsort(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(P)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseXcsrsort__retval,)


@cython.embedsignature(True)
def hipsparseXcscsort_bufferSizeExt(object handle, int m, int n, int nnz, object cscColPtr, object cscRowInd, object pBufferSizeInBytes):
    r"""Sort a sparse CSC matrix

    ``hipsparseXcscsort_bufferSizeExt`` returns the size of the temporary storage buffer
    in bytes required by hipsparseXcscsort(). The temporary storage buffer must be
    allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcscsort_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseXcscsort_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <const int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseXcscsort_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseXcscsort(object handle, int m, int n, int nnz, object descrA, object cscColPtr, object cscRowInd, object P, object pBuffer):
    r"""Sort a sparse CSC matrix

    ``hipsparseXcscsort`` sorts a matrix in CSC format. The sorted permutation vector
    ``perm`` can be used to obtain sorted ``csc_val`` array. In this case, ``perm`` must be
    initialized as the identity permutation, see hipsparseCreateIdentityPermutation(). To
    apply the permutation vector to the CSC values, see hipsparse hipsparseSgthr().

    ``hipsparseXcscsort`` requires extra temporary storage buffer that has to be allocated by
    the user. Storage buffer size can be determined by hipsparseXcscsort_bufferSizeExt().

    Note:
        ``perm`` can be ``NULL`` if a sorted permutation vector is not required.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t descr;
       hipsparseCreateMatDescr(&descr);

       // Sparse matrix in CSC format (unsorted row indices)
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcscRowInd[8] = {2, 0, 1, 0, 1, 2, 0, 2};
       int hcscColPtr[6] = {0, 2, 4, 5, 7, 8};
       float hcscVal[8]  = {6.0f, 1.0f, 4.0f, 2.0f, 5.0f, 7.0f, 3.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int nnz       = 8;

       int* dcscRowInd = nullptr;
       int* dcscColPtr = nullptr;
       float* dcscVal = nullptr;
       hipMalloc((void**)&dcscRowInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcscColPtr, sizeof(int) * (n + 1));
       hipMalloc((void**)&dcscVal, sizeof(float) * nnz);

       hipMemcpy(dcscRowInd, hcscRowInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcscColPtr, hcscColPtr, sizeof(int) * (n + 1), hipMemcpyHostToDevice);
       hipMemcpy(dcscVal, hcscVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       size_t bufferSize;
       hipsparseXcscsort_bufferSizeExt(handle,
                                       m,
                                       n,
                                       nnz,
                                       dcscColPtr,
                                       dcscRowInd,
                                       &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       int* dperm = nullptr;
       hipMalloc((void**)&dperm, sizeof(int) * nnz);
       hipsparseCreateIdentityPermutation(handle, nnz, dperm);

       hipsparseXcscsort(handle,
                         m,
                         n,
                         nnz,
                         descr,
                         dcscColPtr,
                         dcscRowInd,
                         dperm,
                         dbuffer);

       float* dcscValSorted = nullptr;
       hipMalloc((void**)&dcscValSorted, sizeof(float) * nnz);
       hipsparseSgthr(handle, nnz, dcscVal, dcscValSorted, dperm, HIPSPARSE_INDEX_BASE_ZERO);

       hipFree(dcscRowInd);
       hipFree(dcscColPtr);
       hipFree(dcscVal);
       hipFree(dcscValSorted);

       hipFree(dbuffer);
       hipFree(dperm);

       hipsparseDestroyMatDescr(descr);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        P (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcscsort__retval = hipsparseStatus_t(chipsparse.hipsparseXcscsort(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cscColPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(P)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseXcscsort__retval,)


@cython.embedsignature(True)
def hipsparseXcoosort_bufferSizeExt(object handle, int m, int n, int nnz, object cooRows, object cooCols, object pBufferSizeInBytes):
    r"""Sort a sparse COO matrix

    ``hipsparseXcoosort_bufferSizeExt`` returns the size of the temporary storage buffer
    in bytes required by hipsparseXcoosort(). The temporary storage buffer must be
    allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        cooRows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooCols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcoosort_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseXcoosort_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <const int *>hip._util.types.Pointer.fromPyobj(cooRows)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(cooCols)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseXcoosort_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseXcoosortByRow(object handle, int m, int n, int nnz, object cooRows, object cooCols, object P, object pBuffer):
    r"""Sort a sparse COO matrix by row

    ``hipsparseXcoosortByRow`` sorts a matrix in COO format by row. The sorted
    permutation vector ``perm`` can be used to obtain sorted ``cooVal`` array. In this
    case, ``perm`` must be initialized as the identity permutation, see
    hipsparseCreateIdentityPermutation(). To apply the permutation vector to the COO
    values, see hipsparse hipsparseSgthr().

    ``hipsparseXcoosortByRow`` requires extra temporary storage buffer that has to be
    allocated by the user. Storage buffer size can be determined by
    hipsparseXcoosort_bufferSizeExt().

    Note:
        ``perm`` can be ``NULL`` if a sorted permutation vector is not required.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Sparse matrix in COO format (with unsorted row indices)
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcooRowInd[8] = {0, 2, 0, 1, 1, 0, 2, 2};
       int hcooColInd[8] = {0, 0, 1, 1, 2, 3, 3, 4};
       float hcooVal[8]   = {1.0f, 6.0f, 2.0f, 4.0f, 5.0f, 3.0f, 7.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int nnz       = 8;
       hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;

       int* dcooRowInd = nullptr;
       int* dcooColInd = nullptr;
       float* dcooVal = nullptr;
       hipMalloc((void**)&dcooRowInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcooColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcooVal, sizeof(float) * nnz);

       hipMemcpy(dcooRowInd, hcooRowInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcooColInd, hcooColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcooVal, hcooVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       size_t bufferSize;
       hipsparseXcoosort_bufferSizeExt(handle, m, n, nnz, dcooRowInd, dcooColInd, &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       int* dperm = nullptr;
       hipMalloc((void**)&dperm, sizeof(int) * nnz);
       hipsparseCreateIdentityPermutation(handle, nnz, dperm);

       hipsparseXcoosortByRow(handle, m, n, nnz, dcooRowInd, dcooColInd, dperm, dbuffer);

       float* dcooValSorted = nullptr;
       hipMalloc((void**)&dcooValSorted, sizeof(float) * nnz);
       hipsparseSgthr(handle, nnz, dcooVal, dcooValSorted, dperm, base);

       hipFree(dcooRowInd);
       hipFree(dcooColInd);
       hipFree(dcooVal);
       hipFree(dcooValSorted);
       hipFree(dperm);

       hipFree(dbuffer);

       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        cooRows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooCols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        P (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcoosortByRow__retval = hipsparseStatus_t(chipsparse.hipsparseXcoosortByRow(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <int *>hip._util.types.Pointer.fromPyobj(cooRows)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cooCols)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(P)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseXcoosortByRow__retval,)


@cython.embedsignature(True)
def hipsparseXcoosortByColumn(object handle, int m, int n, int nnz, object cooRows, object cooCols, object P, object pBuffer):
    r"""Sort a sparse COO matrix by column

    ``hipsparseXcoosortByColumn`` sorts a matrix in COO format by column. The sorted
    permutation vector ``perm`` can be used to obtain sorted ``cooVal`` array. In this
    case, ``perm`` must be initialized as the identity permutation, see
    hipsparseCreateIdentityPermutation(). To apply the permutation vector to the COO
    values, see hipsparse hipsparseSgthr().

    ``hipsparseXcoosortByColumn`` requires extra temporary storage buffer that has to be
    allocated by the user. Storage buffer size can be determined by
    hipsparseXcoosort_bufferSizeExt().

    Note:
        ``perm`` can be ``NULL`` if a sorted permutation vector is not required.

    Note:
        This function is non blocking and executed asynchronously with respect to the host.
        It may return before the actual computation has finished.

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       // Sparse matrix in COO format (with unsorted column indices)
       //     1 2 0 3 0
       // A = 0 4 5 0 0
       //     6 0 0 7 8
       int hcooRowInd[8] = {0, 0, 0, 1, 1, 2, 2, 2};
       int hcooColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
       float hcooVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};

       int m         = 3;
       int n         = 5;
       int nnz       = 8;
       hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;

       int* dcooRowInd = nullptr;
       int* dcooColInd = nullptr;
       float* dcooVal = nullptr;
       hipMalloc((void**)&dcooRowInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcooColInd, sizeof(int) * nnz);
       hipMalloc((void**)&dcooVal, sizeof(float) * nnz);

       hipMemcpy(dcooRowInd, hcooRowInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcooColInd, hcooColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
       hipMemcpy(dcooVal, hcooVal, sizeof(float) * nnz, hipMemcpyHostToDevice);

       size_t bufferSize;
       hipsparseXcoosort_bufferSizeExt(handle, m, n, nnz, dcooRowInd, dcooColInd, &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       int* dperm = nullptr;
       hipMalloc((void**)&dperm, sizeof(int) * nnz);
       hipsparseCreateIdentityPermutation(handle, nnz, dperm);

       hipsparseXcoosortByColumn(handle, m, n, nnz, dcooRowInd, dcooColInd, dperm, dbuffer);

       float* dcooValSorted = nullptr;
       hipMalloc((void**)&dcooValSorted, sizeof(float) * nnz);
       hipsparseSgthr(handle, nnz, dcooVal, dcooValSorted, dperm, base);

       hipFree(dcooRowInd);
       hipFree(dcooColInd);
       hipFree(dcooVal);
       hipFree(dcooValSorted);
       hipFree(dperm);

       hipFree(dbuffer);

       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        cooRows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooCols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        P (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseXcoosortByColumn__retval = hipsparseStatus_t(chipsparse.hipsparseXcoosortByColumn(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <int *>hip._util.types.Pointer.fromPyobj(cooRows)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(cooCols)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(P)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseXcoosortByColumn__retval,)


@cython.embedsignature(True)
def hipsparseSgebsr2gebsr_bufferSize(object handle, object dirA, int mb, int nb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, object pBufferSizeInBytes):
    r"""This function computes the the size of the user allocated temporary storage buffer used when converting a sparse
    GEBSR matrix to another sparse GEBSR matrix.

    ``hipsparseXgebsr2gebsr_bufferSize`` returns the size of the temporary storage buffer
    that is required by hipsparseXgebsr2gebsrNnz() and hipsparseXgebsr2gebsr().
    The temporary storage buffer must be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimA (`~.int`):
            (undocumented)

        colBlockDimA (`~.int`):
            (undocumented)

        rowBlockDimC (`~.int`):
            (undocumented)

        colBlockDimC (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseSgebsr2gebsr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSgebsr2gebsr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDimA,colBlockDimA,rowBlockDimC,colBlockDimC,
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSgebsr2gebsr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDgebsr2gebsr_bufferSize(object handle, object dirA, int mb, int nb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimA (`~.int`):
            (undocumented)

        colBlockDimA (`~.int`):
            (undocumented)

        rowBlockDimC (`~.int`):
            (undocumented)

        colBlockDimC (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseDgebsr2gebsr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDgebsr2gebsr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDimA,colBlockDimA,rowBlockDimC,colBlockDimC,
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDgebsr2gebsr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseCgebsr2gebsr_bufferSize(object handle, object dirA, int mb, int nb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimA (`~.int`):
            (undocumented)

        colBlockDimA (`~.int`):
            (undocumented)

        rowBlockDimC (`~.int`):
            (undocumented)

        colBlockDimC (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseCgebsr2gebsr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseCgebsr2gebsr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDimA,colBlockDimA,rowBlockDimC,colBlockDimC,
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCgebsr2gebsr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseZgebsr2gebsr_bufferSize(object handle, object dirA, int mb, int nb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimA (`~.int`):
            (undocumented)

        colBlockDimA (`~.int`):
            (undocumented)

        rowBlockDimC (`~.int`):
            (undocumented)

        colBlockDimC (`~.int`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseZgebsr2gebsr_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseZgebsr2gebsr_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDimA,colBlockDimA,rowBlockDimC,colBlockDimC,
        <int *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZgebsr2gebsr_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseXgebsr2gebsrNnz(object handle, object dirA, int mb, int nb, int nnzb, object descrA, object bsrRowPtrA, object bsrColIndA, int rowBlockDimA, int colBlockDimA, object descrC, object bsrRowPtrC, int rowBlockDimC, int colBlockDimC, object nnzTotalDevHostPtr, object buffer):
    r"""This function is used when converting a GEBSR sparse matrix ``A`` to another GEBSR sparse matrix ``C.``
    Specifically, this function determines the number of non-zero blocks that will exist in ``C`` (stored using either a host
    or device pointer), and computes the row pointer array for ``C.``

    The routine does support asynchronous execution.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimA (`~.int`):
            (undocumented)

        colBlockDimA (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimC (`~.int`):
            (undocumented)

        colBlockDimC (`~.int`):
            (undocumented)

        nnzTotalDevHostPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseXgebsr2gebsrNnz__retval = hipsparseStatus_t(chipsparse.hipsparseXgebsr2gebsrNnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDimA,colBlockDimA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrC)._ptr,rowBlockDimC,colBlockDimC,
        <int *>hip._util.types.Pointer.fromPyobj(nnzTotalDevHostPtr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseXgebsr2gebsrNnz__retval,)


@cython.embedsignature(True)
def hipsparseSgebsr2gebsr(object handle, object dirA, int mb, int nb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDimA, int colBlockDimA, object descrC, object bsrValC, object bsrRowPtrC, object bsrColIndC, int rowBlockDimC, int colBlockDimC, object buffer):
    r"""This function converts the GEBSR sparse matrix ``A`` to another GEBSR sparse matrix ``C.``

    The conversion uses three steps. First, the user calls hipsparseXgebsr2gebsr_bufferSize() to determine the size of
    the required temporary storage buffer. The user then allocates this buffer. Secondly, the user then allocates ``mbC+1``
    integers for the row pointer array for ``C`` where:

    .. math::

       \begin{align}
       \text{mbC} &= \text{(m - 1) / rowBlockDimC + 1} \\
       \text{nbC} &= \text{(n - 1) / colBlockDimC + 1}
       \end{align}

    The user then calls hipsparseXgebsr2gebsrNnz() to fill in the row pointer array for ``C`` ( ``bsrRowPtrC`` ) and
    determine the number of non-zero blocks that will exist in ``C.`` Finally, the user allocates space for the column
    indices array of ``C`` to have ``nnzbC`` elements and space for the values array of ``C`` to have
    ``nnzbC*rowBlockDimC*colBlockDimC`` and then calls hipsparseXgebsr2gebsr() to complete the conversion.

    It may be the case that ``rowBlockDimC`` does not divide evenly into ``m`` and/or ``colBlockDim`` does not divide evenly
    into ``n.`` In these cases, the GEBSR matrix is expanded in size in order to fit full GEBSR blocks. For example, if
    the original GEBSR matrix A (using ``rowBlockDimA=2,`` ``colBlockDimA=3)`` looks like:

    .. math::

        \left[
         \begin{array}{c | c}
           \begin{array}{c c c}
            1 & 0 & 0 \\
            3 & 4 & 0
           \end{array} &
           \begin{array}{c c c}
            2 & 0 & 0 \\
            4 & 5 & 6
           \end{array} \\
         \hline
           \begin{array}{c c c}
            1 & 2 & 3 \\
            1 & 2 & 0
           \end{array} &
           \begin{array}{c c c}
            4 & 0 & 0 \\
            3 & 0 & 1
           \end{array} \\
        \end{array}
       \right]

    then if we specify ``rowBlockDimC=3`` and ``colBlockDimC=2,`` our output GEBSR matrix C would be:

    .. math::

        \left[
         \begin{array}{c | c | c}
           \begin{array}{c c}
            1 & 0 \\
            3 & 4 \\
            1 & 2
           \end{array} &
           \begin{array}{c c}
            0 & 2 \\
            0 & 4 \\
            3 & 4
           \end{array} &
           \begin{array}{c c}
            0 & 0 \\
            5 & 6 \\
            0 & 0
           \end{array} \\
         \hline
           \begin{array}{c c}
            1 & 2 \\
            0 & 0 \\
            0 & 0
           \end{array} &
           \begin{array}{c c}
            0 & 3 \\
            0 & 0 \\
            0 & 0
           \end{array} &
           \begin{array}{c c}
            0 & 1 \\
            0 & 0 \\
            0 & 0
           \end{array} \\
        \end{array}
       \right]

    Par:

    .. code-block::

       // hipSPARSE handle
       hipsparseHandle_t handle;
       hipsparseCreate(&handle);

       hipsparseMatDescr_t descrA;
       hipsparseCreateMatDescr(&descrA);

       hipsparseMatDescr_t descrC;
       hipsparseCreateMatDescr(&descrC);

       // Sparse matrix in BSR format
       //     1 2 | 0 3 | 0 0
       //     0 4 | 5 0 | 0 1
       // A = 6 0 | 0 7 | 8 0
       //     ---------------
       //     0 0 | 3 0 | 2 2
       //     1 0 | 0 0 | 4 3
       //     7 2 | 0 0 | 1 4
       int hbsrRowPtrA[3] = {0, 3, 6};
       int hbsrColIndA[6] = {0, 1, 2, 0, 1, 2};
       float hbsrValA[36]  = {1.0f, 2.0f, 0.0f, 4.0f, 6.0f, 0.0f,
                              0.0f, 3.0f, 5.0f, 0.0f, 0.0f, 7.0f,
                              0.0f, 0.0f, 0.0f, 1.0f, 8.0f, 0.0f,
                              0.0f, 0.0f, 1.0f, 0.0f, 7.0f, 2.0f,
                              3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f,
                              2.0f, 2.0f, 4.0f, 3.0f, 1.0f, 4.0f};

       int m           = 6;
       int n           = 6;
       int rowBlockDimA = 3;
       int colBlockDimA = 2;
       int rowBlockDimC = 2;
       int colBlockDimC = 2;
       hipsparseDirection_t dirA = HIPSPARSE_DIRECTION_ROW;

       int mbA   = (m + rowBlockDimA - 1) / rowBlockDimA;
       int nbA   = (n + colBlockDimA - 1) / colBlockDimA;
       int nnzbA = 6;

       int mbC   = (m + rowBlockDimC - 1) / rowBlockDimC;
       int nbC   = (n + colBlockDimC - 1) / colBlockDimC;

       int* dbsrRowPtrA = nullptr;
       int* dbsrColIndA = nullptr;
       float* dbsrValA = nullptr;
       hipMalloc((void**)&dbsrRowPtrA, sizeof(int) * (mbA + 1));
       hipMalloc((void**)&dbsrColIndA, sizeof(int) * nnzbA);
       hipMalloc((void**)&dbsrValA, sizeof(float) * rowBlockDimA * colBlockDimA * nnzbA);

       hipMemcpy(dbsrRowPtrA, hbsrRowPtrA, sizeof(int) * (mbA + 1), hipMemcpyHostToDevice);
       hipMemcpy(dbsrColIndA, hbsrColIndA, sizeof(int) * nnzbA, hipMemcpyHostToDevice);
       hipMemcpy(dbsrValA, hbsrValA, sizeof(float) * rowBlockDimA * colBlockDimA * nnzbA, hipMemcpyHostToDevice);

       int* dbsrRowPtrC = nullptr;
       hipMalloc((void**)&dbsrRowPtrC, sizeof(int) * (mbC + 1));

       size_t bufferSize;
       hipsparseSgebsr2gebsr_bufferSize(handle,
                                        dirA,
                                        mbA,
                                        nbA,
                                        nnzbA,
                                        descrA,
                                        dbsrValA,
                                        dbsrRowPtrA,
                                        dbsrColIndA,
                                        rowBlockDimA,
                                        colBlockDimA,
                                        rowBlockDimC,
                                        colBlockDimC,
                                        &bufferSize);

       void* dbuffer = nullptr;
       hipMalloc((void**)&dbuffer, bufferSize);

       int nnzbC;
       hipsparseXgebsr2gebsrNnz(handle,
                                dirA,
                                mbA,
                                nbA,
                                nnzbA,
                                descrA,
                                dbsrRowPtrA,
                                dbsrColIndA,
                                rowBlockDimA,
                                colBlockDimA,
                                descrC,
                                dbsrRowPtrC,
                                rowBlockDimC,
                                colBlockDimC,
                                &nnzbC,
                                dbuffer);

       hipDeviceSynchronize();

       int* dbsrColIndC = nullptr;
       float* dbsrValC = nullptr;
       hipMalloc((void**)&dbsrColIndC, sizeof(int) * nnzbC);
       hipMalloc((void**)&dbsrValC, sizeof(float) * rowBlockDimC * colBlockDimC * nnzbC);

       hipsparseSgebsr2gebsr(handle,
                             dirA,
                             mbA,
                             nbA,
                             nnzbA,
                             descrA,
                             dbsrValA,
                             dbsrRowPtrA,
                             dbsrColIndA,
                             rowBlockDimA,
                             colBlockDimA,
                             descrC,
                             dbsrValC,
                             dbsrRowPtrC,
                             dbsrColIndC,
                             rowBlockDimC,
                             colBlockDimC,
                             dbuffer);

       hipFree(dbsrRowPtrA);
       hipFree(dbsrColIndA);
       hipFree(dbsrValA);

       hipFree(dbsrRowPtrC);
       hipFree(dbsrColIndC);
       hipFree(dbsrValC);

       hipFree(dbuffer);

       hipsparseDestroyMatDescr(descrA);
       hipsparseDestroyMatDescr(descrC);
       hipsparseDestroy(handle);

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimA (`~.int`):
            (undocumented)

        colBlockDimA (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimC (`~.int`):
            (undocumented)

        colBlockDimC (`~.int`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseSgebsr2gebsr__retval = hipsparseStatus_t(chipsparse.hipsparseSgebsr2gebsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDimA,colBlockDimA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(bsrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColIndC)._ptr,rowBlockDimC,colBlockDimC,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseSgebsr2gebsr__retval,)


@cython.embedsignature(True)
def hipsparseDgebsr2gebsr(object handle, object dirA, int mb, int nb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDimA, int colBlockDimA, object descrC, object bsrValC, object bsrRowPtrC, object bsrColIndC, int rowBlockDimC, int colBlockDimC, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimA (`~.int`):
            (undocumented)

        colBlockDimA (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimC (`~.int`):
            (undocumented)

        colBlockDimC (`~.int`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseDgebsr2gebsr__retval = hipsparseStatus_t(chipsparse.hipsparseDgebsr2gebsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(bsrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDimA,colBlockDimA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(bsrValC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColIndC)._ptr,rowBlockDimC,colBlockDimC,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseDgebsr2gebsr__retval,)


@cython.embedsignature(True)
def hipsparseCgebsr2gebsr(object handle, object dirA, int mb, int nb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDimA, int colBlockDimA, object descrC, object bsrValC, object bsrRowPtrC, object bsrColIndC, int rowBlockDimC, int colBlockDimC, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimA (`~.int`):
            (undocumented)

        colBlockDimA (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValC (`~.float2`/`~.object`):
            (undocumented)

        bsrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimC (`~.int`):
            (undocumented)

        colBlockDimC (`~.int`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseCgebsr2gebsr__retval = hipsparseStatus_t(chipsparse.hipsparseCgebsr2gebsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDimA,colBlockDimA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        float2.fromPyobj(bsrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColIndC)._ptr,rowBlockDimC,colBlockDimC,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseCgebsr2gebsr__retval,)


@cython.embedsignature(True)
def hipsparseZgebsr2gebsr(object handle, object dirA, int mb, int nb, int nnzb, object descrA, object bsrValA, object bsrRowPtrA, object bsrColIndA, int rowBlockDimA, int colBlockDimA, object descrC, object bsrValC, object bsrRowPtrC, object bsrColIndC, int rowBlockDimC, int colBlockDimC, object buffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dirA (`~.hipsparseDirection_t`):
            (undocumented)

        mb (`~.int`):
            (undocumented)

        nb (`~.int`):
            (undocumented)

        nnzb (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValA (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimA (`~.int`):
            (undocumented)

        colBlockDimA (`~.int`):
            (undocumented)

        descrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrValC (`~.double2`/`~.object`):
            (undocumented)

        bsrRowPtrC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bsrColIndC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rowBlockDimC (`~.int`):
            (undocumented)

        colBlockDimC (`~.int`):
            (undocumented)

        buffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(dirA,_hipsparseDirection_t__Base):
        raise TypeError("argument 'dirA' must be of type '_hipsparseDirection_t__Base'")
    _hipsparseZgebsr2gebsr__retval = hipsparseStatus_t(chipsparse.hipsparseZgebsr2gebsr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,dirA.value,mb,nb,nnzb,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(bsrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(bsrColIndA)._ptr,rowBlockDimA,colBlockDimA,
        <void *const>hip._util.types.Pointer.fromPyobj(descrC)._ptr,
        double2.fromPyobj(bsrValC).getElementPtr(),
        <int *>hip._util.types.Pointer.fromPyobj(bsrRowPtrC)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(bsrColIndC)._ptr,rowBlockDimC,colBlockDimC,
        <void *>hip._util.types.Pointer.fromPyobj(buffer)._ptr))
    return (_hipsparseZgebsr2gebsr__retval,)


@cython.embedsignature(True)
def hipsparseScsru2csr_bufferSizeExt(object handle, int m, int n, int nnz, object csrVal, object csrRowPtr, object csrColInd, object info, object pBufferSizeInBytes):
    r"""This function calculates the amount of temporary storage in bytes required for
    hipsparseXcsru2csr() and hipsparseXcsr2csru().

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsru2csr_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseScsru2csr_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseScsru2csr_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseDcsru2csr_bufferSizeExt(object handle, int m, int n, int nnz, object csrVal, object csrRowPtr, object csrColInd, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsru2csr_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseDcsru2csr_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDcsru2csr_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseCcsru2csr_bufferSizeExt(object handle, int m, int n, int nnz, object csrVal, object csrRowPtr, object csrColInd, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrVal (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsru2csr_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseCcsru2csr_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        float2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseCcsru2csr_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseZcsru2csr_bufferSizeExt(object handle, int m, int n, int nnz, object csrVal, object csrRowPtr, object csrColInd, object info, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrVal (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsru2csr_bufferSizeExt__retval = hipsparseStatus_t(chipsparse.hipsparseZcsru2csr_bufferSizeExt(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        double2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseZcsru2csr_bufferSizeExt__retval,)


@cython.embedsignature(True)
def hipsparseScsru2csr(object handle, int m, int n, int nnz, object descrA, object csrVal, object csrRowPtr, object csrColInd, object info, object pBuffer):
    r"""This function converts unsorted CSR format to sorted CSR format. The required
    temporary storage has to be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsru2csr__retval = hipsparseStatus_t(chipsparse.hipsparseScsru2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsru2csr__retval,)


@cython.embedsignature(True)
def hipsparseDcsru2csr(object handle, int m, int n, int nnz, object descrA, object csrVal, object csrRowPtr, object csrColInd, object info, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsru2csr__retval = hipsparseStatus_t(chipsparse.hipsparseDcsru2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsru2csr__retval,)


@cython.embedsignature(True)
def hipsparseCcsru2csr(object handle, int m, int n, int nnz, object descrA, object csrVal, object csrRowPtr, object csrColInd, object info, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsru2csr__retval = hipsparseStatus_t(chipsparse.hipsparseCcsru2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsru2csr__retval,)


@cython.embedsignature(True)
def hipsparseZcsru2csr(object handle, int m, int n, int nnz, object descrA, object csrVal, object csrRowPtr, object csrColInd, object info, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsru2csr__retval = hipsparseStatus_t(chipsparse.hipsparseZcsru2csr(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsru2csr__retval,)


@cython.embedsignature(True)
def hipsparseScsr2csru(object handle, int m, int n, int nnz, object descrA, object csrVal, object csrRowPtr, object csrColInd, object info, object pBuffer):
    r"""This function converts sorted CSR format to unsorted CSR format. The required
    temporary storage has to be allocated by the user.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsr2csru__retval = hipsparseStatus_t(chipsparse.hipsparseScsr2csru(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <float *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseScsr2csru__retval,)


@cython.embedsignature(True)
def hipsparseDcsr2csru(object handle, int m, int n, int nnz, object descrA, object csrVal, object csrRowPtr, object csrColInd, object info, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsr2csru__retval = hipsparseStatus_t(chipsparse.hipsparseDcsr2csru(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <double *>hip._util.types.Pointer.fromPyobj(csrVal)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseDcsr2csru__retval,)


@cython.embedsignature(True)
def hipsparseCcsr2csru(object handle, int m, int n, int nnz, object descrA, object csrVal, object csrRowPtr, object csrColInd, object info, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsr2csru__retval = hipsparseStatus_t(chipsparse.hipsparseCcsr2csru(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseCcsr2csru__retval,)


@cython.embedsignature(True)
def hipsparseZcsr2csru(object handle, int m, int n, int nnz, object descrA, object csrVal, object csrRowPtr, object csrColInd, object info, object pBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        n (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrVal (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.csru2csrInfo`/`~.object`):
            (undocumented)

        pBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsr2csru__retval = hipsparseStatus_t(chipsparse.hipsparseZcsr2csru(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,n,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrVal).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        csru2csrInfo.fromPyobj(info).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(pBuffer)._ptr))
    return (_hipsparseZcsr2csru__retval,)


@cython.embedsignature(True)
def hipsparseScsrcolor(object handle, int m, int nnz, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object fractionToColor, object ncolors, object coloring, object reordering, object info):
    r"""Coloring of the adjacency graph of the matrix :math:`A` stored in the CSR format.

    ``hipsparseXcsrcolor`` performs the coloring of the undirected graph represented by the (symmetric) sparsity pattern of the matrix :math:`A` stored in CSR format. Graph coloring is a way of coloring the nodes of a graph such that no two adjacent nodes are of the same color. The ``fraction_to_color`` is a parameter to only color a given percentage of the graph nodes, the remaining uncolored nodes receive distinct new colors. The optional ``reordering`` array is a permutation array such that unknowns of the same color are grouped. The matrix :math:`A` must be stored as a general matrix with a symmetric sparsity pattern, and if the matrix :math:`A` is non-symmetric then the user is responsible to provide the symmetric part :math:`\frac{A+A^T}{2}`.

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        fractionToColor (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ncolors (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        coloring (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        reordering (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScsrcolor__retval = hipsparseStatus_t(chipsparse.hipsparseScsrcolor(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(fractionToColor)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(ncolors)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(coloring)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(reordering)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(info)._ptr))
    return (_hipsparseScsrcolor__retval,)


@cython.embedsignature(True)
def hipsparseDcsrcolor(object handle, int m, int nnz, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object fractionToColor, object ncolors, object coloring, object reordering, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        fractionToColor (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ncolors (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        coloring (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        reordering (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDcsrcolor__retval = hipsparseStatus_t(chipsparse.hipsparseDcsrcolor(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(csrValA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(fractionToColor)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(ncolors)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(coloring)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(reordering)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(info)._ptr))
    return (_hipsparseDcsrcolor__retval,)


@cython.embedsignature(True)
def hipsparseCcsrcolor(object handle, int m, int nnz, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object fractionToColor, object ncolors, object coloring, object reordering, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.float2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        fractionToColor (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ncolors (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        coloring (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        reordering (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCcsrcolor__retval = hipsparseStatus_t(chipsparse.hipsparseCcsrcolor(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        float2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const float *>hip._util.types.Pointer.fromPyobj(fractionToColor)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(ncolors)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(coloring)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(reordering)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(info)._ptr))
    return (_hipsparseCcsrcolor__retval,)


@cython.embedsignature(True)
def hipsparseZcsrcolor(object handle, int m, int nnz, object descrA, object csrValA, object csrRowPtrA, object csrColIndA, object fractionToColor, object ncolors, object coloring, object reordering, object info):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        m (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        descrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValA (`~.double2`/`~.object`):
            (undocumented)

        csrRowPtrA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        fractionToColor (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ncolors (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        coloring (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        reordering (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        info (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseZcsrcolor__retval = hipsparseStatus_t(chipsparse.hipsparseZcsrcolor(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,m,nnz,
        <void *const>hip._util.types.Pointer.fromPyobj(descrA)._ptr,
        double2.fromPyobj(csrValA).getElementPtr(),
        <const int *>hip._util.types.Pointer.fromPyobj(csrRowPtrA)._ptr,
        <const int *>hip._util.types.Pointer.fromPyobj(csrColIndA)._ptr,
        <const double *>hip._util.types.Pointer.fromPyobj(fractionToColor)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(ncolors)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(coloring)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(reordering)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(info)._ptr))
    return (_hipsparseZcsrcolor__retval,)


cdef class hipsparseSpGEMMDescr(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.hipsparseSpGEMMDescr.

    Python wrapper for cdef class chipsparse.hipsparseSpGEMMDescr.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.hipsparseSpGEMMDescr* getElementPtr(self):
        return <chipsparse.hipsparseSpGEMMDescr*>self._ptr

    @staticmethod
    cdef hipsparseSpGEMMDescr fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipsparseSpGEMMDescr`` objects from
        given ``chipsparse.hipsparseSpGEMMDescr`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipsparseSpGEMMDescr wrapper = hipsparseSpGEMMDescr.__new__(hipsparseSpGEMMDescr)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipsparseSpGEMMDescr from a Python object.

        Derives a hipsparseSpGEMMDescr from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipsparseSpGEMMDescr`` reference, this method
        returns it directly. No new ``hipsparseSpGEMMDescr`` is created in this case.
        """
        return hipsparseSpGEMMDescr.fromPyobj(pyobj)

    @staticmethod
    cdef hipsparseSpGEMMDescr fromPyobj(object pyobj):
        """Creates a hipsparseSpGEMMDescr from a Python object.

        Derives a hipsparseSpGEMMDescr from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipsparseSpGEMMDescr`` reference, this method
        returns it directly. No new ``hipsparseSpGEMMDescr`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipsparseSpGEMMDescr`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipsparseSpGEMMDescr!
        """
        cdef hipsparseSpGEMMDescr wrapper

        if isinstance(pyobj,hipsparseSpGEMMDescr):
            return pyobj
        else:
            wrapper = hipsparseSpGEMMDescr.__new__(hipsparseSpGEMMDescr)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipsparseSpGEMMDescr object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipsparseSpSVDescr(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.hipsparseSpSVDescr.

    Python wrapper for cdef class chipsparse.hipsparseSpSVDescr.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.hipsparseSpSVDescr* getElementPtr(self):
        return <chipsparse.hipsparseSpSVDescr*>self._ptr

    @staticmethod
    cdef hipsparseSpSVDescr fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipsparseSpSVDescr`` objects from
        given ``chipsparse.hipsparseSpSVDescr`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipsparseSpSVDescr wrapper = hipsparseSpSVDescr.__new__(hipsparseSpSVDescr)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipsparseSpSVDescr from a Python object.

        Derives a hipsparseSpSVDescr from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipsparseSpSVDescr`` reference, this method
        returns it directly. No new ``hipsparseSpSVDescr`` is created in this case.
        """
        return hipsparseSpSVDescr.fromPyobj(pyobj)

    @staticmethod
    cdef hipsparseSpSVDescr fromPyobj(object pyobj):
        """Creates a hipsparseSpSVDescr from a Python object.

        Derives a hipsparseSpSVDescr from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipsparseSpSVDescr`` reference, this method
        returns it directly. No new ``hipsparseSpSVDescr`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipsparseSpSVDescr`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipsparseSpSVDescr!
        """
        cdef hipsparseSpSVDescr wrapper

        if isinstance(pyobj,hipsparseSpSVDescr):
            return pyobj
        else:
            wrapper = hipsparseSpSVDescr.__new__(hipsparseSpSVDescr)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipsparseSpSVDescr object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


cdef class hipsparseSpSMDescr(hip._util.types.Pointer):
    """Python wrapper for cdef class chipsparse.hipsparseSpSMDescr.

    Python wrapper for cdef class chipsparse.hipsparseSpSMDescr.

    If this type is initialized via its `__init__` method, it allocates a
    member of the underlying C type and destroys it again if the wrapper
    type is deallocated.

    This type also serves as adapter when appearing as argument type in a
    function signature. In this case, the type can further be initialized
    from a number of Python objects:

    * `None`:

      This will set the ``self._ptr`` attribute to ``NULL``.

    * `int`:

      Interprets the integer value as pointer address and writes it to ``self._ptr``.
      No ownership is transferred.

    * `ctypes.c_void_p`:

      Takes the pointer address ``pyobj.value`` and writes it to ``self._ptr``.
      No ownership is transferred.

    * `object` that implements the `CUDA Array Interface <https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html>`_ protocol:

      Takes the integer-valued pointer address, i.e. the first entry of the `data` tuple
      from `pyobj`'s member ``__cuda_array_interface__``  and writes it to ``self._ptr``.

    * `object` that implements the Python buffer protocol:

      If the object represents a simple contiguous array,
      writes the `Py_buffer` associated with ``pyobj`` to `self._py_buffer`,
      sets the `self._py_buffer_acquired` flag to `True`, and
      writes `self._py_buffer.buf` to the data pointer `self._ptr`.

    * `hip._util.types.Pointer`:

      Takes the pointer address ``pyobj._ptr`` and writes it to ``self._ptr``.
      No ownership is transferred.

    Type checks are performed in the above order.

    C Attributes:
        _ptr (C type ``void *``, protected):
            Stores a pointer to the data of the original Python object.
        _is_ptr_owner (C type ``bint``, protected):
            If this wrapper is the owner of the underlying data.
        _py_buffer (C type ``Py_buffer`, protected):
            Stores a pointer to the data of the original Python object.
        _py_buffer_acquired (C type ``bint``, protected):
            Stores a pointer to the data of the original Python object.
    """
    # C members declared in pxd file

    def __cinit__(self):
        self._ptr = NULL
        self._is_ptr_owner = False
        self._py_buffer_acquired = False

    cdef chipsparse.hipsparseSpSMDescr* getElementPtr(self):
        return <chipsparse.hipsparseSpSMDescr*>self._ptr

    @staticmethod
    cdef hipsparseSpSMDescr fromPtr(void* ptr, bint owner=False):
        """Factory function to create ``hipsparseSpSMDescr`` objects from
        given ``chipsparse.hipsparseSpSMDescr`` pointer.
        """
        # Fast call to __new__() that bypasses the __init__() constructor.
        cdef hipsparseSpSMDescr wrapper = hipsparseSpSMDescr.__new__(hipsparseSpSMDescr)
        wrapper._ptr = ptr
        wrapper._is_ptr_owner = owner
        return wrapper

    @staticmethod
    def fromObj(pyobj):
        """Creates a hipsparseSpSMDescr from a Python object.

        Derives a hipsparseSpSMDescr from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipsparseSpSMDescr`` reference, this method
        returns it directly. No new ``hipsparseSpSMDescr`` is created in this case.
        """
        return hipsparseSpSMDescr.fromPyobj(pyobj)

    @staticmethod
    cdef hipsparseSpSMDescr fromPyobj(object pyobj):
        """Creates a hipsparseSpSMDescr from a Python object.

        Derives a hipsparseSpSMDescr from the given Python object ``pyobj``.
        In case ``pyobj`` is itself an ``hipsparseSpSMDescr`` reference, this method
        returns it directly. No new ``hipsparseSpSMDescr`` is created in this case.

        Args:
            pyobj (object): Must be either `None`; a `hip._util.types.Pointer`; a simple, contiguous buffer according to the buffer protocol;
                            or of type `hipsparseSpSMDescr`; `int`; or `ctypes.c_void_p`.

        Note:
            This routine does not perform a copy but returns the original ``pyobj``
            if ``pyobj`` is an instance of hipsparseSpSMDescr!
        """
        cdef hipsparseSpSMDescr wrapper

        if isinstance(pyobj,hipsparseSpSMDescr):
            return pyobj
        else:
            wrapper = hipsparseSpSMDescr.__new__(hipsparseSpSMDescr)
            wrapper.init_from_pyobj(pyobj)
            return wrapper

    def __dealloc__(self):
        # Release the buffer handle
        if self._py_buffer_acquired is True:
            cpython.buffer.PyBuffer_Release(&self._py_buffer)

    def __int__(self):
        """Returns the data's address as long integer.
        """
        return cpython.long.PyLong_FromVoidPtr(self._ptr)

    def __repr__(self):
        return f"<hipsparseSpSMDescr object, ptr: {int(self)}>"

    def as_c_void_p(self):
        """Returns the data's address as `ctypes.c_void_p`
        Note:
            Implemented as function to not collide with
            autogenerated property names.
        """
        return ctypes.c_void_p(int(self))

    @staticmethod
    def PROPERTIES():
        return []

    def __contains__(self,item):
        properties = self.PROPERTIES()
        return item in properties

    def __getitem__(self,item):
        properties = self.PROPERTIES()
        if isinstance(item,int):
            if item < 0 or item >= len(properties):
                raise IndexError()
            return getattr(self,properties[item])
        raise ValueError("'item' type must be 'int'")


hipsparseSpGEMMDescr_t = hipsparseSpGEMMDescr

hipsparseSpSVDescr_t = hipsparseSpSVDescr

hipsparseSpSMDescr_t = hipsparseSpSMDescr

class _hipsparseFormat_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseFormat_t(_hipsparseFormat_t__Base):
    """hipsparseFormat_t

    Attributes:
        HIPSPARSE_FORMAT_CSR:
            (undocumented)
        HIPSPARSE_FORMAT_CSC:
            (undocumented)
        HIPSPARSE_FORMAT_COO:
            (undocumented)
        HIPSPARSE_FORMAT_COO_AOS:
            (undocumented)
        HIPSPARSE_FORMAT_BLOCKED_ELL:
            (undocumented)
    """
    HIPSPARSE_FORMAT_CSR = chipsparse.HIPSPARSE_FORMAT_CSR
    HIPSPARSE_FORMAT_CSC = chipsparse.HIPSPARSE_FORMAT_CSC
    HIPSPARSE_FORMAT_COO = chipsparse.HIPSPARSE_FORMAT_COO
    HIPSPARSE_FORMAT_COO_AOS = chipsparse.HIPSPARSE_FORMAT_COO_AOS
    HIPSPARSE_FORMAT_BLOCKED_ELL = chipsparse.HIPSPARSE_FORMAT_BLOCKED_ELL
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseOrder_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseOrder_t(_hipsparseOrder_t__Base):
    """hipsparseOrder_t

    Attributes:
        HIPSPARSE_ORDER_COLUMN:
            (undocumented)
        HIPSPARSE_ORDER_COL:
            Column major
        HIPSPARSE_ORDER_ROW:
            Row major
    """
    HIPSPARSE_ORDER_COLUMN = chipsparse.HIPSPARSE_ORDER_COLUMN
    HIPSPARSE_ORDER_COL = chipsparse.HIPSPARSE_ORDER_COL
    HIPSPARSE_ORDER_ROW = chipsparse.HIPSPARSE_ORDER_ROW
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseIndexType_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseIndexType_t(_hipsparseIndexType_t__Base):
    """hipsparseIndexType_t

    Attributes:
        HIPSPARSE_INDEX_16U:
            16 bit unsigned integer indices
        HIPSPARSE_INDEX_32I:
            32 bit signed integer indices
        HIPSPARSE_INDEX_64I:
            64 bit signed integer indices
    """
    HIPSPARSE_INDEX_16U = chipsparse.HIPSPARSE_INDEX_16U
    HIPSPARSE_INDEX_32I = chipsparse.HIPSPARSE_INDEX_32I
    HIPSPARSE_INDEX_64I = chipsparse.HIPSPARSE_INDEX_64I
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseSpMVAlg_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseSpMVAlg_t(_hipsparseSpMVAlg_t__Base):
    """hipsparseSpMVAlg_t

    Attributes:
        HIPSPARSE_MV_ALG_DEFAULT:
            (undocumented)
        HIPSPARSE_COOMV_ALG:
            (undocumented)
        HIPSPARSE_CSRMV_ALG1:
            (undocumented)
        HIPSPARSE_CSRMV_ALG2:
            (undocumented)
        HIPSPARSE_SPMV_ALG_DEFAULT:
            (undocumented)
        HIPSPARSE_SPMV_COO_ALG1:
            (undocumented)
        HIPSPARSE_SPMV_CSR_ALG1:
            (undocumented)
        HIPSPARSE_SPMV_CSR_ALG2:
            (undocumented)
        HIPSPARSE_SPMV_COO_ALG2:
            (undocumented)
    """
    HIPSPARSE_MV_ALG_DEFAULT = chipsparse.HIPSPARSE_MV_ALG_DEFAULT
    HIPSPARSE_COOMV_ALG = chipsparse.HIPSPARSE_COOMV_ALG
    HIPSPARSE_CSRMV_ALG1 = chipsparse.HIPSPARSE_CSRMV_ALG1
    HIPSPARSE_CSRMV_ALG2 = chipsparse.HIPSPARSE_CSRMV_ALG2
    HIPSPARSE_SPMV_ALG_DEFAULT = chipsparse.HIPSPARSE_SPMV_ALG_DEFAULT
    HIPSPARSE_SPMV_COO_ALG1 = chipsparse.HIPSPARSE_SPMV_COO_ALG1
    HIPSPARSE_SPMV_CSR_ALG1 = chipsparse.HIPSPARSE_SPMV_CSR_ALG1
    HIPSPARSE_SPMV_CSR_ALG2 = chipsparse.HIPSPARSE_SPMV_CSR_ALG2
    HIPSPARSE_SPMV_COO_ALG2 = chipsparse.HIPSPARSE_SPMV_COO_ALG2
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseSpMMAlg_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseSpMMAlg_t(_hipsparseSpMMAlg_t__Base):
    """hipsparseSpMMAlg_t

    Attributes:
        HIPSPARSE_MM_ALG_DEFAULT:
            (undocumented)
        HIPSPARSE_COOMM_ALG1:
            (undocumented)
        HIPSPARSE_COOMM_ALG2:
            (undocumented)
        HIPSPARSE_COOMM_ALG3:
            (undocumented)
        HIPSPARSE_CSRMM_ALG1:
            (undocumented)
        HIPSPARSE_SPMM_ALG_DEFAULT:
            (undocumented)
        HIPSPARSE_SPMM_COO_ALG1:
            (undocumented)
        HIPSPARSE_SPMM_COO_ALG2:
            (undocumented)
        HIPSPARSE_SPMM_COO_ALG3:
            (undocumented)
        HIPSPARSE_SPMM_COO_ALG4:
            (undocumented)
        HIPSPARSE_SPMM_CSR_ALG1:
            (undocumented)
        HIPSPARSE_SPMM_CSR_ALG2:
            (undocumented)
        HIPSPARSE_SPMM_CSR_ALG3:
            (undocumented)
        HIPSPARSE_SPMM_BLOCKED_ELL_ALG1:
            (undocumented)
    """
    HIPSPARSE_MM_ALG_DEFAULT = chipsparse.HIPSPARSE_MM_ALG_DEFAULT
    HIPSPARSE_COOMM_ALG1 = chipsparse.HIPSPARSE_COOMM_ALG1
    HIPSPARSE_COOMM_ALG2 = chipsparse.HIPSPARSE_COOMM_ALG2
    HIPSPARSE_COOMM_ALG3 = chipsparse.HIPSPARSE_COOMM_ALG3
    HIPSPARSE_CSRMM_ALG1 = chipsparse.HIPSPARSE_CSRMM_ALG1
    HIPSPARSE_SPMM_ALG_DEFAULT = chipsparse.HIPSPARSE_SPMM_ALG_DEFAULT
    HIPSPARSE_SPMM_COO_ALG1 = chipsparse.HIPSPARSE_SPMM_COO_ALG1
    HIPSPARSE_SPMM_COO_ALG2 = chipsparse.HIPSPARSE_SPMM_COO_ALG2
    HIPSPARSE_SPMM_COO_ALG3 = chipsparse.HIPSPARSE_SPMM_COO_ALG3
    HIPSPARSE_SPMM_COO_ALG4 = chipsparse.HIPSPARSE_SPMM_COO_ALG4
    HIPSPARSE_SPMM_CSR_ALG1 = chipsparse.HIPSPARSE_SPMM_CSR_ALG1
    HIPSPARSE_SPMM_CSR_ALG2 = chipsparse.HIPSPARSE_SPMM_CSR_ALG2
    HIPSPARSE_SPMM_CSR_ALG3 = chipsparse.HIPSPARSE_SPMM_CSR_ALG3
    HIPSPARSE_SPMM_BLOCKED_ELL_ALG1 = chipsparse.HIPSPARSE_SPMM_BLOCKED_ELL_ALG1
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseSparseToDenseAlg_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseSparseToDenseAlg_t(_hipsparseSparseToDenseAlg_t__Base):
    """hipsparseSparseToDenseAlg_t

    Attributes:
        HIPSPARSE_SPARSETODENSE_ALG_DEFAULT:
            (undocumented)
    """
    HIPSPARSE_SPARSETODENSE_ALG_DEFAULT = chipsparse.HIPSPARSE_SPARSETODENSE_ALG_DEFAULT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseDenseToSparseAlg_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseDenseToSparseAlg_t(_hipsparseDenseToSparseAlg_t__Base):
    """hipsparseDenseToSparseAlg_t

    Attributes:
        HIPSPARSE_DENSETOSPARSE_ALG_DEFAULT:
            (undocumented)
    """
    HIPSPARSE_DENSETOSPARSE_ALG_DEFAULT = chipsparse.HIPSPARSE_DENSETOSPARSE_ALG_DEFAULT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseSDDMMAlg_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseSDDMMAlg_t(_hipsparseSDDMMAlg_t__Base):
    """hipsparseSDDMMAlg_t

    Attributes:
        HIPSPARSE_SDDMM_ALG_DEFAULT:
            (undocumented)
    """
    HIPSPARSE_SDDMM_ALG_DEFAULT = chipsparse.HIPSPARSE_SDDMM_ALG_DEFAULT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseSpSVAlg_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseSpSVAlg_t(_hipsparseSpSVAlg_t__Base):
    """hipsparseSpSVAlg_t

    Attributes:
        HIPSPARSE_SPSV_ALG_DEFAULT:
            (undocumented)
    """
    HIPSPARSE_SPSV_ALG_DEFAULT = chipsparse.HIPSPARSE_SPSV_ALG_DEFAULT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseSpSMAlg_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseSpSMAlg_t(_hipsparseSpSMAlg_t__Base):
    """hipsparseSpSMAlg_t

    Attributes:
        HIPSPARSE_SPSM_ALG_DEFAULT:
            (undocumented)
    """
    HIPSPARSE_SPSM_ALG_DEFAULT = chipsparse.HIPSPARSE_SPSM_ALG_DEFAULT
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseSpMatAttribute_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseSpMatAttribute_t(_hipsparseSpMatAttribute_t__Base):
    """hipsparseSpMatAttribute_t

    Attributes:
        HIPSPARSE_SPMAT_FILL_MODE:
            Fill mode attribute
        HIPSPARSE_SPMAT_DIAG_TYPE:
            Diag type attribute
    """
    HIPSPARSE_SPMAT_FILL_MODE = chipsparse.HIPSPARSE_SPMAT_FILL_MODE
    HIPSPARSE_SPMAT_DIAG_TYPE = chipsparse.HIPSPARSE_SPMAT_DIAG_TYPE
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


class _hipsparseSpGEMMAlg_t__Base(enum.IntEnum):
    """Empty enum base class that allows subclassing.
    """
    pass
class hipsparseSpGEMMAlg_t(_hipsparseSpGEMMAlg_t__Base):
    """hipsparseSpGEMMAlg_t

    Attributes:
        HIPSPARSE_SPGEMM_DEFAULT:
            (undocumented)
        HIPSPARSE_SPGEMM_CSR_ALG_DETERMINISTIC:
            (undocumented)
        HIPSPARSE_SPGEMM_CSR_ALG_NONDETERMINISTIC:
            (undocumented)
        HIPSPARSE_SPGEMM_ALG1:
            (undocumented)
        HIPSPARSE_SPGEMM_ALG2:
            (undocumented)
        HIPSPARSE_SPGEMM_ALG3:
            (undocumented)
    """
    HIPSPARSE_SPGEMM_DEFAULT = chipsparse.HIPSPARSE_SPGEMM_DEFAULT
    HIPSPARSE_SPGEMM_CSR_ALG_DETERMINISTIC = chipsparse.HIPSPARSE_SPGEMM_CSR_ALG_DETERMINISTIC
    HIPSPARSE_SPGEMM_CSR_ALG_NONDETERMINISTIC = chipsparse.HIPSPARSE_SPGEMM_CSR_ALG_NONDETERMINISTIC
    HIPSPARSE_SPGEMM_ALG1 = chipsparse.HIPSPARSE_SPGEMM_ALG1
    HIPSPARSE_SPGEMM_ALG2 = chipsparse.HIPSPARSE_SPGEMM_ALG2
    HIPSPARSE_SPGEMM_ALG3 = chipsparse.HIPSPARSE_SPGEMM_ALG3
    @staticmethod
    def ctypes_type():
        """The type of the enum constants as ctypes type."""
        return ctypes.c_uint


@cython.embedsignature(True)
def hipsparseCreateSpVec(object spVecDescr, long size, long nnz, object indices, object values, object idxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        size (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        indices (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(idxType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'idxType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateSpVec__retval = hipsparseStatus_t(chipsparse.hipsparseCreateSpVec(
        <void **>hip._util.types.Pointer.fromPyobj(spVecDescr)._ptr,size,nnz,
        <void *>hip._util.types.Pointer.fromPyobj(indices)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(values)._ptr,idxType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateSpVec__retval,)


@cython.embedsignature(True)
def hipsparseCreateConstSpVec(object spVecDescr, long size, long nnz, object indices, object values, object idxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        size (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        indices (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(idxType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'idxType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateConstSpVec__retval = hipsparseStatus_t(chipsparse.hipsparseCreateConstSpVec(
        <const void **>hip._util.types.Pointer.fromPyobj(spVecDescr)._ptr,size,nnz,
        <const void *>hip._util.types.Pointer.fromPyobj(indices)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(values)._ptr,idxType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateConstSpVec__retval,)


@cython.embedsignature(True)
def hipsparseDestroySpVec(object spVecDescr):
    r"""(No short description, might be part of a group.)

    Args:
        spVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroySpVec__retval = hipsparseStatus_t(chipsparse.hipsparseDestroySpVec(
        <const void *>hip._util.types.Pointer.fromPyobj(spVecDescr)._ptr))
    return (_hipsparseDestroySpVec__retval,)


@cython.embedsignature(True)
def hipsparseSpVecGet(object spVecDescr, object size, object nnz, object indices, object values, object idxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        size (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        indices (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpVecGet__retval = hipsparseStatus_t(chipsparse.hipsparseSpVecGet(
        <void *const>hip._util.types.Pointer.fromPyobj(spVecDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(size)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(nnz)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(indices)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(values)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(idxType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseSpVecGet__retval,)


@cython.embedsignature(True)
def hipsparseConstSpVecGet(object spVecDescr, object size, object nnz, object indices, object values, object idxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        size (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        indices (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstSpVecGet__retval = hipsparseStatus_t(chipsparse.hipsparseConstSpVecGet(
        <const void *>hip._util.types.Pointer.fromPyobj(spVecDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(size)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(nnz)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(indices)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(values)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(idxType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseConstSpVecGet__retval,)


@cython.embedsignature(True)
def hipsparseSpVecGetIndexBase(object spVecDescr, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        spVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpVecGetIndexBase__retval = hipsparseStatus_t(chipsparse.hipsparseSpVecGetIndexBase(
        <const void *const>hip._util.types.Pointer.fromPyobj(spVecDescr)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr))
    return (_hipsparseSpVecGetIndexBase__retval,)


@cython.embedsignature(True)
def hipsparseSpVecGetValues(object spVecDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        spVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpVecGetValues__retval = hipsparseStatus_t(chipsparse.hipsparseSpVecGetValues(
        <void *const>hip._util.types.Pointer.fromPyobj(spVecDescr)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseSpVecGetValues__retval,)


@cython.embedsignature(True)
def hipsparseConstSpVecGetValues(object spVecDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        spVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstSpVecGetValues__retval = hipsparseStatus_t(chipsparse.hipsparseConstSpVecGetValues(
        <const void *>hip._util.types.Pointer.fromPyobj(spVecDescr)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseConstSpVecGetValues__retval,)


@cython.embedsignature(True)
def hipsparseSpVecSetValues(object spVecDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        spVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpVecSetValues__retval = hipsparseStatus_t(chipsparse.hipsparseSpVecSetValues(
        <void *>hip._util.types.Pointer.fromPyobj(spVecDescr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseSpVecSetValues__retval,)


@cython.embedsignature(True)
def hipsparseCreateCoo(object spMatDescr, long rows, long cols, long nnz, object cooRowInd, object cooColInd, object cooValues, object cooIdxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        cooRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooIdxType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(cooIdxType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'cooIdxType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateCoo__retval = hipsparseStatus_t(chipsparse.hipsparseCreateCoo(
        <void **>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,rows,cols,nnz,
        <void *>hip._util.types.Pointer.fromPyobj(cooRowInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cooColInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cooValues)._ptr,cooIdxType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateCoo__retval,)


@cython.embedsignature(True)
def hipsparseCreateConstCoo(object spMatDescr, long rows, long cols, long nnz, object cooRowInd, object cooColInd, object cooValues, object cooIdxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        cooRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooIdxType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(cooIdxType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'cooIdxType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateConstCoo__retval = hipsparseStatus_t(chipsparse.hipsparseCreateConstCoo(
        <const void **>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,rows,cols,nnz,
        <const void *>hip._util.types.Pointer.fromPyobj(cooRowInd)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(cooColInd)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(cooValues)._ptr,cooIdxType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateConstCoo__retval,)


@cython.embedsignature(True)
def hipsparseCreateCooAoS(object spMatDescr, long rows, long cols, long nnz, object cooInd, object cooValues, object cooIdxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        cooInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooIdxType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(cooIdxType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'cooIdxType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateCooAoS__retval = hipsparseStatus_t(chipsparse.hipsparseCreateCooAoS(
        <void **>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,rows,cols,nnz,
        <void *>hip._util.types.Pointer.fromPyobj(cooInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cooValues)._ptr,cooIdxType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateCooAoS__retval,)


@cython.embedsignature(True)
def hipsparseCreateCsr(object spMatDescr, long rows, long cols, long nnz, object csrRowOffsets, object csrColInd, object csrValues, object csrRowOffsetsType, object csrColIndType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrRowOffsets (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowOffsetsType (`~.hipsparseIndexType_t`):
            (undocumented)

        csrColIndType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(csrRowOffsetsType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'csrRowOffsetsType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(csrColIndType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'csrColIndType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateCsr__retval = hipsparseStatus_t(chipsparse.hipsparseCreateCsr(
        <void **>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,rows,cols,nnz,
        <void *>hip._util.types.Pointer.fromPyobj(csrRowOffsets)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(csrValues)._ptr,csrRowOffsetsType.value,csrColIndType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateCsr__retval,)


@cython.embedsignature(True)
def hipsparseCreateConstCsr(object spMatDescr, long rows, long cols, long nnz, object csrRowOffsets, object csrColInd, object csrValues, object csrRowOffsetsType, object csrColIndType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        csrRowOffsets (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowOffsetsType (`~.hipsparseIndexType_t`):
            (undocumented)

        csrColIndType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(csrRowOffsetsType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'csrRowOffsetsType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(csrColIndType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'csrColIndType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateConstCsr__retval = hipsparseStatus_t(chipsparse.hipsparseCreateConstCsr(
        <const void **>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,rows,cols,nnz,
        <const void *>hip._util.types.Pointer.fromPyobj(csrRowOffsets)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(csrValues)._ptr,csrRowOffsetsType.value,csrColIndType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateConstCsr__retval,)


@cython.embedsignature(True)
def hipsparseCreateCsc(object spMatDescr, long rows, long cols, long nnz, object cscColOffsets, object cscRowInd, object cscValues, object cscColOffsetsType, object cscRowIndType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        cscColOffsets (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColOffsetsType (`~.hipsparseIndexType_t`):
            (undocumented)

        cscRowIndType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(cscColOffsetsType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'cscColOffsetsType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(cscRowIndType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'cscRowIndType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateCsc__retval = hipsparseStatus_t(chipsparse.hipsparseCreateCsc(
        <void **>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,rows,cols,nnz,
        <void *>hip._util.types.Pointer.fromPyobj(cscColOffsets)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cscValues)._ptr,cscColOffsetsType.value,cscRowIndType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateCsc__retval,)


@cython.embedsignature(True)
def hipsparseCreateConstCsc(object spMatDescr, long rows, long cols, long nnz, object cscColOffsets, object cscRowInd, object cscValues, object cscColOffsetsType, object cscRowIndType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        nnz (`~.int`):
            (undocumented)

        cscColOffsets (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColOffsetsType (`~.hipsparseIndexType_t`):
            (undocumented)

        cscRowIndType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(cscColOffsetsType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'cscColOffsetsType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(cscRowIndType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'cscRowIndType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateConstCsc__retval = hipsparseStatus_t(chipsparse.hipsparseCreateConstCsc(
        <const void **>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,rows,cols,nnz,
        <const void *>hip._util.types.Pointer.fromPyobj(cscColOffsets)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(cscValues)._ptr,cscColOffsetsType.value,cscRowIndType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateConstCsc__retval,)


@cython.embedsignature(True)
def hipsparseCreateBlockedEll(object spMatDescr, long rows, long cols, long ellBlockSize, long ellCols, object ellColInd, object ellValue, object ellIdxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        ellBlockSize (`~.int`):
            (undocumented)

        ellCols (`~.int`):
            (undocumented)

        ellColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellValue (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellIdxType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(ellIdxType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'ellIdxType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateBlockedEll__retval = hipsparseStatus_t(chipsparse.hipsparseCreateBlockedEll(
        <void **>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,rows,cols,ellBlockSize,ellCols,
        <void *>hip._util.types.Pointer.fromPyobj(ellColInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(ellValue)._ptr,ellIdxType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateBlockedEll__retval,)


@cython.embedsignature(True)
def hipsparseCreateConstBlockedEll(object spMatDescr, long rows, long cols, long ellBlockSize, long ellCols, object ellColInd, object ellValue, object ellIdxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        ellBlockSize (`~.int`):
            (undocumented)

        ellCols (`~.int`):
            (undocumented)

        ellColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellValue (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellIdxType (`~.hipsparseIndexType_t`):
            (undocumented)

        idxBase (`~.hipsparseIndexBase_t`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(ellIdxType,_hipsparseIndexType_t__Base):
        raise TypeError("argument 'ellIdxType' must be of type '_hipsparseIndexType_t__Base'")                    
    if not isinstance(idxBase,_hipsparseIndexBase_t__Base):
        raise TypeError("argument 'idxBase' must be of type '_hipsparseIndexBase_t__Base'")                    
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateConstBlockedEll__retval = hipsparseStatus_t(chipsparse.hipsparseCreateConstBlockedEll(
        <const void **>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,rows,cols,ellBlockSize,ellCols,
        <const void *>hip._util.types.Pointer.fromPyobj(ellColInd)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(ellValue)._ptr,ellIdxType.value,idxBase.value,valueType.value))
    return (_hipsparseCreateConstBlockedEll__retval,)


@cython.embedsignature(True)
def hipsparseDestroySpMat(object spMatDescr):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroySpMat__retval = hipsparseStatus_t(chipsparse.hipsparseDestroySpMat(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr))
    return (_hipsparseDestroySpMat__retval,)


@cython.embedsignature(True)
def hipsparseCooGet(object spMatDescr, object rows, object cols, object nnz, object cooRowInd, object cooColInd, object cooValues, object idxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCooGet__retval = hipsparseStatus_t(chipsparse.hipsparseCooGet(
        <void *const>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(nnz)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(cooRowInd)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(cooColInd)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(cooValues)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(idxType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseCooGet__retval,)


@cython.embedsignature(True)
def hipsparseConstCooGet(object spMatDescr, object rows, object cols, object nnz, object cooRowInd, object cooColInd, object cooValues, object idxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstCooGet__retval = hipsparseStatus_t(chipsparse.hipsparseConstCooGet(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(nnz)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(cooRowInd)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(cooColInd)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(cooValues)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(idxType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseConstCooGet__retval,)


@cython.embedsignature(True)
def hipsparseCooAoSGet(object spMatDescr, object rows, object cols, object nnz, object cooInd, object cooValues, object idxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCooAoSGet__retval = hipsparseStatus_t(chipsparse.hipsparseCooAoSGet(
        <void *const>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(nnz)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(cooInd)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(cooValues)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(idxType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseCooAoSGet__retval,)


@cython.embedsignature(True)
def hipsparseCsrGet(object spMatDescr, object rows, object cols, object nnz, object csrRowOffsets, object csrColInd, object csrValues, object csrRowOffsetsType, object csrColIndType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowOffsets (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowOffsetsType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCsrGet__retval = hipsparseStatus_t(chipsparse.hipsparseCsrGet(
        <void *const>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(nnz)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(csrRowOffsets)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(csrValues)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(csrRowOffsetsType)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(csrColIndType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseCsrGet__retval,)


@cython.embedsignature(True)
def hipsparseConstCsrGet(object spMatDescr, object rows, object cols, object nnz, object csrRowOffsets, object csrColInd, object csrValues, object csrRowOffsetsType, object csrColIndType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowOffsets (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowOffsetsType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColIndType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstCsrGet__retval = hipsparseStatus_t(chipsparse.hipsparseConstCsrGet(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(nnz)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(csrRowOffsets)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(csrValues)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(csrRowOffsetsType)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(csrColIndType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseConstCsrGet__retval,)


@cython.embedsignature(True)
def hipsparseCscGet(object spMatDescr, object rows, object cols, object nnz, object cscColOffsets, object cscRowInd, object cscValues, object cscColOffsetsType, object cscRowIndType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColOffsets (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColOffsetsType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowIndType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCscGet__retval = hipsparseStatus_t(chipsparse.hipsparseCscGet(
        <void *const>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(nnz)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(cscColOffsets)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(cscValues)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(cscColOffsetsType)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(cscRowIndType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseCscGet__retval,)


@cython.embedsignature(True)
def hipsparseConstCscGet(object spMatDescr, object rows, object cols, object nnz, object cscColOffsets, object cscRowInd, object cscValues, object cscColOffsetsType, object cscRowIndType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColOffsets (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColOffsetsType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowIndType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstCscGet__retval = hipsparseStatus_t(chipsparse.hipsparseConstCscGet(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(nnz)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(cscColOffsets)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(cscValues)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(cscColOffsetsType)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(cscRowIndType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseConstCscGet__retval,)


@cython.embedsignature(True)
def hipsparseBlockedEllGet(object spMatDescr, object rows, object cols, object ellBlockSize, object ellCols, object ellColInd, object ellValue, object ellIdxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellBlockSize (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellCols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellValue (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellIdxType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseBlockedEllGet__retval = hipsparseStatus_t(chipsparse.hipsparseBlockedEllGet(
        <void *const>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(ellBlockSize)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(ellCols)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(ellColInd)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(ellValue)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(ellIdxType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseBlockedEllGet__retval,)


@cython.embedsignature(True)
def hipsparseConstBlockedEllGet(object spMatDescr, object rows, object cols, object ellBlockSize, object ellCols, object ellColInd, object ellValue, object ellIdxType, object idxBase, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellBlockSize (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellCols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellValue (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ellIdxType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstBlockedEllGet__retval = hipsparseStatus_t(chipsparse.hipsparseConstBlockedEllGet(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(ellBlockSize)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(ellCols)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(ellColInd)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(ellValue)._ptr,
        <chipsparse.hipsparseIndexType_t *>hip._util.types.Pointer.fromPyobj(ellIdxType)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseConstBlockedEllGet__retval,)


@cython.embedsignature(True)
def hipsparseCsrSetPointers(object spMatDescr, object csrRowOffsets, object csrColInd, object csrValues):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrRowOffsets (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        csrValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCsrSetPointers__retval = hipsparseStatus_t(chipsparse.hipsparseCsrSetPointers(
        <void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(csrRowOffsets)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(csrColInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(csrValues)._ptr))
    return (_hipsparseCsrSetPointers__retval,)


@cython.embedsignature(True)
def hipsparseCscSetPointers(object spMatDescr, object cscColOffsets, object cscRowInd, object cscValues):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscColOffsets (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cscValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCscSetPointers__retval = hipsparseStatus_t(chipsparse.hipsparseCscSetPointers(
        <void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cscColOffsets)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cscRowInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cscValues)._ptr))
    return (_hipsparseCscSetPointers__retval,)


@cython.embedsignature(True)
def hipsparseCooSetPointers(object spMatDescr, object cooRowInd, object cooColInd, object cooValues):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooRowInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooColInd (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cooValues (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseCooSetPointers__retval = hipsparseStatus_t(chipsparse.hipsparseCooSetPointers(
        <void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cooRowInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cooColInd)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(cooValues)._ptr))
    return (_hipsparseCooSetPointers__retval,)


@cython.embedsignature(True)
def hipsparseSpMatGetSize(object spMatDescr, object rows, object cols, object nnz):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        nnz (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpMatGetSize__retval = hipsparseStatus_t(chipsparse.hipsparseSpMatGetSize(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(nnz)._ptr))
    return (_hipsparseSpMatGetSize__retval,)


@cython.embedsignature(True)
def hipsparseSpMatGetFormat(object spMatDescr, object format):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        format (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpMatGetFormat__retval = hipsparseStatus_t(chipsparse.hipsparseSpMatGetFormat(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <chipsparse.hipsparseFormat_t *>hip._util.types.Pointer.fromPyobj(format)._ptr))
    return (_hipsparseSpMatGetFormat__retval,)


@cython.embedsignature(True)
def hipsparseSpMatGetIndexBase(object spMatDescr, object idxBase):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        idxBase (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpMatGetIndexBase__retval = hipsparseStatus_t(chipsparse.hipsparseSpMatGetIndexBase(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <chipsparse.hipsparseIndexBase_t *>hip._util.types.Pointer.fromPyobj(idxBase)._ptr))
    return (_hipsparseSpMatGetIndexBase__retval,)


@cython.embedsignature(True)
def hipsparseSpMatGetValues(object spMatDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpMatGetValues__retval = hipsparseStatus_t(chipsparse.hipsparseSpMatGetValues(
        <void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseSpMatGetValues__retval,)


@cython.embedsignature(True)
def hipsparseConstSpMatGetValues(object spMatDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstSpMatGetValues__retval = hipsparseStatus_t(chipsparse.hipsparseConstSpMatGetValues(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseConstSpMatGetValues__retval,)


@cython.embedsignature(True)
def hipsparseSpMatSetValues(object spMatDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpMatSetValues__retval = hipsparseStatus_t(chipsparse.hipsparseSpMatSetValues(
        <void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseSpMatSetValues__retval,)


@cython.embedsignature(True)
def hipsparseSpMatGetStridedBatch(object spMatDescr, object batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseSpMatGetStridedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseSpMatGetStridedBatch(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(batchCount)._ptr))
    return (_hipsparseSpMatGetStridedBatch__retval,)


@cython.embedsignature(True)
def hipsparseSpMatSetStridedBatch(object spMatDescr, int batchCount):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)
    """
    _hipsparseSpMatSetStridedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseSpMatSetStridedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,batchCount))
    return (_hipsparseSpMatSetStridedBatch__retval,)


@cython.embedsignature(True)
def hipsparseCooSetStridedBatch(object spMatDescr, int batchCount, long batchStride):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        batchStride (`~.int`):
            (undocumented)
    """
    _hipsparseCooSetStridedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseCooSetStridedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,batchCount,batchStride))
    return (_hipsparseCooSetStridedBatch__retval,)


@cython.embedsignature(True)
def hipsparseCsrSetStridedBatch(object spMatDescr, int batchCount, long offsetsBatchStride, long columnsValuesBatchStride):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        offsetsBatchStride (`~.int`):
            (undocumented)

        columnsValuesBatchStride (`~.int`):
            (undocumented)
    """
    _hipsparseCsrSetStridedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseCsrSetStridedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,batchCount,offsetsBatchStride,columnsValuesBatchStride))
    return (_hipsparseCsrSetStridedBatch__retval,)


@cython.embedsignature(True)
def hipsparseSpMatGetAttribute(object spMatDescr, object attribute, object data, unsigned long dataSize):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        attribute (`~.hipsparseSpMatAttribute_t`):
            (undocumented)

        data (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dataSize (`~.int`):
            (undocumented)
    """
    if not isinstance(attribute,_hipsparseSpMatAttribute_t__Base):
        raise TypeError("argument 'attribute' must be of type '_hipsparseSpMatAttribute_t__Base'")
    _hipsparseSpMatGetAttribute__retval = hipsparseStatus_t(chipsparse.hipsparseSpMatGetAttribute(
        <const void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,attribute.value,
        <void *>hip._util.types.Pointer.fromPyobj(data)._ptr,dataSize))
    return (_hipsparseSpMatGetAttribute__retval,)


@cython.embedsignature(True)
def hipsparseSpMatSetAttribute(object spMatDescr, object attribute, object data, unsigned long dataSize):
    r"""(No short description, might be part of a group.)

    Args:
        spMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        attribute (`~.hipsparseSpMatAttribute_t`):
            (undocumented)

        data (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        dataSize (`~.int`):
            (undocumented)
    """
    if not isinstance(attribute,_hipsparseSpMatAttribute_t__Base):
        raise TypeError("argument 'attribute' must be of type '_hipsparseSpMatAttribute_t__Base'")
    _hipsparseSpMatSetAttribute__retval = hipsparseStatus_t(chipsparse.hipsparseSpMatSetAttribute(
        <void *>hip._util.types.Pointer.fromPyobj(spMatDescr)._ptr,attribute.value,
        <const void *>hip._util.types.Pointer.fromPyobj(data)._ptr,dataSize))
    return (_hipsparseSpMatSetAttribute__retval,)


@cython.embedsignature(True)
def hipsparseCreateDnVec(object dnVecDescr, long size, object values, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        dnVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        size (`~.int`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateDnVec__retval = hipsparseStatus_t(chipsparse.hipsparseCreateDnVec(
        <void **>hip._util.types.Pointer.fromPyobj(dnVecDescr)._ptr,size,
        <void *>hip._util.types.Pointer.fromPyobj(values)._ptr,valueType.value))
    return (_hipsparseCreateDnVec__retval,)


@cython.embedsignature(True)
def hipsparseCreateConstDnVec(object dnVecDescr, long size, object values, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        dnVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        size (`~.int`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)
    """
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")
    _hipsparseCreateConstDnVec__retval = hipsparseStatus_t(chipsparse.hipsparseCreateConstDnVec(
        <const void **>hip._util.types.Pointer.fromPyobj(dnVecDescr)._ptr,size,
        <const void *>hip._util.types.Pointer.fromPyobj(values)._ptr,valueType.value))
    return (_hipsparseCreateConstDnVec__retval,)


@cython.embedsignature(True)
def hipsparseDestroyDnVec(object dnVecDescr):
    r"""(No short description, might be part of a group.)

    Args:
        dnVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyDnVec__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyDnVec(
        <const void *>hip._util.types.Pointer.fromPyobj(dnVecDescr)._ptr))
    return (_hipsparseDestroyDnVec__retval,)


@cython.embedsignature(True)
def hipsparseDnVecGet(object dnVecDescr, object size, object values, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        dnVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        size (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDnVecGet__retval = hipsparseStatus_t(chipsparse.hipsparseDnVecGet(
        <void *const>hip._util.types.Pointer.fromPyobj(dnVecDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(size)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(values)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseDnVecGet__retval,)


@cython.embedsignature(True)
def hipsparseConstDnVecGet(object dnVecDescr, object size, object values, object valueType):
    r"""(No short description, might be part of a group.)

    Args:
        dnVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        size (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstDnVecGet__retval = hipsparseStatus_t(chipsparse.hipsparseConstDnVecGet(
        <const void *>hip._util.types.Pointer.fromPyobj(dnVecDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(size)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(values)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr))
    return (_hipsparseConstDnVecGet__retval,)


@cython.embedsignature(True)
def hipsparseDnVecGetValues(object dnVecDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        dnVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDnVecGetValues__retval = hipsparseStatus_t(chipsparse.hipsparseDnVecGetValues(
        <void *const>hip._util.types.Pointer.fromPyobj(dnVecDescr)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseDnVecGetValues__retval,)


@cython.embedsignature(True)
def hipsparseConstDnVecGetValues(object dnVecDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        dnVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstDnVecGetValues__retval = hipsparseStatus_t(chipsparse.hipsparseConstDnVecGetValues(
        <const void *>hip._util.types.Pointer.fromPyobj(dnVecDescr)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseConstDnVecGetValues__retval,)


@cython.embedsignature(True)
def hipsparseDnVecSetValues(object dnVecDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        dnVecDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDnVecSetValues__retval = hipsparseStatus_t(chipsparse.hipsparseDnVecSetValues(
        <void *>hip._util.types.Pointer.fromPyobj(dnVecDescr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseDnVecSetValues__retval,)


@cython.embedsignature(True)
def hipsparseCreateDnMat(object dnMatDescr, long rows, long cols, long ld, object values, object valueType, object order):
    r"""(No short description, might be part of a group.)

    Args:
        dnMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        ld (`~.int`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)

        order (`~.hipsparseOrder_t`):
            (undocumented)
    """
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")                    
    if not isinstance(order,_hipsparseOrder_t__Base):
        raise TypeError("argument 'order' must be of type '_hipsparseOrder_t__Base'")
    _hipsparseCreateDnMat__retval = hipsparseStatus_t(chipsparse.hipsparseCreateDnMat(
        <void **>hip._util.types.Pointer.fromPyobj(dnMatDescr)._ptr,rows,cols,ld,
        <void *>hip._util.types.Pointer.fromPyobj(values)._ptr,valueType.value,order.value))
    return (_hipsparseCreateDnMat__retval,)


@cython.embedsignature(True)
def hipsparseCreateConstDnMat(object dnMatDescr, long rows, long cols, long ld, object values, object valueType, object order):
    r"""(No short description, might be part of a group.)

    Args:
        dnMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.int`):
            (undocumented)

        cols (`~.int`):
            (undocumented)

        ld (`~.int`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hipDataType`):
            (undocumented)

        order (`~.hipsparseOrder_t`):
            (undocumented)
    """
    if not isinstance(valueType,_hipDataType__Base):
        raise TypeError("argument 'valueType' must be of type '_hipDataType__Base'")                    
    if not isinstance(order,_hipsparseOrder_t__Base):
        raise TypeError("argument 'order' must be of type '_hipsparseOrder_t__Base'")
    _hipsparseCreateConstDnMat__retval = hipsparseStatus_t(chipsparse.hipsparseCreateConstDnMat(
        <const void **>hip._util.types.Pointer.fromPyobj(dnMatDescr)._ptr,rows,cols,ld,
        <const void *>hip._util.types.Pointer.fromPyobj(values)._ptr,valueType.value,order.value))
    return (_hipsparseCreateConstDnMat__retval,)


@cython.embedsignature(True)
def hipsparseDestroyDnMat(object dnMatDescr):
    r"""(No short description, might be part of a group.)

    Args:
        dnMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDestroyDnMat__retval = hipsparseStatus_t(chipsparse.hipsparseDestroyDnMat(
        <const void *>hip._util.types.Pointer.fromPyobj(dnMatDescr)._ptr))
    return (_hipsparseDestroyDnMat__retval,)


@cython.embedsignature(True)
def hipsparseDnMatGet(object dnMatDescr, object rows, object cols, object ld, object values, object valueType, object order):
    r"""(No short description, might be part of a group.)

    Args:
        dnMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ld (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        order (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDnMatGet__retval = hipsparseStatus_t(chipsparse.hipsparseDnMatGet(
        <void *const>hip._util.types.Pointer.fromPyobj(dnMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(ld)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(values)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr,
        <chipsparse.hipsparseOrder_t *>hip._util.types.Pointer.fromPyobj(order)._ptr))
    return (_hipsparseDnMatGet__retval,)


@cython.embedsignature(True)
def hipsparseConstDnMatGet(object dnMatDescr, object rows, object cols, object ld, object values, object valueType, object order):
    r"""(No short description, might be part of a group.)

    Args:
        dnMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        rows (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        cols (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        ld (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        valueType (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        order (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstDnMatGet__retval = hipsparseStatus_t(chipsparse.hipsparseConstDnMatGet(
        <const void *>hip._util.types.Pointer.fromPyobj(dnMatDescr)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(rows)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(cols)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(ld)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(values)._ptr,
        <chipsparse.hipDataType *>hip._util.types.Pointer.fromPyobj(valueType)._ptr,
        <chipsparse.hipsparseOrder_t *>hip._util.types.Pointer.fromPyobj(order)._ptr))
    return (_hipsparseConstDnMatGet__retval,)


@cython.embedsignature(True)
def hipsparseDnMatGetValues(object dnMatDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        dnMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDnMatGetValues__retval = hipsparseStatus_t(chipsparse.hipsparseDnMatGetValues(
        <void *const>hip._util.types.Pointer.fromPyobj(dnMatDescr)._ptr,
        <void **>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseDnMatGetValues__retval,)


@cython.embedsignature(True)
def hipsparseConstDnMatGetValues(object dnMatDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        dnMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseConstDnMatGetValues__retval = hipsparseStatus_t(chipsparse.hipsparseConstDnMatGetValues(
        <const void *>hip._util.types.Pointer.fromPyobj(dnMatDescr)._ptr,
        <const void **>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseConstDnMatGetValues__retval,)


@cython.embedsignature(True)
def hipsparseDnMatSetValues(object dnMatDescr, object values):
    r"""(No short description, might be part of a group.)

    Args:
        dnMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        values (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDnMatSetValues__retval = hipsparseStatus_t(chipsparse.hipsparseDnMatSetValues(
        <void *>hip._util.types.Pointer.fromPyobj(dnMatDescr)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(values)._ptr))
    return (_hipsparseDnMatSetValues__retval,)


@cython.embedsignature(True)
def hipsparseDnMatGetStridedBatch(object dnMatDescr, object batchCount, object batchStride):
    r"""(No short description, might be part of a group.)

    Args:
        dnMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchStride (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseDnMatGetStridedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseDnMatGetStridedBatch(
        <const void *>hip._util.types.Pointer.fromPyobj(dnMatDescr)._ptr,
        <int *>hip._util.types.Pointer.fromPyobj(batchCount)._ptr,
        <long *>hip._util.types.Pointer.fromPyobj(batchStride)._ptr))
    return (_hipsparseDnMatGetStridedBatch__retval,)


@cython.embedsignature(True)
def hipsparseDnMatSetStridedBatch(object dnMatDescr, int batchCount, long batchStride):
    r"""(No short description, might be part of a group.)

    Args:
        dnMatDescr (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        batchCount (`~.int`):
            (undocumented)

        batchStride (`~.int`):
            (undocumented)
    """
    _hipsparseDnMatSetStridedBatch__retval = hipsparseStatus_t(chipsparse.hipsparseDnMatSetStridedBatch(
        <void *>hip._util.types.Pointer.fromPyobj(dnMatDescr)._ptr,batchCount,batchStride))
    return (_hipsparseDnMatSetStridedBatch__retval,)


@cython.embedsignature(True)
def hipsparseAxpby(object handle, object alpha, object vecX, object beta, object vecY):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecX (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecY (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseAxpby__retval = hipsparseStatus_t(chipsparse.hipsparseAxpby(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(vecX)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(vecY)._ptr))
    return (_hipsparseAxpby__retval,)


@cython.embedsignature(True)
def hipsparseGather(object handle, object vecY, object vecX):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecY (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecX (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseGather__retval = hipsparseStatus_t(chipsparse.hipsparseGather(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(vecY)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(vecX)._ptr))
    return (_hipsparseGather__retval,)


@cython.embedsignature(True)
def hipsparseScatter(object handle, object vecX, object vecY):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecX (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecY (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseScatter__retval = hipsparseStatus_t(chipsparse.hipsparseScatter(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(vecX)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(vecY)._ptr))
    return (_hipsparseScatter__retval,)


@cython.embedsignature(True)
def hipsparseRot(object handle, object c_coeff, object s_coeff, object vecX, object vecY):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        c_coeff (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        s_coeff (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecX (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecY (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    _hipsparseRot__retval = hipsparseStatus_t(chipsparse.hipsparseRot(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(c_coeff)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(s_coeff)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(vecX)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(vecY)._ptr))
    return (_hipsparseRot__retval,)


@cython.embedsignature(True)
def hipsparseSparseToDense_bufferSize(object handle, object matA, object matB, object alg, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alg (`~.hipsparseSparseToDenseAlg_t`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(alg,_hipsparseSparseToDenseAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSparseToDenseAlg_t__Base'")
    _hipsparseSparseToDense_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSparseToDense_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,alg.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSparseToDense_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSparseToDense(object handle, object matA, object matB, object alg, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alg (`~.hipsparseSparseToDenseAlg_t`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(alg,_hipsparseSparseToDenseAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSparseToDenseAlg_t__Base'")
    _hipsparseSparseToDense__retval = hipsparseStatus_t(chipsparse.hipsparseSparseToDense(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,alg.value,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseSparseToDense__retval,)


@cython.embedsignature(True)
def hipsparseDenseToSparse_bufferSize(object handle, object matA, object matB, object alg, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alg (`~.hipsparseDenseToSparseAlg_t`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(alg,_hipsparseDenseToSparseAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseDenseToSparseAlg_t__Base'")
    _hipsparseDenseToSparse_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseDenseToSparse_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,alg.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseDenseToSparse_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseDenseToSparse_analysis(object handle, object matA, object matB, object alg, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alg (`~.hipsparseDenseToSparseAlg_t`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(alg,_hipsparseDenseToSparseAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseDenseToSparseAlg_t__Base'")
    _hipsparseDenseToSparse_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseDenseToSparse_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,alg.value,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseDenseToSparse_analysis__retval,)


@cython.embedsignature(True)
def hipsparseDenseToSparse_convert(object handle, object matA, object matB, object alg, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alg (`~.hipsparseDenseToSparseAlg_t`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(alg,_hipsparseDenseToSparseAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseDenseToSparseAlg_t__Base'")
    _hipsparseDenseToSparse_convert__retval = hipsparseStatus_t(chipsparse.hipsparseDenseToSparse_convert(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,alg.value,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseDenseToSparse_convert__retval,)


@cython.embedsignature(True)
def hipsparseSpVV_bufferSize(object handle, object opX, object vecX, object vecY, object result, object computeType, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opX (`~.hipsparseOperation_t`):
            (undocumented)

        vecX (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecY (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opX' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")
    _hipsparseSpVV_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSpVV_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opX.value,
        <const void *>hip._util.types.Pointer.fromPyobj(vecX)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(vecY)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,computeType.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpVV_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSpVV(object handle, object opX, object vecX, object vecY, object result, object computeType, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opX (`~.hipsparseOperation_t`):
            (undocumented)

        vecX (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecY (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        result (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opX,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opX' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")
    _hipsparseSpVV__retval = hipsparseStatus_t(chipsparse.hipsparseSpVV(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opX.value,
        <const void *>hip._util.types.Pointer.fromPyobj(vecX)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(vecY)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(result)._ptr,computeType.value,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseSpVV__retval,)


@cython.embedsignature(True)
def hipsparseSpMV_bufferSize(object handle, object opA, object alpha, object matA, object vecX, object beta, object vecY, object computeType, object alg, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecX (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecY (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpMVAlg_t`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpMVAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpMVAlg_t__Base'")
    _hipsparseSpMV_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSpMV_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(vecX)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(vecY)._ptr,computeType.value,alg.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpMV_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSpMV_preprocess(object handle, object opA, object alpha, object matA, object vecX, object beta, object vecY, object computeType, object alg, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecX (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecY (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpMVAlg_t`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpMVAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpMVAlg_t__Base'")
    _hipsparseSpMV_preprocess__retval = hipsparseStatus_t(chipsparse.hipsparseSpMV_preprocess(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(vecX)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(vecY)._ptr,computeType.value,alg.value,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseSpMV_preprocess__retval,)


@cython.embedsignature(True)
def hipsparseSpMV(object handle, object opA, object alpha, object matA, object vecX, object beta, object vecY, object computeType, object alg, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecX (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        vecY (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpMVAlg_t`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpMVAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpMVAlg_t__Base'")
    _hipsparseSpMV__retval = hipsparseStatus_t(chipsparse.hipsparseSpMV(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(vecX)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(vecY)._ptr,computeType.value,alg.value,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseSpMV__retval,)


@cython.embedsignature(True)
def hipsparseSpMM_bufferSize(object handle, object opA, object opB, object alpha, object matA, object matB, object beta, object matC, object computeType, object alg, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpMMAlg_t`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpMMAlg_t__Base'")
    _hipsparseSpMM_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSpMM_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(matC)._ptr,computeType.value,alg.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpMM_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSpMM_preprocess(object handle, object opA, object opB, object alpha, object matA, object matB, object beta, object matC, object computeType, object alg, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpMMAlg_t`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpMMAlg_t__Base'")
    _hipsparseSpMM_preprocess__retval = hipsparseStatus_t(chipsparse.hipsparseSpMM_preprocess(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(matC)._ptr,computeType.value,alg.value,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseSpMM_preprocess__retval,)


@cython.embedsignature(True)
def hipsparseSpMM(object handle, object opA, object opB, object alpha, object matA, object matB, object beta, object matC, object computeType, object alg, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpMMAlg_t`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpMMAlg_t__Base'")
    _hipsparseSpMM__retval = hipsparseStatus_t(chipsparse.hipsparseSpMM(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(matC)._ptr,computeType.value,alg.value,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseSpMM__retval,)


@cython.embedsignature(True)
def hipsparseSpGEMM_createDescr():
    r"""(No short description, might be part of a group.)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * descr (`~.hipsparseSpGEMMDescr`):
            (undocumented)
    """
    descr = hipsparseSpGEMMDescr.fromPtr(NULL)
    _hipsparseSpGEMM_createDescr__retval = hipsparseStatus_t(chipsparse.hipsparseSpGEMM_createDescr(<chipsparse.hipsparseSpGEMMDescr**>&descr._ptr))
    return (_hipsparseSpGEMM_createDescr__retval,None if descr._ptr == NULL else descr)


@cython.embedsignature(True)
def hipsparseSpGEMM_destroyDescr(object descr):
    r"""(No short description, might be part of a group.)

    Args:
        descr (`~.hipsparseSpGEMMDescr`/`~.object`):
            (undocumented)
    """
    _hipsparseSpGEMM_destroyDescr__retval = hipsparseStatus_t(chipsparse.hipsparseSpGEMM_destroyDescr(
        hipsparseSpGEMMDescr.fromPyobj(descr).getElementPtr()))
    return (_hipsparseSpGEMM_destroyDescr__retval,)


@cython.embedsignature(True)
def hipsparseSpGEMM_workEstimation(object handle, object opA, object opB, object alpha, object matA, object matB, object beta, object matC, object computeType, object alg, object spgemmDescr, object bufferSize1, object externalBuffer1):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpGEMMAlg_t`):
            (undocumented)

        spgemmDescr (`~.hipsparseSpGEMMDescr`/`~.object`):
            (undocumented)

        bufferSize1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        externalBuffer1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpGEMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpGEMMAlg_t__Base'")
    _hipsparseSpGEMM_workEstimation__retval = hipsparseStatus_t(chipsparse.hipsparseSpGEMM_workEstimation(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matC)._ptr,computeType.value,alg.value,
        hipsparseSpGEMMDescr.fromPyobj(spgemmDescr).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(bufferSize1)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer1)._ptr))
    return (_hipsparseSpGEMM_workEstimation__retval,)


@cython.embedsignature(True)
def hipsparseSpGEMM_compute(object handle, object opA, object opB, object alpha, object matA, object matB, object beta, object matC, object computeType, object alg, object spgemmDescr, object bufferSize2, object externalBuffer2):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpGEMMAlg_t`):
            (undocumented)

        spgemmDescr (`~.hipsparseSpGEMMDescr`/`~.object`):
            (undocumented)

        bufferSize2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        externalBuffer2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpGEMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpGEMMAlg_t__Base'")
    _hipsparseSpGEMM_compute__retval = hipsparseStatus_t(chipsparse.hipsparseSpGEMM_compute(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matC)._ptr,computeType.value,alg.value,
        hipsparseSpGEMMDescr.fromPyobj(spgemmDescr).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(bufferSize2)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer2)._ptr))
    return (_hipsparseSpGEMM_compute__retval,)


@cython.embedsignature(True)
def hipsparseSpGEMM_copy(object handle, object opA, object opB, object alpha, object matA, object matB, object beta, object matC, object computeType, object alg, object spgemmDescr):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpGEMMAlg_t`):
            (undocumented)

        spgemmDescr (`~.hipsparseSpGEMMDescr`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpGEMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpGEMMAlg_t__Base'")
    _hipsparseSpGEMM_copy__retval = hipsparseStatus_t(chipsparse.hipsparseSpGEMM_copy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matC)._ptr,computeType.value,alg.value,
        hipsparseSpGEMMDescr.fromPyobj(spgemmDescr).getElementPtr()))
    return (_hipsparseSpGEMM_copy__retval,)


@cython.embedsignature(True)
def hipsparseSpGEMMreuse_workEstimation(object handle, object opA, object opB, object matA, object matB, object matC, object alg, object spgemmDescr, object bufferSize1, object externalBuffer1):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alg (`~.hipsparseSpGEMMAlg_t`):
            (undocumented)

        spgemmDescr (`~.hipsparseSpGEMMDescr`/`~.object`):
            (undocumented)

        bufferSize1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        externalBuffer1 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(alg,_hipsparseSpGEMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpGEMMAlg_t__Base'")
    _hipsparseSpGEMMreuse_workEstimation__retval = hipsparseStatus_t(chipsparse.hipsparseSpGEMMreuse_workEstimation(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matC)._ptr,alg.value,
        hipsparseSpGEMMDescr.fromPyobj(spgemmDescr).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(bufferSize1)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer1)._ptr))
    return (_hipsparseSpGEMMreuse_workEstimation__retval,)


@cython.embedsignature(True)
def hipsparseSpGEMMreuse_nnz(object handle, object opA, object opB, object matA, object matB, object matC, object alg, object spgemmDescr, object bufferSize2, object externalBuffer2, object bufferSize3, object externalBuffer3, object bufferSize4, object externalBuffer4):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alg (`~.hipsparseSpGEMMAlg_t`):
            (undocumented)

        spgemmDescr (`~.hipsparseSpGEMMDescr`/`~.object`):
            (undocumented)

        bufferSize2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        externalBuffer2 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bufferSize3 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        externalBuffer3 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        bufferSize4 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        externalBuffer4 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(alg,_hipsparseSpGEMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpGEMMAlg_t__Base'")
    _hipsparseSpGEMMreuse_nnz__retval = hipsparseStatus_t(chipsparse.hipsparseSpGEMMreuse_nnz(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matC)._ptr,alg.value,
        hipsparseSpGEMMDescr.fromPyobj(spgemmDescr).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(bufferSize2)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer2)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(bufferSize3)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer3)._ptr,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(bufferSize4)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer4)._ptr))
    return (_hipsparseSpGEMMreuse_nnz__retval,)


@cython.embedsignature(True)
def hipsparseSpGEMMreuse_copy(object handle, object opA, object opB, object matA, object matB, object matC, object alg, object spgemmDescr, object bufferSize5, object externalBuffer5):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        alg (`~.hipsparseSpGEMMAlg_t`):
            (undocumented)

        spgemmDescr (`~.hipsparseSpGEMMDescr`/`~.object`):
            (undocumented)

        bufferSize5 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        externalBuffer5 (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(alg,_hipsparseSpGEMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpGEMMAlg_t__Base'")
    _hipsparseSpGEMMreuse_copy__retval = hipsparseStatus_t(chipsparse.hipsparseSpGEMMreuse_copy(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matC)._ptr,alg.value,
        hipsparseSpGEMMDescr.fromPyobj(spgemmDescr).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(bufferSize5)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer5)._ptr))
    return (_hipsparseSpGEMMreuse_copy__retval,)


@cython.embedsignature(True)
def hipsparseSpGEMMreuse_compute(object handle, object opA, object opB, object alpha, object matA, object matB, object beta, object matC, object computeType, object alg, object spgemmDescr):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpGEMMAlg_t`):
            (undocumented)

        spgemmDescr (`~.hipsparseSpGEMMDescr`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpGEMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpGEMMAlg_t__Base'")
    _hipsparseSpGEMMreuse_compute__retval = hipsparseStatus_t(chipsparse.hipsparseSpGEMMreuse_compute(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(matC)._ptr,computeType.value,alg.value,
        hipsparseSpGEMMDescr.fromPyobj(spgemmDescr).getElementPtr()))
    return (_hipsparseSpGEMMreuse_compute__retval,)


@cython.embedsignature(True)
def hipsparseSDDMM_bufferSize(object handle, object opA, object opB, object alpha, object A, object B, object beta, object C, object computeType, object alg, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSDDMMAlg_t`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSDDMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSDDMMAlg_t__Base'")
    _hipsparseSDDMM_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSDDMM_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,computeType.value,alg.value,
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSDDMM_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSDDMM_preprocess(object handle, object opA, object opB, object alpha, object A, object B, object beta, object C, object computeType, object alg, object tempBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSDDMMAlg_t`):
            (undocumented)

        tempBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSDDMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSDDMMAlg_t__Base'")
    _hipsparseSDDMM_preprocess__retval = hipsparseStatus_t(chipsparse.hipsparseSDDMM_preprocess(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,computeType.value,alg.value,
        <void *>hip._util.types.Pointer.fromPyobj(tempBuffer)._ptr))
    return (_hipsparseSDDMM_preprocess__retval,)


@cython.embedsignature(True)
def hipsparseSDDMM(object handle, object opA, object opB, object alpha, object A, object B, object beta, object C, object computeType, object alg, object tempBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        A (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        B (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        beta (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        C (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSDDMMAlg_t`):
            (undocumented)

        tempBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSDDMMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSDDMMAlg_t__Base'")
    _hipsparseSDDMM__retval = hipsparseStatus_t(chipsparse.hipsparseSDDMM(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(A)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(B)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(beta)._ptr,
        <void *>hip._util.types.Pointer.fromPyobj(C)._ptr,computeType.value,alg.value,
        <void *>hip._util.types.Pointer.fromPyobj(tempBuffer)._ptr))
    return (_hipsparseSDDMM__retval,)


@cython.embedsignature(True)
def hipsparseSpSV_createDescr():
    r"""(No short description, might be part of a group.)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * descr (`~.hipsparseSpSVDescr`):
            (undocumented)
    """
    descr = hipsparseSpSVDescr.fromPtr(NULL)
    _hipsparseSpSV_createDescr__retval = hipsparseStatus_t(chipsparse.hipsparseSpSV_createDescr(<chipsparse.hipsparseSpSVDescr**>&descr._ptr))
    return (_hipsparseSpSV_createDescr__retval,None if descr._ptr == NULL else descr)


@cython.embedsignature(True)
def hipsparseSpSV_destroyDescr(object descr):
    r"""(No short description, might be part of a group.)

    Args:
        descr (`~.hipsparseSpSVDescr`/`~.object`):
            (undocumented)
    """
    _hipsparseSpSV_destroyDescr__retval = hipsparseStatus_t(chipsparse.hipsparseSpSV_destroyDescr(
        hipsparseSpSVDescr.fromPyobj(descr).getElementPtr()))
    return (_hipsparseSpSV_destroyDescr__retval,)


@cython.embedsignature(True)
def hipsparseSpSV_bufferSize(object handle, object opA, object alpha, object matA, object x, object y, object computeType, object alg, object spsvDescr, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpSVAlg_t`):
            (undocumented)

        spsvDescr (`~.hipsparseSpSVDescr`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpSVAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpSVAlg_t__Base'")
    _hipsparseSpSV_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSpSV_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(y)._ptr,computeType.value,alg.value,
        hipsparseSpSVDescr.fromPyobj(spsvDescr).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpSV_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSpSV_analysis(object handle, object opA, object alpha, object matA, object x, object y, object computeType, object alg, object spsvDescr, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpSVAlg_t`):
            (undocumented)

        spsvDescr (`~.hipsparseSpSVDescr`/`~.object`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpSVAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpSVAlg_t__Base'")
    _hipsparseSpSV_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseSpSV_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(y)._ptr,computeType.value,alg.value,
        hipsparseSpSVDescr.fromPyobj(spsvDescr).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseSpSV_analysis__retval,)


@cython.embedsignature(True)
def hipsparseSpSV_solve(object handle, object opA, object alpha, object matA, object x, object y, object computeType, object alg, object spsvDescr):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        x (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        y (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpSVAlg_t`):
            (undocumented)

        spsvDescr (`~.hipsparseSpSVDescr`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpSVAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpSVAlg_t__Base'")
    _hipsparseSpSV_solve__retval = hipsparseStatus_t(chipsparse.hipsparseSpSV_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(x)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(y)._ptr,computeType.value,alg.value,
        hipsparseSpSVDescr.fromPyobj(spsvDescr).getElementPtr()))
    return (_hipsparseSpSV_solve__retval,)


@cython.embedsignature(True)
def hipsparseSpSM_createDescr():
    r"""(No short description, might be part of a group.)

    Returns:
        A `~.tuple` of size 1 that contains (in that order):

        * descr (`~.hipsparseSpSMDescr`):
            (undocumented)
    """
    descr = hipsparseSpSMDescr.fromPtr(NULL)
    _hipsparseSpSM_createDescr__retval = hipsparseStatus_t(chipsparse.hipsparseSpSM_createDescr(<chipsparse.hipsparseSpSMDescr**>&descr._ptr))
    return (_hipsparseSpSM_createDescr__retval,None if descr._ptr == NULL else descr)


@cython.embedsignature(True)
def hipsparseSpSM_destroyDescr(object descr):
    r"""(No short description, might be part of a group.)

    Args:
        descr (`~.hipsparseSpSMDescr`/`~.object`):
            (undocumented)
    """
    _hipsparseSpSM_destroyDescr__retval = hipsparseStatus_t(chipsparse.hipsparseSpSM_destroyDescr(
        hipsparseSpSMDescr.fromPyobj(descr).getElementPtr()))
    return (_hipsparseSpSM_destroyDescr__retval,)


@cython.embedsignature(True)
def hipsparseSpSM_bufferSize(object handle, object opA, object opB, object alpha, object matA, object matB, object matC, object computeType, object alg, object spsmDescr, object pBufferSizeInBytes):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpSMAlg_t`):
            (undocumented)

        spsmDescr (`~.hipsparseSpSMDescr`/`~.object`):
            (undocumented)

        pBufferSizeInBytes (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpSMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpSMAlg_t__Base'")
    _hipsparseSpSM_bufferSize__retval = hipsparseStatus_t(chipsparse.hipsparseSpSM_bufferSize(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(matC)._ptr,computeType.value,alg.value,
        hipsparseSpSMDescr.fromPyobj(spsmDescr).getElementPtr(),
        <unsigned long *>hip._util.types.Pointer.fromPyobj(pBufferSizeInBytes)._ptr))
    return (_hipsparseSpSM_bufferSize__retval,)


@cython.embedsignature(True)
def hipsparseSpSM_analysis(object handle, object opA, object opB, object alpha, object matA, object matB, object matC, object computeType, object alg, object spsmDescr, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpSMAlg_t`):
            (undocumented)

        spsmDescr (`~.hipsparseSpSMDescr`/`~.object`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpSMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpSMAlg_t__Base'")
    _hipsparseSpSM_analysis__retval = hipsparseStatus_t(chipsparse.hipsparseSpSM_analysis(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(matC)._ptr,computeType.value,alg.value,
        hipsparseSpSMDescr.fromPyobj(spsmDescr).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseSpSM_analysis__retval,)


@cython.embedsignature(True)
def hipsparseSpSM_solve(object handle, object opA, object opB, object alpha, object matA, object matB, object matC, object computeType, object alg, object spsmDescr, object externalBuffer):
    r"""(No short description, might be part of a group.)

    Args:
        handle (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        opA (`~.hipsparseOperation_t`):
            (undocumented)

        opB (`~.hipsparseOperation_t`):
            (undocumented)

        alpha (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matA (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matB (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        matC (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)

        computeType (`~.hipDataType`):
            (undocumented)

        alg (`~.hipsparseSpSMAlg_t`):
            (undocumented)

        spsmDescr (`~.hipsparseSpSMDescr`/`~.object`):
            (undocumented)

        externalBuffer (`~.hip._util.types.Pointer`/`~.object`):
            (undocumented)
    """
    if not isinstance(opA,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opA' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(opB,_hipsparseOperation_t__Base):
        raise TypeError("argument 'opB' must be of type '_hipsparseOperation_t__Base'")                    
    if not isinstance(computeType,_hipDataType__Base):
        raise TypeError("argument 'computeType' must be of type '_hipDataType__Base'")                    
    if not isinstance(alg,_hipsparseSpSMAlg_t__Base):
        raise TypeError("argument 'alg' must be of type '_hipsparseSpSMAlg_t__Base'")
    _hipsparseSpSM_solve__retval = hipsparseStatus_t(chipsparse.hipsparseSpSM_solve(
        <void *>hip._util.types.Pointer.fromPyobj(handle)._ptr,opA.value,opB.value,
        <const void *>hip._util.types.Pointer.fromPyobj(alpha)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matA)._ptr,
        <const void *>hip._util.types.Pointer.fromPyobj(matB)._ptr,
        <void *const>hip._util.types.Pointer.fromPyobj(matC)._ptr,computeType.value,alg.value,
        hipsparseSpSMDescr.fromPyobj(spsmDescr).getElementPtr(),
        <void *>hip._util.types.Pointer.fromPyobj(externalBuffer)._ptr))
    return (_hipsparseSpSM_solve__retval,)

__all__ = [
    "bsrsv2Info",
    "bsrsm2Info",
    "bsrilu02Info",
    "bsric02Info",
    "csrsv2Info",
    "csrsm2Info",
    "csrilu02Info",
    "csric02Info",
    "csrgemm2Info",
    "pruneInfo",
    "csru2csrInfo",
    "bsrsv2Info_t",
    "bsrsm2Info_t",
    "bsrilu02Info_t",
    "bsric02Info_t",
    "csrsv2Info_t",
    "csrsm2Info_t",
    "csrilu02Info_t",
    "csric02Info_t",
    "csrgemm2Info_t",
    "pruneInfo_t",
    "csru2csrInfo_t",
    "_hipsparseStatus_t__Base",
    "hipsparseStatus_t",
    "_hipsparsePointerMode_t__Base",
    "hipsparsePointerMode_t",
    "_hipsparseAction_t__Base",
    "hipsparseAction_t",
    "_hipsparseMatrixType_t__Base",
    "hipsparseMatrixType_t",
    "_hipsparseFillMode_t__Base",
    "hipsparseFillMode_t",
    "_hipsparseDiagType_t__Base",
    "hipsparseDiagType_t",
    "_hipsparseIndexBase_t__Base",
    "hipsparseIndexBase_t",
    "_hipsparseOperation_t__Base",
    "hipsparseOperation_t",
    "_hipsparseHybPartition_t__Base",
    "hipsparseHybPartition_t",
    "_hipsparseSolvePolicy_t__Base",
    "hipsparseSolvePolicy_t",
    "_hipsparseSideMode_t__Base",
    "hipsparseSideMode_t",
    "_hipsparseDirection_t__Base",
    "hipsparseDirection_t",
    "hipsparseCreate",
    "hipsparseDestroy",
    "hipsparseGetErrorName",
    "hipsparseGetErrorString",
    "hipsparseGetVersion",
    "hipsparseGetGitRevision",
    "hipsparseSetStream",
    "hipsparseGetStream",
    "hipsparseSetPointerMode",
    "hipsparseGetPointerMode",
    "hipsparseCreateMatDescr",
    "hipsparseDestroyMatDescr",
    "hipsparseCopyMatDescr",
    "hipsparseSetMatType",
    "hipsparseGetMatType",
    "hipsparseSetMatFillMode",
    "hipsparseGetMatFillMode",
    "hipsparseSetMatDiagType",
    "hipsparseGetMatDiagType",
    "hipsparseSetMatIndexBase",
    "hipsparseGetMatIndexBase",
    "hipsparseCreateHybMat",
    "hipsparseDestroyHybMat",
    "hipsparseCreateBsrsv2Info",
    "hipsparseDestroyBsrsv2Info",
    "hipsparseCreateBsrsm2Info",
    "hipsparseDestroyBsrsm2Info",
    "hipsparseCreateBsrilu02Info",
    "hipsparseDestroyBsrilu02Info",
    "hipsparseCreateBsric02Info",
    "hipsparseDestroyBsric02Info",
    "hipsparseCreateCsrsv2Info",
    "hipsparseDestroyCsrsv2Info",
    "hipsparseCreateCsrsm2Info",
    "hipsparseDestroyCsrsm2Info",
    "hipsparseCreateCsrilu02Info",
    "hipsparseDestroyCsrilu02Info",
    "hipsparseCreateCsric02Info",
    "hipsparseDestroyCsric02Info",
    "hipsparseCreateCsru2csrInfo",
    "hipsparseDestroyCsru2csrInfo",
    "hipsparseCreateColorInfo",
    "hipsparseDestroyColorInfo",
    "hipsparseCreateCsrgemm2Info",
    "hipsparseDestroyCsrgemm2Info",
    "hipsparseCreatePruneInfo",
    "hipsparseDestroyPruneInfo",
    "hipsparseSaxpyi",
    "hipsparseDaxpyi",
    "hipsparseCaxpyi",
    "hipsparseZaxpyi",
    "hipsparseSdoti",
    "hipsparseDdoti",
    "hipsparseCdoti",
    "hipsparseZdoti",
    "hipsparseCdotci",
    "hipsparseZdotci",
    "hipsparseSgthr",
    "hipsparseDgthr",
    "hipsparseCgthr",
    "hipsparseZgthr",
    "hipsparseSgthrz",
    "hipsparseDgthrz",
    "hipsparseCgthrz",
    "hipsparseZgthrz",
    "hipsparseSroti",
    "hipsparseDroti",
    "hipsparseSsctr",
    "hipsparseDsctr",
    "hipsparseCsctr",
    "hipsparseZsctr",
    "hipsparseScsrmv",
    "hipsparseDcsrmv",
    "hipsparseCcsrmv",
    "hipsparseZcsrmv",
    "hipsparseXcsrsv2_zeroPivot",
    "hipsparseScsrsv2_bufferSize",
    "hipsparseDcsrsv2_bufferSize",
    "hipsparseCcsrsv2_bufferSize",
    "hipsparseZcsrsv2_bufferSize",
    "hipsparseScsrsv2_bufferSizeExt",
    "hipsparseDcsrsv2_bufferSizeExt",
    "hipsparseCcsrsv2_bufferSizeExt",
    "hipsparseZcsrsv2_bufferSizeExt",
    "hipsparseScsrsv2_analysis",
    "hipsparseDcsrsv2_analysis",
    "hipsparseCcsrsv2_analysis",
    "hipsparseZcsrsv2_analysis",
    "hipsparseScsrsv2_solve",
    "hipsparseDcsrsv2_solve",
    "hipsparseCcsrsv2_solve",
    "hipsparseZcsrsv2_solve",
    "hipsparseShybmv",
    "hipsparseDhybmv",
    "hipsparseChybmv",
    "hipsparseZhybmv",
    "hipsparseSbsrmv",
    "hipsparseDbsrmv",
    "hipsparseCbsrmv",
    "hipsparseZbsrmv",
    "hipsparseSbsrxmv",
    "hipsparseDbsrxmv",
    "hipsparseCbsrxmv",
    "hipsparseZbsrxmv",
    "hipsparseXbsrsv2_zeroPivot",
    "hipsparseSbsrsv2_bufferSize",
    "hipsparseDbsrsv2_bufferSize",
    "hipsparseCbsrsv2_bufferSize",
    "hipsparseZbsrsv2_bufferSize",
    "hipsparseSbsrsv2_bufferSizeExt",
    "hipsparseDbsrsv2_bufferSizeExt",
    "hipsparseCbsrsv2_bufferSizeExt",
    "hipsparseZbsrsv2_bufferSizeExt",
    "hipsparseSbsrsv2_analysis",
    "hipsparseDbsrsv2_analysis",
    "hipsparseCbsrsv2_analysis",
    "hipsparseZbsrsv2_analysis",
    "hipsparseSbsrsv2_solve",
    "hipsparseDbsrsv2_solve",
    "hipsparseCbsrsv2_solve",
    "hipsparseZbsrsv2_solve",
    "hipsparseSgemvi_bufferSize",
    "hipsparseDgemvi_bufferSize",
    "hipsparseCgemvi_bufferSize",
    "hipsparseZgemvi_bufferSize",
    "hipsparseSgemvi",
    "hipsparseDgemvi",
    "hipsparseCgemvi",
    "hipsparseZgemvi",
    "hipsparseSbsrmm",
    "hipsparseDbsrmm",
    "hipsparseCbsrmm",
    "hipsparseZbsrmm",
    "hipsparseScsrmm",
    "hipsparseDcsrmm",
    "hipsparseCcsrmm",
    "hipsparseZcsrmm",
    "hipsparseScsrmm2",
    "hipsparseDcsrmm2",
    "hipsparseCcsrmm2",
    "hipsparseZcsrmm2",
    "hipsparseXbsrsm2_zeroPivot",
    "hipsparseSbsrsm2_bufferSize",
    "hipsparseDbsrsm2_bufferSize",
    "hipsparseCbsrsm2_bufferSize",
    "hipsparseZbsrsm2_bufferSize",
    "hipsparseSbsrsm2_analysis",
    "hipsparseDbsrsm2_analysis",
    "hipsparseCbsrsm2_analysis",
    "hipsparseZbsrsm2_analysis",
    "hipsparseSbsrsm2_solve",
    "hipsparseDbsrsm2_solve",
    "hipsparseCbsrsm2_solve",
    "hipsparseZbsrsm2_solve",
    "hipsparseXcsrsm2_zeroPivot",
    "hipsparseScsrsm2_bufferSizeExt",
    "hipsparseDcsrsm2_bufferSizeExt",
    "hipsparseCcsrsm2_bufferSizeExt",
    "hipsparseZcsrsm2_bufferSizeExt",
    "hipsparseScsrsm2_analysis",
    "hipsparseDcsrsm2_analysis",
    "hipsparseCcsrsm2_analysis",
    "hipsparseZcsrsm2_analysis",
    "hipsparseScsrsm2_solve",
    "hipsparseDcsrsm2_solve",
    "hipsparseCcsrsm2_solve",
    "hipsparseZcsrsm2_solve",
    "hipsparseSgemmi",
    "hipsparseDgemmi",
    "hipsparseCgemmi",
    "hipsparseZgemmi",
    "hipsparseXcsrgeamNnz",
    "hipsparseScsrgeam",
    "hipsparseDcsrgeam",
    "hipsparseCcsrgeam",
    "hipsparseZcsrgeam",
    "hipsparseScsrgeam2_bufferSizeExt",
    "hipsparseDcsrgeam2_bufferSizeExt",
    "hipsparseCcsrgeam2_bufferSizeExt",
    "hipsparseZcsrgeam2_bufferSizeExt",
    "hipsparseXcsrgeam2Nnz",
    "hipsparseScsrgeam2",
    "hipsparseDcsrgeam2",
    "hipsparseCcsrgeam2",
    "hipsparseZcsrgeam2",
    "hipsparseXcsrgemmNnz",
    "hipsparseScsrgemm",
    "hipsparseDcsrgemm",
    "hipsparseCcsrgemm",
    "hipsparseZcsrgemm",
    "hipsparseScsrgemm2_bufferSizeExt",
    "hipsparseDcsrgemm2_bufferSizeExt",
    "hipsparseCcsrgemm2_bufferSizeExt",
    "hipsparseZcsrgemm2_bufferSizeExt",
    "hipsparseXcsrgemm2Nnz",
    "hipsparseScsrgemm2",
    "hipsparseDcsrgemm2",
    "hipsparseCcsrgemm2",
    "hipsparseZcsrgemm2",
    "hipsparseXbsrilu02_zeroPivot",
    "hipsparseSbsrilu02_numericBoost",
    "hipsparseDbsrilu02_numericBoost",
    "hipsparseCbsrilu02_numericBoost",
    "hipsparseZbsrilu02_numericBoost",
    "hipsparseSbsrilu02_bufferSize",
    "hipsparseDbsrilu02_bufferSize",
    "hipsparseCbsrilu02_bufferSize",
    "hipsparseZbsrilu02_bufferSize",
    "hipsparseSbsrilu02_analysis",
    "hipsparseDbsrilu02_analysis",
    "hipsparseCbsrilu02_analysis",
    "hipsparseZbsrilu02_analysis",
    "hipsparseSbsrilu02",
    "hipsparseDbsrilu02",
    "hipsparseCbsrilu02",
    "hipsparseZbsrilu02",
    "hipsparseXcsrilu02_zeroPivot",
    "hipsparseScsrilu02_numericBoost",
    "hipsparseDcsrilu02_numericBoost",
    "hipsparseCcsrilu02_numericBoost",
    "hipsparseZcsrilu02_numericBoost",
    "hipsparseScsrilu02_bufferSize",
    "hipsparseDcsrilu02_bufferSize",
    "hipsparseCcsrilu02_bufferSize",
    "hipsparseZcsrilu02_bufferSize",
    "hipsparseScsrilu02_bufferSizeExt",
    "hipsparseDcsrilu02_bufferSizeExt",
    "hipsparseCcsrilu02_bufferSizeExt",
    "hipsparseZcsrilu02_bufferSizeExt",
    "hipsparseScsrilu02_analysis",
    "hipsparseDcsrilu02_analysis",
    "hipsparseCcsrilu02_analysis",
    "hipsparseZcsrilu02_analysis",
    "hipsparseScsrilu02",
    "hipsparseDcsrilu02",
    "hipsparseCcsrilu02",
    "hipsparseZcsrilu02",
    "hipsparseXbsric02_zeroPivot",
    "hipsparseSbsric02_bufferSize",
    "hipsparseDbsric02_bufferSize",
    "hipsparseCbsric02_bufferSize",
    "hipsparseZbsric02_bufferSize",
    "hipsparseSbsric02_analysis",
    "hipsparseDbsric02_analysis",
    "hipsparseCbsric02_analysis",
    "hipsparseZbsric02_analysis",
    "hipsparseSbsric02",
    "hipsparseDbsric02",
    "hipsparseCbsric02",
    "hipsparseZbsric02",
    "hipsparseXcsric02_zeroPivot",
    "hipsparseScsric02_bufferSize",
    "hipsparseDcsric02_bufferSize",
    "hipsparseCcsric02_bufferSize",
    "hipsparseZcsric02_bufferSize",
    "hipsparseScsric02_bufferSizeExt",
    "hipsparseDcsric02_bufferSizeExt",
    "hipsparseCcsric02_bufferSizeExt",
    "hipsparseZcsric02_bufferSizeExt",
    "hipsparseScsric02_analysis",
    "hipsparseDcsric02_analysis",
    "hipsparseCcsric02_analysis",
    "hipsparseZcsric02_analysis",
    "hipsparseScsric02",
    "hipsparseDcsric02",
    "hipsparseCcsric02",
    "hipsparseZcsric02",
    "hipsparseSgtsv2_bufferSizeExt",
    "hipsparseDgtsv2_bufferSizeExt",
    "hipsparseCgtsv2_bufferSizeExt",
    "hipsparseZgtsv2_bufferSizeExt",
    "hipsparseSgtsv2",
    "hipsparseDgtsv2",
    "hipsparseCgtsv2",
    "hipsparseZgtsv2",
    "hipsparseSgtsv2_nopivot_bufferSizeExt",
    "hipsparseDgtsv2_nopivot_bufferSizeExt",
    "hipsparseCgtsv2_nopivot_bufferSizeExt",
    "hipsparseZgtsv2_nopivot_bufferSizeExt",
    "hipsparseSgtsv2_nopivot",
    "hipsparseDgtsv2_nopivot",
    "hipsparseCgtsv2_nopivot",
    "hipsparseZgtsv2_nopivot",
    "hipsparseSgtsv2StridedBatch_bufferSizeExt",
    "hipsparseDgtsv2StridedBatch_bufferSizeExt",
    "hipsparseCgtsv2StridedBatch_bufferSizeExt",
    "hipsparseZgtsv2StridedBatch_bufferSizeExt",
    "hipsparseSgtsv2StridedBatch",
    "hipsparseDgtsv2StridedBatch",
    "hipsparseCgtsv2StridedBatch",
    "hipsparseZgtsv2StridedBatch",
    "hipsparseSgtsvInterleavedBatch_bufferSizeExt",
    "hipsparseDgtsvInterleavedBatch_bufferSizeExt",
    "hipsparseCgtsvInterleavedBatch_bufferSizeExt",
    "hipsparseZgtsvInterleavedBatch_bufferSizeExt",
    "hipsparseSgtsvInterleavedBatch",
    "hipsparseDgtsvInterleavedBatch",
    "hipsparseCgtsvInterleavedBatch",
    "hipsparseZgtsvInterleavedBatch",
    "hipsparseSgpsvInterleavedBatch_bufferSizeExt",
    "hipsparseDgpsvInterleavedBatch_bufferSizeExt",
    "hipsparseCgpsvInterleavedBatch_bufferSizeExt",
    "hipsparseZgpsvInterleavedBatch_bufferSizeExt",
    "hipsparseSgpsvInterleavedBatch",
    "hipsparseDgpsvInterleavedBatch",
    "hipsparseCgpsvInterleavedBatch",
    "hipsparseZgpsvInterleavedBatch",
    "hipsparseSnnz",
    "hipsparseDnnz",
    "hipsparseCnnz",
    "hipsparseZnnz",
    "hipsparseSdense2csr",
    "hipsparseDdense2csr",
    "hipsparseCdense2csr",
    "hipsparseZdense2csr",
    "hipsparseSpruneDense2csr_bufferSize",
    "hipsparseDpruneDense2csr_bufferSize",
    "hipsparseSpruneDense2csr_bufferSizeExt",
    "hipsparseDpruneDense2csr_bufferSizeExt",
    "hipsparseSpruneDense2csrNnz",
    "hipsparseDpruneDense2csrNnz",
    "hipsparseSpruneDense2csr",
    "hipsparseDpruneDense2csr",
    "hipsparseSpruneDense2csrByPercentage_bufferSize",
    "hipsparseDpruneDense2csrByPercentage_bufferSize",
    "hipsparseSpruneDense2csrByPercentage_bufferSizeExt",
    "hipsparseDpruneDense2csrByPercentage_bufferSizeExt",
    "hipsparseSpruneDense2csrNnzByPercentage",
    "hipsparseDpruneDense2csrNnzByPercentage",
    "hipsparseSpruneDense2csrByPercentage",
    "hipsparseDpruneDense2csrByPercentage",
    "hipsparseSdense2csc",
    "hipsparseDdense2csc",
    "hipsparseCdense2csc",
    "hipsparseZdense2csc",
    "hipsparseScsr2dense",
    "hipsparseDcsr2dense",
    "hipsparseCcsr2dense",
    "hipsparseZcsr2dense",
    "hipsparseScsc2dense",
    "hipsparseDcsc2dense",
    "hipsparseCcsc2dense",
    "hipsparseZcsc2dense",
    "hipsparseXcsr2bsrNnz",
    "hipsparseSnnz_compress",
    "hipsparseDnnz_compress",
    "hipsparseCnnz_compress",
    "hipsparseZnnz_compress",
    "hipsparseXcsr2coo",
    "hipsparseScsr2csc",
    "hipsparseDcsr2csc",
    "hipsparseCcsr2csc",
    "hipsparseZcsr2csc",
    "_hipsparseCsr2CscAlg_t__Base",
    "hipsparseCsr2CscAlg_t",
    "hipsparseCsr2cscEx2_bufferSize",
    "hipsparseCsr2cscEx2",
    "hipsparseScsr2hyb",
    "hipsparseDcsr2hyb",
    "hipsparseCcsr2hyb",
    "hipsparseZcsr2hyb",
    "hipsparseSgebsr2gebsc_bufferSize",
    "hipsparseDgebsr2gebsc_bufferSize",
    "hipsparseCgebsr2gebsc_bufferSize",
    "hipsparseZgebsr2gebsc_bufferSize",
    "hipsparseSgebsr2gebsc",
    "hipsparseDgebsr2gebsc",
    "hipsparseCgebsr2gebsc",
    "hipsparseZgebsr2gebsc",
    "hipsparseScsr2gebsr_bufferSize",
    "hipsparseDcsr2gebsr_bufferSize",
    "hipsparseCcsr2gebsr_bufferSize",
    "hipsparseZcsr2gebsr_bufferSize",
    "hipsparseXcsr2gebsrNnz",
    "hipsparseScsr2gebsr",
    "hipsparseDcsr2gebsr",
    "hipsparseCcsr2gebsr",
    "hipsparseZcsr2gebsr",
    "hipsparseScsr2bsr",
    "hipsparseDcsr2bsr",
    "hipsparseCcsr2bsr",
    "hipsparseZcsr2bsr",
    "hipsparseSbsr2csr",
    "hipsparseDbsr2csr",
    "hipsparseCbsr2csr",
    "hipsparseZbsr2csr",
    "hipsparseSgebsr2csr",
    "hipsparseDgebsr2csr",
    "hipsparseCgebsr2csr",
    "hipsparseZgebsr2csr",
    "hipsparseScsr2csr_compress",
    "hipsparseDcsr2csr_compress",
    "hipsparseCcsr2csr_compress",
    "hipsparseZcsr2csr_compress",
    "hipsparseSpruneCsr2csr_bufferSize",
    "hipsparseDpruneCsr2csr_bufferSize",
    "hipsparseSpruneCsr2csr_bufferSizeExt",
    "hipsparseDpruneCsr2csr_bufferSizeExt",
    "hipsparseSpruneCsr2csrNnz",
    "hipsparseDpruneCsr2csrNnz",
    "hipsparseSpruneCsr2csr",
    "hipsparseDpruneCsr2csr",
    "hipsparseSpruneCsr2csrByPercentage_bufferSize",
    "hipsparseDpruneCsr2csrByPercentage_bufferSize",
    "hipsparseSpruneCsr2csrByPercentage_bufferSizeExt",
    "hipsparseDpruneCsr2csrByPercentage_bufferSizeExt",
    "hipsparseSpruneCsr2csrNnzByPercentage",
    "hipsparseDpruneCsr2csrNnzByPercentage",
    "hipsparseSpruneCsr2csrByPercentage",
    "hipsparseDpruneCsr2csrByPercentage",
    "hipsparseShyb2csr",
    "hipsparseDhyb2csr",
    "hipsparseChyb2csr",
    "hipsparseZhyb2csr",
    "hipsparseXcoo2csr",
    "hipsparseCreateIdentityPermutation",
    "hipsparseXcsrsort_bufferSizeExt",
    "hipsparseXcsrsort",
    "hipsparseXcscsort_bufferSizeExt",
    "hipsparseXcscsort",
    "hipsparseXcoosort_bufferSizeExt",
    "hipsparseXcoosortByRow",
    "hipsparseXcoosortByColumn",
    "hipsparseSgebsr2gebsr_bufferSize",
    "hipsparseDgebsr2gebsr_bufferSize",
    "hipsparseCgebsr2gebsr_bufferSize",
    "hipsparseZgebsr2gebsr_bufferSize",
    "hipsparseXgebsr2gebsrNnz",
    "hipsparseSgebsr2gebsr",
    "hipsparseDgebsr2gebsr",
    "hipsparseCgebsr2gebsr",
    "hipsparseZgebsr2gebsr",
    "hipsparseScsru2csr_bufferSizeExt",
    "hipsparseDcsru2csr_bufferSizeExt",
    "hipsparseCcsru2csr_bufferSizeExt",
    "hipsparseZcsru2csr_bufferSizeExt",
    "hipsparseScsru2csr",
    "hipsparseDcsru2csr",
    "hipsparseCcsru2csr",
    "hipsparseZcsru2csr",
    "hipsparseScsr2csru",
    "hipsparseDcsr2csru",
    "hipsparseCcsr2csru",
    "hipsparseZcsr2csru",
    "hipsparseScsrcolor",
    "hipsparseDcsrcolor",
    "hipsparseCcsrcolor",
    "hipsparseZcsrcolor",
    "hipsparseSpGEMMDescr",
    "hipsparseSpSVDescr",
    "hipsparseSpSMDescr",
    "hipsparseSpGEMMDescr_t",
    "hipsparseSpSVDescr_t",
    "hipsparseSpSMDescr_t",
    "_hipsparseFormat_t__Base",
    "hipsparseFormat_t",
    "_hipsparseOrder_t__Base",
    "hipsparseOrder_t",
    "_hipsparseIndexType_t__Base",
    "hipsparseIndexType_t",
    "_hipsparseSpMVAlg_t__Base",
    "hipsparseSpMVAlg_t",
    "_hipsparseSpMMAlg_t__Base",
    "hipsparseSpMMAlg_t",
    "_hipsparseSparseToDenseAlg_t__Base",
    "hipsparseSparseToDenseAlg_t",
    "_hipsparseDenseToSparseAlg_t__Base",
    "hipsparseDenseToSparseAlg_t",
    "_hipsparseSDDMMAlg_t__Base",
    "hipsparseSDDMMAlg_t",
    "_hipsparseSpSVAlg_t__Base",
    "hipsparseSpSVAlg_t",
    "_hipsparseSpSMAlg_t__Base",
    "hipsparseSpSMAlg_t",
    "_hipsparseSpMatAttribute_t__Base",
    "hipsparseSpMatAttribute_t",
    "_hipsparseSpGEMMAlg_t__Base",
    "hipsparseSpGEMMAlg_t",
    "hipsparseCreateSpVec",
    "hipsparseCreateConstSpVec",
    "hipsparseDestroySpVec",
    "hipsparseSpVecGet",
    "hipsparseConstSpVecGet",
    "hipsparseSpVecGetIndexBase",
    "hipsparseSpVecGetValues",
    "hipsparseConstSpVecGetValues",
    "hipsparseSpVecSetValues",
    "hipsparseCreateCoo",
    "hipsparseCreateConstCoo",
    "hipsparseCreateCooAoS",
    "hipsparseCreateCsr",
    "hipsparseCreateConstCsr",
    "hipsparseCreateCsc",
    "hipsparseCreateConstCsc",
    "hipsparseCreateBlockedEll",
    "hipsparseCreateConstBlockedEll",
    "hipsparseDestroySpMat",
    "hipsparseCooGet",
    "hipsparseConstCooGet",
    "hipsparseCooAoSGet",
    "hipsparseCsrGet",
    "hipsparseConstCsrGet",
    "hipsparseCscGet",
    "hipsparseConstCscGet",
    "hipsparseBlockedEllGet",
    "hipsparseConstBlockedEllGet",
    "hipsparseCsrSetPointers",
    "hipsparseCscSetPointers",
    "hipsparseCooSetPointers",
    "hipsparseSpMatGetSize",
    "hipsparseSpMatGetFormat",
    "hipsparseSpMatGetIndexBase",
    "hipsparseSpMatGetValues",
    "hipsparseConstSpMatGetValues",
    "hipsparseSpMatSetValues",
    "hipsparseSpMatGetStridedBatch",
    "hipsparseSpMatSetStridedBatch",
    "hipsparseCooSetStridedBatch",
    "hipsparseCsrSetStridedBatch",
    "hipsparseSpMatGetAttribute",
    "hipsparseSpMatSetAttribute",
    "hipsparseCreateDnVec",
    "hipsparseCreateConstDnVec",
    "hipsparseDestroyDnVec",
    "hipsparseDnVecGet",
    "hipsparseConstDnVecGet",
    "hipsparseDnVecGetValues",
    "hipsparseConstDnVecGetValues",
    "hipsparseDnVecSetValues",
    "hipsparseCreateDnMat",
    "hipsparseCreateConstDnMat",
    "hipsparseDestroyDnMat",
    "hipsparseDnMatGet",
    "hipsparseConstDnMatGet",
    "hipsparseDnMatGetValues",
    "hipsparseConstDnMatGetValues",
    "hipsparseDnMatSetValues",
    "hipsparseDnMatGetStridedBatch",
    "hipsparseDnMatSetStridedBatch",
    "hipsparseAxpby",
    "hipsparseGather",
    "hipsparseScatter",
    "hipsparseRot",
    "hipsparseSparseToDense_bufferSize",
    "hipsparseSparseToDense",
    "hipsparseDenseToSparse_bufferSize",
    "hipsparseDenseToSparse_analysis",
    "hipsparseDenseToSparse_convert",
    "hipsparseSpVV_bufferSize",
    "hipsparseSpVV",
    "hipsparseSpMV_bufferSize",
    "hipsparseSpMV_preprocess",
    "hipsparseSpMV",
    "hipsparseSpMM_bufferSize",
    "hipsparseSpMM_preprocess",
    "hipsparseSpMM",
    "hipsparseSpGEMM_createDescr",
    "hipsparseSpGEMM_destroyDescr",
    "hipsparseSpGEMM_workEstimation",
    "hipsparseSpGEMM_compute",
    "hipsparseSpGEMM_copy",
    "hipsparseSpGEMMreuse_workEstimation",
    "hipsparseSpGEMMreuse_nnz",
    "hipsparseSpGEMMreuse_copy",
    "hipsparseSpGEMMreuse_compute",
    "hipsparseSDDMM_bufferSize",
    "hipsparseSDDMM_preprocess",
    "hipsparseSDDMM",
    "hipsparseSpSV_createDescr",
    "hipsparseSpSV_destroyDescr",
    "hipsparseSpSV_bufferSize",
    "hipsparseSpSV_analysis",
    "hipsparseSpSV_solve",
    "hipsparseSpSM_createDescr",
    "hipsparseSpSM_destroyDescr",
    "hipsparseSpSM_bufferSize",
    "hipsparseSpSM_analysis",
    "hipsparseSpSM_solve",
]