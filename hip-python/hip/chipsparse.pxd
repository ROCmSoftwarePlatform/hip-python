# MIT License
#
# Copyright (c) 2021-2025 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


# This file has been autogenerated, do not modify.

from libc.stdint cimport *
ctypedef bint _Bool # bool is not a reserved keyword in C, _Bool is
from .chip cimport *
cdef extern from "hipsparse/hipsparse.h":

    cdef struct bsrsv2Info:
        pass

    cdef struct bsrsm2Info:
        pass

    cdef struct bsrilu02Info:
        pass

    cdef struct bsric02Info:
        pass

    cdef struct csrsv2Info:
        pass

    cdef struct csrsm2Info:
        pass

    cdef struct csrilu02Info:
        pass

    cdef struct csric02Info:
        pass

    cdef struct csrgemm2Info:
        pass

    cdef struct pruneInfo:
        pass

    cdef struct csru2csrInfo:
        pass

    ctypedef void * hipsparseHandle_t

    ctypedef void * hipsparseMatDescr_t

    ctypedef void * hipsparseHybMat_t

    ctypedef void * hipsparseColorInfo_t

    ctypedef bsrsv2Info * bsrsv2Info_t

    ctypedef bsrsm2Info * bsrsm2Info_t

    ctypedef bsrilu02Info * bsrilu02Info_t

    ctypedef bsric02Info * bsric02Info_t

    ctypedef csrsv2Info * csrsv2Info_t

    ctypedef csrsm2Info * csrsm2Info_t

    ctypedef csrilu02Info * csrilu02Info_t

    ctypedef csric02Info * csric02Info_t

    ctypedef csrgemm2Info * csrgemm2Info_t

    ctypedef pruneInfo * pruneInfo_t

    ctypedef csru2csrInfo * csru2csrInfo_t

    ctypedef enum hipsparseStatus_t:
        HIPSPARSE_STATUS_SUCCESS
        HIPSPARSE_STATUS_NOT_INITIALIZED
        HIPSPARSE_STATUS_ALLOC_FAILED
        HIPSPARSE_STATUS_INVALID_VALUE
        HIPSPARSE_STATUS_ARCH_MISMATCH
        HIPSPARSE_STATUS_MAPPING_ERROR
        HIPSPARSE_STATUS_EXECUTION_FAILED
        HIPSPARSE_STATUS_INTERNAL_ERROR
        HIPSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED
        HIPSPARSE_STATUS_ZERO_PIVOT
        HIPSPARSE_STATUS_NOT_SUPPORTED
        HIPSPARSE_STATUS_INSUFFICIENT_RESOURCES

    ctypedef enum hipsparsePointerMode_t:
        HIPSPARSE_POINTER_MODE_HOST
        HIPSPARSE_POINTER_MODE_DEVICE

    ctypedef enum hipsparseAction_t:
        HIPSPARSE_ACTION_SYMBOLIC
        HIPSPARSE_ACTION_NUMERIC

    ctypedef enum hipsparseMatrixType_t:
        HIPSPARSE_MATRIX_TYPE_GENERAL
        HIPSPARSE_MATRIX_TYPE_SYMMETRIC
        HIPSPARSE_MATRIX_TYPE_HERMITIAN
        HIPSPARSE_MATRIX_TYPE_TRIANGULAR

    ctypedef enum hipsparseFillMode_t:
        HIPSPARSE_FILL_MODE_LOWER
        HIPSPARSE_FILL_MODE_UPPER

    ctypedef enum hipsparseDiagType_t:
        HIPSPARSE_DIAG_TYPE_NON_UNIT
        HIPSPARSE_DIAG_TYPE_UNIT

    ctypedef enum hipsparseIndexBase_t:
        HIPSPARSE_INDEX_BASE_ZERO
        HIPSPARSE_INDEX_BASE_ONE

    ctypedef enum hipsparseOperation_t:
        HIPSPARSE_OPERATION_NON_TRANSPOSE
        HIPSPARSE_OPERATION_TRANSPOSE
        HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE

    ctypedef enum hipsparseHybPartition_t:
        HIPSPARSE_HYB_PARTITION_AUTO
        HIPSPARSE_HYB_PARTITION_USER
        HIPSPARSE_HYB_PARTITION_MAX

    ctypedef enum hipsparseSolvePolicy_t:
        HIPSPARSE_SOLVE_POLICY_NO_LEVEL
        HIPSPARSE_SOLVE_POLICY_USE_LEVEL

    ctypedef enum hipsparseSideMode_t:
        HIPSPARSE_SIDE_LEFT
        HIPSPARSE_SIDE_RIGHT

    ctypedef enum hipsparseDirection_t:
        HIPSPARSE_DIRECTION_ROW
        HIPSPARSE_DIRECTION_COLUMN

# \ingroup aux_module
# \brief Create a hipsparse handle
# 
# \details
# \p hipsparseCreate creates the hipSPARSE library context. It must be
# initialized before any other hipSPARSE API function is invoked and must be passed to
# all subsequent library function calls. The handle should be destroyed at the end
# using hipsparseDestroy().
cdef hipsparseStatus_t hipsparseCreate(void ** handle)


# \ingroup aux_module
# \brief Destroy a hipsparse handle
# 
# \details
# \p hipsparseDestroy destroys the hipSPARSE library context and releases all
# resources used by the hipSPARSE library.
cdef hipsparseStatus_t hipsparseDestroy(void * handle)


# \ingroup aux_module
# \brief Return the string representation of a hipSPARSE status's matching backend status enum name
# 
# \details
# \p hipsparseGetErrorName takes a hipSPARSE status as input and first converts it to the matching backend
# status (either rocsparse_status or cusparseStatus_t). It then returns the string representation of this status
# enum name. If the status is not recognized, the function returns "Unrecognized status code".
# 
# For example, hipsparseGetErrorName(HIPSPARSE_STATUS_SUCCESS) on a system with a rocSPARSE backend will
# return "rocsparse_status_success". On a system with a cuSPARSE backend this function would return
# "CUSPARSE_STATUS_SUCCESS".
cdef const char * hipsparseGetErrorName(hipsparseStatus_t status)


# \ingroup aux_module
# \brief Return the hipSPARSE status's matching backend status description as a string
# 
# \details
# \p hipsparseGetErrorString takes a hipSPARSE status as input and first converts it to the matching backend
# status (either rocsparse_status or cusparseStatus_t). It then returns the string description of this status.
# If the status is not recognized, the function returns "Unrecognized status code".
cdef const char * hipsparseGetErrorString(hipsparseStatus_t status)


# \ingroup aux_module
# \brief Get hipSPARSE version
# 
# \details
# \p hipsparseGetVersion gets the hipSPARSE library version number.
# - patch = version % 100
# - minor = version / 100 % 1000
# - major = version / 100000
cdef hipsparseStatus_t hipsparseGetVersion(void * handle,int * version)


# \ingroup aux_module
# \brief Get hipSPARSE git revision
# 
# \details
# \p hipsparseGetGitRevision gets the hipSPARSE library git commit revision (SHA-1).
cdef hipsparseStatus_t hipsparseGetGitRevision(void * handle,char * rev)


# \ingroup aux_module
# \brief Specify user defined HIP stream
# 
# \details
# \p hipsparseSetStream specifies the stream to be used by the hipSPARSE library
# context and all subsequent function calls.
cdef hipsparseStatus_t hipsparseSetStream(void * handle,hipStream_t streamId)


# \ingroup aux_module
# \brief Get current stream from library context
# 
# \details
# \p hipsparseGetStream gets the hipSPARSE library context stream which is currently
# used for all subsequent function calls.
cdef hipsparseStatus_t hipsparseGetStream(void * handle,hipStream_t* streamId)


# \ingroup aux_module
# \brief Specify pointer mode
# 
# \details
# \p hipsparseSetPointerMode specifies the pointer mode to be used by the hipSPARSE
# library context and all subsequent function calls. By default, all values are passed
# by reference on the host. Valid pointer modes are \ref HIPSPARSE_POINTER_MODE_HOST
# or \ref HIPSPARSE_POINTER_MODE_DEVICE.
cdef hipsparseStatus_t hipsparseSetPointerMode(void * handle,hipsparsePointerMode_t mode)


# \ingroup aux_module
# \brief Get current pointer mode from library context
# 
# \details
# \p hipsparseGetPointerMode gets the hipSPARSE library context pointer mode which
# is currently used for all subsequent function calls.
cdef hipsparseStatus_t hipsparseGetPointerMode(void * handle,hipsparsePointerMode_t * mode)


# \ingroup aux_module
# \brief Create a matrix descriptor
# \details
# \p hipsparseCreateMatDescr creates a matrix descriptor. It initializes
# \ref hipsparseMatrixType_t to \ref HIPSPARSE_MATRIX_TYPE_GENERAL and
# \ref hipsparseIndexBase_t to \ref HIPSPARSE_INDEX_BASE_ZERO. It should be destroyed
# at the end using hipsparseDestroyMatDescr().
cdef hipsparseStatus_t hipsparseCreateMatDescr(void ** descrA)


# \ingroup aux_module
# \brief Destroy a matrix descriptor
# 
# \details
# \p hipsparseDestroyMatDescr destroys a matrix descriptor and releases all
# resources used by the descriptor.
cdef hipsparseStatus_t hipsparseDestroyMatDescr(void * descrA)


# \ingroup aux_module
# \brief Copy a matrix descriptor
# \details
# \p hipsparseCopyMatDescr copies a matrix descriptor. Both, source and destination
# matrix descriptors must be initialized prior to calling \p hipsparseCopyMatDescr.
cdef hipsparseStatus_t hipsparseCopyMatDescr(void * dest,void *const src)


# \ingroup aux_module
# \brief Specify the matrix type of a matrix descriptor
# 
# \details
# \p hipsparseSetMatType sets the matrix type of a matrix descriptor. Valid
# matrix types are \ref HIPSPARSE_MATRIX_TYPE_GENERAL,
# \ref HIPSPARSE_MATRIX_TYPE_SYMMETRIC, \ref HIPSPARSE_MATRIX_TYPE_HERMITIAN or
# \ref HIPSPARSE_MATRIX_TYPE_TRIANGULAR.
cdef hipsparseStatus_t hipsparseSetMatType(void * descrA,hipsparseMatrixType_t type)


# \ingroup aux_module
# \brief Get the matrix type of a matrix descriptor
# 
# \details
# \p hipsparseGetMatType returns the matrix type of a matrix descriptor.
cdef hipsparseMatrixType_t hipsparseGetMatType(void *const descrA)


# \ingroup aux_module
# \brief Specify the matrix fill mode of a matrix descriptor
# 
# \details
# \p hipsparseSetMatFillMode sets the matrix fill mode of a matrix descriptor.
# Valid fill modes are \ref HIPSPARSE_FILL_MODE_LOWER or
# \ref HIPSPARSE_FILL_MODE_UPPER.
cdef hipsparseStatus_t hipsparseSetMatFillMode(void * descrA,hipsparseFillMode_t fillMode)


# \ingroup aux_module
# \brief Get the matrix fill mode of a matrix descriptor
# 
# \details
# \p hipsparseGetMatFillMode returns the matrix fill mode of a matrix descriptor.
cdef hipsparseFillMode_t hipsparseGetMatFillMode(void *const descrA)


# \ingroup aux_module
# \brief Specify the matrix diagonal type of a matrix descriptor
# 
# \details
# \p hipsparseSetMatDiagType sets the matrix diagonal type of a matrix
# descriptor. Valid diagonal types are \ref HIPSPARSE_DIAG_TYPE_UNIT or
# \ref HIPSPARSE_DIAG_TYPE_NON_UNIT.
cdef hipsparseStatus_t hipsparseSetMatDiagType(void * descrA,hipsparseDiagType_t diagType)


# \ingroup aux_module
# \brief Get the matrix diagonal type of a matrix descriptor
# 
# \details
# \p hipsparseGetMatDiagType returns the matrix diagonal type of a matrix
# descriptor.
cdef hipsparseDiagType_t hipsparseGetMatDiagType(void *const descrA)


# \ingroup aux_module
# \brief Specify the index base of a matrix descriptor
# 
# \details
# \p hipsparseSetMatIndexBase sets the index base of a matrix descriptor. Valid
# options are \ref HIPSPARSE_INDEX_BASE_ZERO or \ref HIPSPARSE_INDEX_BASE_ONE.
cdef hipsparseStatus_t hipsparseSetMatIndexBase(void * descrA,hipsparseIndexBase_t base)


# \ingroup aux_module
# \brief Get the index base of a matrix descriptor
# 
# \details
# \p hipsparseGetMatIndexBase returns the index base of a matrix descriptor.
cdef hipsparseIndexBase_t hipsparseGetMatIndexBase(void *const descrA)


# \ingroup aux_module
# \brief Create a \p HYB matrix structure
# 
# \details
# \p hipsparseCreateHybMat creates a structure that holds the matrix in \p HYB
# storage format. It should be destroyed at the end using hipsparseDestroyHybMat().
cdef hipsparseStatus_t hipsparseCreateHybMat(void ** hybA)


# \ingroup aux_module
# \brief Destroy a \p HYB matrix structure
# 
# \details
# \p hipsparseDestroyHybMat destroys a \p HYB structure.
cdef hipsparseStatus_t hipsparseDestroyHybMat(void * hybA)


# \ingroup aux_module
# \brief Create a bsrsv2 info structure
# 
# \details
# \p hipsparseCreateBsrsv2Info creates a structure that holds the bsrsv2 info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyBsrsv2Info().
cdef hipsparseStatus_t hipsparseCreateBsrsv2Info(bsrsv2Info_t* info)


# \ingroup aux_module
# \brief Destroy a bsrsv2 info structure
# 
# \details
# \p hipsparseDestroyBsrsv2Info destroys a bsrsv2 info structure.
cdef hipsparseStatus_t hipsparseDestroyBsrsv2Info(bsrsv2Info_t info)


# \ingroup aux_module
# \brief Create a bsrsm2 info structure
# 
# \details
# \p hipsparseCreateBsrsm2Info creates a structure that holds the bsrsm2 info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyBsrsm2Info().
cdef hipsparseStatus_t hipsparseCreateBsrsm2Info(bsrsm2Info_t* info)


# \ingroup aux_module
# \brief Destroy a bsrsm2 info structure
# 
# \details
# \p hipsparseDestroyBsrsm2Info destroys a bsrsm2 info structure.
cdef hipsparseStatus_t hipsparseDestroyBsrsm2Info(bsrsm2Info_t info)


# \ingroup aux_module
# \brief Create a bsrilu02 info structure
# 
# \details
# \p hipsparseCreateBsrilu02Info creates a structure that holds the bsrilu02 info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyBsrilu02Info().
cdef hipsparseStatus_t hipsparseCreateBsrilu02Info(bsrilu02Info_t* info)


# \ingroup aux_module
# \brief Destroy a bsrilu02 info structure
# 
# \details
# \p hipsparseDestroyBsrilu02Info destroys a bsrilu02 info structure.
cdef hipsparseStatus_t hipsparseDestroyBsrilu02Info(bsrilu02Info_t info)


# \ingroup aux_module
# \brief Create a bsric02 info structure
# 
# \details
# \p hipsparseCreateBsric02Info creates a structure that holds the bsric02 info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyBsric02Info().
cdef hipsparseStatus_t hipsparseCreateBsric02Info(bsric02Info_t* info)


# \ingroup aux_module
# \brief Destroy a bsric02 info structure
# 
# \details
# \p hipsparseDestroyBsric02Info destroys a bsric02 info structure.
cdef hipsparseStatus_t hipsparseDestroyBsric02Info(bsric02Info_t info)


# \ingroup aux_module
# \brief Create a csrsv2 info structure
# 
# \details
# \p hipsparseCreateCsrsv2Info creates a structure that holds the csrsv2 info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyCsrsv2Info().
cdef hipsparseStatus_t hipsparseCreateCsrsv2Info(csrsv2Info_t* info)


# \ingroup aux_module
# \brief Destroy a csrsv2 info structure
# 
# \details
# \p hipsparseDestroyCsrsv2Info destroys a csrsv2 info structure.
cdef hipsparseStatus_t hipsparseDestroyCsrsv2Info(csrsv2Info_t info)


# \ingroup aux_module
# \brief Create a csrsm2 info structure
# 
# \details
# \p hipsparseCreateCsrsm2Info creates a structure that holds the csrsm2 info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyCsrsm2Info().
cdef hipsparseStatus_t hipsparseCreateCsrsm2Info(csrsm2Info_t* info)


# \ingroup aux_module
# \brief Destroy a csrsm2 info structure
# 
# \details
# \p hipsparseDestroyCsrsm2Info destroys a csrsm2 info structure.
cdef hipsparseStatus_t hipsparseDestroyCsrsm2Info(csrsm2Info_t info)


# \ingroup aux_module
# \brief Create a csrilu02 info structure
# 
# \details
# \p hipsparseCreateCsrilu02Info creates a structure that holds the csrilu02 info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyCsrilu02Info().
cdef hipsparseStatus_t hipsparseCreateCsrilu02Info(csrilu02Info_t* info)


# \ingroup aux_module
# \brief Destroy a csrilu02 info structure
# 
# \details
# \p hipsparseDestroyCsrilu02Info destroys a csrilu02 info structure.
cdef hipsparseStatus_t hipsparseDestroyCsrilu02Info(csrilu02Info_t info)


# \ingroup aux_module
# \brief Create a csric02 info structure
# 
# \details
# \p hipsparseCreateCsric02Info creates a structure that holds the csric02 info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyCsric02Info().
cdef hipsparseStatus_t hipsparseCreateCsric02Info(csric02Info_t* info)


# \ingroup aux_module
# \brief Destroy a csric02 info structure
# 
# \details
# \p hipsparseDestroyCsric02Info destroys a csric02 info structure.
cdef hipsparseStatus_t hipsparseDestroyCsric02Info(csric02Info_t info)


# \ingroup aux_module
# \brief Create a csru2csr info structure
# 
# \details
# \p hipsparseCreateCsru2csrInfo creates a structure that holds the csru2csr info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyCsru2csrInfo().
cdef hipsparseStatus_t hipsparseCreateCsru2csrInfo(csru2csrInfo_t* info)


# \ingroup aux_module
# \brief Destroy a csru2csr info structure
# 
# \details
# \p hipsparseDestroyCsru2csrInfo destroys a csru2csr info structure.
cdef hipsparseStatus_t hipsparseDestroyCsru2csrInfo(csru2csrInfo_t info)


# \ingroup aux_module
# \brief Create a color info structure
# 
# \details
# \p hipsparseCreateColorInfo creates a structure that holds the color info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyColorInfo().
cdef hipsparseStatus_t hipsparseCreateColorInfo(void ** info)


# \ingroup aux_module
# \brief Destroy a color info structure
# 
# \details
# \p hipsparseDestroyColorInfo destroys a color info structure.
cdef hipsparseStatus_t hipsparseDestroyColorInfo(void * info)


# \ingroup aux_module
# \brief Create a csrgemm2 info structure
# 
# \details
# \p hipsparseCreateCsrgemm2Info creates a structure that holds the csrgemm2 info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyCsrgemm2Info().
cdef hipsparseStatus_t hipsparseCreateCsrgemm2Info(csrgemm2Info_t* info)


# \ingroup aux_module
# \brief Destroy a csrgemm2 info structure
# 
# \details
# \p hipsparseDestroyCsrgemm2Info destroys a csrgemm2 info structure.
cdef hipsparseStatus_t hipsparseDestroyCsrgemm2Info(csrgemm2Info_t info)


# \ingroup aux_module
# \brief Create a prune info structure
# 
# \details
# \p hipsparseCreatePruneInfo creates a structure that holds the prune info data
# that is gathered during the analysis routines available. It should be destroyed
# at the end using hipsparseDestroyPruneInfo().
cdef hipsparseStatus_t hipsparseCreatePruneInfo(pruneInfo_t* info)


# \ingroup aux_module
# \brief Destroy a prune info structure
# 
# \details
# \p hipsparseDestroyPruneInfo destroys a prune info structure.
cdef hipsparseStatus_t hipsparseDestroyPruneInfo(pruneInfo_t info)


#  \ingroup level1_module
# \brief Scale a sparse vector and add it to a dense vector.
# 
# \details
# \p hipsparseXaxpyi multiplies the sparse vector \f$x\f$ with scalar \f$\alpha\f$ and
# adds the result to the dense vector \f$y\f$, such that
# 
# \f[
#     y := y + \alpha \cdot x
# \f]
# 
# \code{.c}
#     for(i = 0; i < nnz; ++i)
#     {
#         y[xInd[i]] = y[xInd[i]] + alpha * xVal[i];
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#     // Number of non-zeros of the sparse vector
#     int nnz = 3;
# 
#     // Sparse index vector
#     int hxInd[3] = {0, 3, 5};
# 
#     // Sparse value vector
#     double hxVal[3] = {1.0, 2.0, 3.0};
# 
#     // Dense vector
#     double hy[9] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};
# 
#     // Scalar alpha
#     double alpha = 3.7;
# 
#     // Index base
#     hipsparseIndexBase_t idxBase = HIPSPARSE_INDEX_BASE_ZERO;
# 
#     // Offload data to device
#     int* dxInd;
#     double*        dxVal;
#     double*        dy;
# 
#     hipMalloc((void**)&dxInd, sizeof(int) * nnz);
#     hipMalloc((void**)&dxVal, sizeof(double) * nnz);
#     hipMalloc((void**)&dy, sizeof(double) * 9);
# 
#     hipMemcpy(dxInd, hxInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dxVal, hxVal, sizeof(double) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dy, hy, sizeof(double) * 9, hipMemcpyHostToDevice);
# 
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // Call daxpyi to perform y = y + alpha * x
#     hipsparseDaxpyi(handle, nnz, &alpha, dxVal, dxInd, dy, idxBase);
# 
#     // Copy result back to host
#     hipMemcpy(hy, dy, sizeof(double) * 9, hipMemcpyDeviceToHost);
# 
#     // Clear hipSPARSE
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dxInd);
#     hipFree(dxVal);
#     hipFree(dy);
# \endcode
cdef hipsparseStatus_t hipsparseSaxpyi(void * handle,int nnz,const float * alpha,const float * xVal,const int * xInd,float * y,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseDaxpyi(void * handle,int nnz,const double * alpha,const double * xVal,const int * xInd,double * y,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseCaxpyi(void * handle,int nnz,float2 * alpha,float2 * xVal,const int * xInd,float2 * y,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseZaxpyi(void * handle,int nnz,double2 * alpha,double2 * xVal,const int * xInd,double2 * y,hipsparseIndexBase_t idxBase)


#  \ingroup level1_module
# \brief Compute the dot product of a sparse vector with a dense vector.
# 
# \details
# \p hipsparseXdoti computes the dot product of the sparse vector \f$x\f$ with the
# dense vector \f$y\f$, such that
# \f[
#   result := y^T x
# \f]
# 
# \code{.c}
#     result = 0
#     for(i = 0; i < nnz; ++i)
#     {
#         result += xVal[i] * y[xInd[i]];
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#     // Number of non-zeros of the sparse vector
#     int nnz = 3;
# 
#     // Sparse index vector
#     int hxInd[3] = {0, 3, 5};
# 
#     // Sparse value vector
#     float hxVal[3] = {1.0f, 2.0f, 3.0f};
# 
#     // Dense vector
#     float hy[9] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f};
# 
#     // Index base
#     hipsparseIndexBase_t idxBase = HIPSPARSE_INDEX_BASE_ZERO;
# 
#     // Offload data to device
#     int* dxInd;
#     float*        dxVal;
#     float*        dy;
# 
#     hipMalloc((void**)&dxInd, sizeof(int) * nnz);
#     hipMalloc((void**)&dxVal, sizeof(float) * nnz);
#     hipMalloc((void**)&dy, sizeof(float) * 9);
# 
#     hipMemcpy(dxInd, hxInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dxVal, hxVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dy, hy, sizeof(float) * 9, hipMemcpyHostToDevice);
# 
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // Call sdoti to compute the dot product
#     float dot;
#     hipsparseSdoti(handle, nnz, dxVal, dxInd, dy, &dot, idxBase);
# 
#     // Clear hipSPARSE
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dxInd);
#     hipFree(dxVal);
#     hipFree(dy);
# \endcode
cdef hipsparseStatus_t hipsparseSdoti(void * handle,int nnz,const float * xVal,const int * xInd,const float * y,float * result,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseDdoti(void * handle,int nnz,const double * xVal,const int * xInd,const double * y,double * result,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseCdoti(void * handle,int nnz,float2 * xVal,const int * xInd,float2 * y,float2 * result,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseZdoti(void * handle,int nnz,double2 * xVal,const int * xInd,double2 * y,double2 * result,hipsparseIndexBase_t idxBase)


#  \ingroup level1_module
# \brief Compute the dot product of a complex conjugate sparse vector with a dense
# vector.
# 
# \details
# \p hipsparseXdotci computes the dot product of the complex conjugate sparse vector
# \f$x\f$ with the dense vector \f$y\f$, such that
# \f[
#   result := \bar{x}^H y
# \f]
# 
# \code{.c}
#     result = 0
#     for(i = 0; i < nnz; ++i)
#     {
#         result += conj(xVal[i]) * y[xInd[i]];
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseCdotci(void * handle,int nnz,float2 * xVal,const int * xInd,float2 * y,float2 * result,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseZdotci(void * handle,int nnz,double2 * xVal,const int * xInd,double2 * y,double2 * result,hipsparseIndexBase_t idxBase)


#  \ingroup level1_module
# \brief Gather elements from a dense vector and store them into a sparse vector.
# 
# \details
# \p hipsparseXgthr gathers the elements that are listed in \p xInd from the dense
# vector \f$y\f$ and stores them in the sparse vector \f$x\f$.
# 
# \code{.c}
#     for(i = 0; i < nnz; ++i)
#     {
#         xVal[i] = y[xInd[i]];
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#     // Number of non-zeros of the sparse vector
#     int nnz = 3;
# 
#     // Sparse index vector
#     int hxInd[3] = {0, 3, 5};
# 
#     // Sparse value vector
#     float hxVal[3];
# 
#     // Dense vector
#     float hy[9] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};
# 
#     // Index base
#     hipsparseIndexBase_t idxBase = HIPSPARSE_INDEX_BASE_ZERO;
# 
#     // Offload data to device
#     int* dxInd;
#     float*         dxVal;
#     float*         dy;
# 
#     hipMalloc((void**)&dxInd, sizeof(int) * nnz);
#     hipMalloc((void**)&dxVal, sizeof(float) * nnz);
#     hipMalloc((void**)&dy, sizeof(float) * 9);
# 
#     hipMemcpy(dxInd, hxInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dy, hy, sizeof(float) * 9, hipMemcpyHostToDevice);
# 
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // Call sgthr
#     hipsparseSgthr(handle, nnz, dy, dxVal, dxInd, idxBase);
# 
#     // Copy result back to host
#     hipMemcpy(hxVal, dxVal, sizeof(float) * nnz, hipMemcpyDeviceToHost);
# 
#     // Clear hipSPARSE
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dxInd);
#     hipFree(dxVal);
#     hipFree(dy);
# \endcode
cdef hipsparseStatus_t hipsparseSgthr(void * handle,int nnz,const float * y,float * xVal,const int * xInd,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseDgthr(void * handle,int nnz,const double * y,double * xVal,const int * xInd,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseCgthr(void * handle,int nnz,float2 * y,float2 * xVal,const int * xInd,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseZgthr(void * handle,int nnz,double2 * y,double2 * xVal,const int * xInd,hipsparseIndexBase_t idxBase)


#  \ingroup level1_module
# \brief Gather and zero out elements from a dense vector and store them into a sparse
# vector.
# 
# \details
# \p hipsparseXgthrz gathers the elements that are listed in \p xInd from the dense
# vector \f$y\f$ and stores them in the sparse vector \f$x\f$. The gathered elements
# in \f$y\f$ are replaced by zero.
# 
# \code{.c}
#     for(i = 0; i < nnz; ++i)
#     {
#         xVal[i]    = y[xInd[i]];
#         y[xInd[i]] = 0;
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSgthrz(void * handle,int nnz,float * y,float * xVal,const int * xInd,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseDgthrz(void * handle,int nnz,double * y,double * xVal,const int * xInd,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseCgthrz(void * handle,int nnz,float2 * y,float2 * xVal,const int * xInd,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseZgthrz(void * handle,int nnz,double2 * y,double2 * xVal,const int * xInd,hipsparseIndexBase_t idxBase)


#  \ingroup level1_module
# \brief Apply Givens rotation to a dense and a sparse vector.
# 
# \details
# \p hipsparseXroti applies the Givens rotation matrix \f$G\f$ to the sparse vector
# \f$x\f$ and the dense vector \f$y\f$, where
# \f[
#   G = \begin{pmatrix} c & s \\ -s & c \end{pmatrix}
# \f]
# 
# \code{.c}
#     for(i = 0; i < nnz; ++i)
#     {
#         x_tmp = xVal[i];
#         y_tmp = y[xInd[i]];
# 
#         xVal[i]    = c * x_tmp + s * y_tmp;
#         y[xInd[i]] = c * y_tmp - s * x_tmp;
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#     // Number of non-zeros of the sparse vector
#     int nnz = 3;
# 
#     // Sparse index vector
#     int hxInd[3] = {0, 3, 5};
# 
#     // Sparse value vector
#     float hxVal[3] = {1.0f, 2.0f, 3.0f};
# 
#     // Dense vector
#     float hy[9] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f};
# 
#     // c and s
#     float c = 3.7;
#     float s = 1.3;
# 
#     // Index base
#     hipsparseIndexBase_t idxBase = HIPSPARSE_INDEX_BASE_ZERO;
# 
#     // Offload data to device
#     int* dxInd;
#     float*        dxVal;
#     float*        dy;
# 
#     hipMalloc((void**)&dxInd, sizeof(int) * nnz);
#     hipMalloc((void**)&dxVal, sizeof(float) * nnz);
#     hipMalloc((void**)&dy, sizeof(float) * 9);
# 
#     hipMemcpy(dxInd, hxInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dxVal, hxVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dy, hy, sizeof(float) * 9, hipMemcpyHostToDevice);
# 
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // Call sroti
#     hipsparseSroti(handle, nnz, dxVal, dxInd, dy, &c, &s, idxBase);
# 
#     // Copy result back to host
#     hipMemcpy(hxVal, dxVal, sizeof(float) * nnz, hipMemcpyDeviceToHost);
#     hipMemcpy(hy, dy, sizeof(float) * 9, hipMemcpyDeviceToHost);
# 
#     // Clear hipSPARSE
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dxInd);
#     hipFree(dxVal);
#     hipFree(dy);
# \endcode
cdef hipsparseStatus_t hipsparseSroti(void * handle,int nnz,float * xVal,const int * xInd,float * y,const float * c,const float * s,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseDroti(void * handle,int nnz,double * xVal,const int * xInd,double * y,const double * c,const double * s,hipsparseIndexBase_t idxBase)


#  \ingroup level1_module
# \brief Scatter elements from a dense vector across a sparse vector.
# 
# \details
# \p hipsparseXsctr scatters the elements that are listed in \p xInd from the sparse
# vector \f$x\f$ into the dense vector \f$y\f$. Indices of \f$y\f$ that are not listed
# in \p xInd remain unchanged.
# 
# \code{.c}
#     for(i = 0; i < nnz; ++i)
#     {
#         y[xInd[i]] = xVal[i];
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#     // Number of non-zeros of the sparse vector
#     int nnz = 3;
# 
#     // Sparse index vector
#     int hxInd[3] = {0, 3, 5};
# 
#     // Sparse value vector
#     float hxVal[3] = {9.0, 2.0, 3.0};
# 
#     // Dense vector
#     float hy[9] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};
# 
#     // Index base
#     hipsparseIndexBase_t idxBase = HIPSPARSE_INDEX_BASE_ZERO;
# 
#     // Offload data to device
#     int* dxInd;
#     float*         dxVal;
#     float*         dy;
# 
#     hipMalloc((void**)&dxInd, sizeof(int) * nnz);
#     hipMalloc((void**)&dxVal, sizeof(float) * nnz);
#     hipMalloc((void**)&dy, sizeof(float) * 9);
# 
#     hipMemcpy(dxInd, hxInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dxVal, hxVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dy, hy, sizeof(float) * 9, hipMemcpyHostToDevice);
# 
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // Call ssctr
#     hipsparseSsctr(handle, nnz, dxVal, dxInd, dy, idxBase);
# 
#     // Copy result back to host
#     hipMemcpy(hy, dy, sizeof(float) * 9, hipMemcpyDeviceToHost);
# 
#     // Clear hipSPARSE
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dxInd);
#     hipFree(dxVal);
#     hipFree(dy);
# \endcode
cdef hipsparseStatus_t hipsparseSsctr(void * handle,int nnz,const float * xVal,const int * xInd,float * y,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseDsctr(void * handle,int nnz,const double * xVal,const int * xInd,double * y,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseCsctr(void * handle,int nnz,float2 * xVal,const int * xInd,float2 * y,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseZsctr(void * handle,int nnz,double2 * xVal,const int * xInd,double2 * y,hipsparseIndexBase_t idxBase)


#  \ingroup level2_module
# \brief Sparse matrix vector multiplication using CSR storage format
# 
# \details
# \p hipsparseXcsrmv multiplies the scalar \f$\alpha\f$ with a sparse \f$m \times n\f$
# matrix, defined in CSR storage format, and the dense vector \f$x\f$ and adds the
# result to the dense vector \f$y\f$ that is multiplied by the scalar \f$\beta\f$,
# such that
# \f[
#   y := \alpha \cdot op(A) \cdot x + \beta \cdot y,
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# \code{.c}
#     for(i = 0; i < m; ++i)
#     {
#         y[i] = beta * y[i];
# 
#         for(j = csrRowPtr[i]; j < csrRowPtr[i + 1]; ++j)
#         {
#             y[i] = y[i] + alpha * csrVal[j] * x[csrColInd[j]];
#         }
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Currently, only \p trans == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE is supported.
# 
# \par Example
# \code{.c}
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // alpha * ( 1.0  0.0  2.0 ) * ( 1.0 ) + beta * ( 4.0 ) = (  31.1 )
#     //         ( 3.0  0.0  4.0 ) * ( 2.0 )          ( 5.0 ) = (  62.0 )
#     //         ( 5.0  6.0  0.0 ) * ( 3.0 )          ( 6.0 ) = (  70.7 )
#     //         ( 7.0  0.0  8.0 ) *                  ( 7.0 ) = ( 123.8 )
# 
#     int m = 4;
#     int n = 3;
#     int nnz = 8;
# 
#     // CSR row pointers
#     int hcsrRowPtr[5] = {0, 2, 4, 6, 8};
# 
#     // CSR column indices
#     int hcsrColInd[8] = {0, 2, 0, 2, 0, 1, 0, 2};
# 
#     // CSR values
#     double hcsrVal[8] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};
# 
#     // Transposition of the matrix
#     hipsparseOperation_t trans = HIPSPARSE_OPERATION_NON_TRANSPOSE;
# 
#     // Scalar alpha and beta
#     double alpha = 3.7;
#     double beta  = 1.3;
# 
#     // x and y
#     double hx[3] = {1.0, 2.0, 3.0};
#     double hy[4] = {4.0, 5.0, 6.0, 7.0};
# 
#     // Matrix descriptor
#     hipsparseMatDescr_t descr;
#     hipsparseCreateMatDescr(&descr);
# 
#     // Offload data to device
#     int* dcsrRowPtr;
#     int* dcsrColInd;
#     double*        dcsrVal;
#     double*        dx;
#     double*        dy;
# 
#     hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#     hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#     hipMalloc((void**)&dcsrVal, sizeof(double) * nnz);
#     hipMalloc((void**)&dx, sizeof(double) * n);
#     hipMalloc((void**)&dy, sizeof(double) * m);
# 
#     hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#     hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dcsrVal, hcsrVal, sizeof(double) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dx, hx, sizeof(double) * n, hipMemcpyHostToDevice);
#     hipMemcpy(dy, hy, sizeof(double) * m, hipMemcpyHostToDevice);
# 
#     // Call dcsrmv to perform y = alpha * A x + beta * y
#     hipsparseDcsrmv(handle,
#                     trans,
#                     m,
#                     n,
#                     nnz,
#                     &alpha,
#                     descr,
#                     dcsrVal,
#                     dcsrRowPtr,
#                     dcsrColInd,
#                     dx,
#                     &beta,
#                     dy);
# 
#     // Copy result back to host
#     hipMemcpy(hy, dy, sizeof(double) * m, hipMemcpyDeviceToHost);
# 
#     // Clear hipSPARSE
#     hipsparseDestroyMatDescr(descr);
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dcsrRowPtr);
#     hipFree(dcsrColInd);
#     hipFree(dcsrVal);
#     hipFree(dx);
#     hipFree(dy);
# \endcode
cdef hipsparseStatus_t hipsparseScsrmv(void * handle,hipsparseOperation_t transA,int m,int n,int nnz,const float * alpha,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const float * x,const float * beta,float * y)



cdef hipsparseStatus_t hipsparseDcsrmv(void * handle,hipsparseOperation_t transA,int m,int n,int nnz,const double * alpha,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const double * x,const double * beta,double * y)



cdef hipsparseStatus_t hipsparseCcsrmv(void * handle,hipsparseOperation_t transA,int m,int n,int nnz,float2 * alpha,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,float2 * x,float2 * beta,float2 * y)



cdef hipsparseStatus_t hipsparseZcsrmv(void * handle,hipsparseOperation_t transA,int m,int n,int nnz,double2 * alpha,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,double2 * x,double2 * beta,double2 * y)


#  \ingroup level2_module
# \brief Sparse triangular solve using CSR storage format
# 
# \details
# \p hipsparseXcsrsv2_zeroPivot returns \ref HIPSPARSE_STATUS_ZERO_PIVOT, if either a
# structural or numerical zero has been found during hipsparseScsrsv2_solve(),
# hipsparseDcsrsv2_solve(), hipsparseCcsrsv2_solve() or hipsparseZcsrsv2_solve()
# computation. The first zero pivot \f$j\f$ at \f$A_{j,j}\f$ is stored in \p position,
# using same index base as the CSR matrix.
# 
# \p position can be in host or device memory. If no zero pivot has been found,
# \p position is set to -1 and \ref HIPSPARSE_STATUS_SUCCESS is returned instead.
# 
# \note \p hipsparseXcsrsv2_zeroPivot is a blocking function. It might influence
# performance negatively.
cdef hipsparseStatus_t hipsparseXcsrsv2_zeroPivot(void * handle,csrsv2Info_t info,int * position)


#  \ingroup level2_module
# \brief Sparse triangular solve using CSR storage format
# 
# \details
# \p hipsparseXcsrsv2_bufferSize returns the size of the temporary storage buffer in bytes
# that is required by hipsparseScsrsv2_analysis(), hipsparseDcsrsv2_analysis(),
# hipsparseCcsrsv2_analysis(), hipsparseZcsrsv2_analysis(), hipsparseScsrsv2_solve(),
# hipsparseDcsrsv2_solve(), hipsparseCcsrsv2_solve() and hipsparseZcsrsv2_solve(). The
# temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseScsrsv2_bufferSize(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsrsv2_bufferSize(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsrsv2_bufferSize(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsrsv2_bufferSize(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,int * pBufferSizeInBytes)


#  \ingroup level2_module
# \brief Sparse triangular solve using CSR storage format
# 
# \details
# \p hipsparseXcsrsv2_bufferSizeExt returns the size of the temporary storage buffer in bytes
# that is required by hipsparseScsrsv2_analysis(), hipsparseDcsrsv2_analysis(),
# hipsparseCcsrsv2_analysis(), hipsparseZcsrsv2_analysis(), hipsparseScsrsv2_solve(),
# hipsparseDcsrsv2_solve(), hipsparseCcsrsv2_solve() and hipsparseZcsrsv2_solve(). The
# temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseScsrsv2_bufferSizeExt(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsrsv2_bufferSizeExt(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsrsv2_bufferSizeExt(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsrsv2_bufferSizeExt(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,unsigned long * pBufferSizeInBytes)


#  \ingroup level2_module
# \brief Sparse triangular solve using CSR storage format
# 
# \details
# \p hipsparseXcsrsv2_analysis performs the analysis step for hipsparseScsrsv2_solve(),
# hipsparseDcsrsv2_solve(), hipsparseCcsrsv2_solve() and hipsparseZcsrsv2_solve().
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseScsrsv2_analysis(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsrsv2_analysis(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsrsv2_analysis(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsrsv2_analysis(void * handle,hipsparseOperation_t transA,int m,int nnz,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup level2_module
# \brief Sparse triangular solve using CSR storage format
# 
# \details
# \p hipsparseXcsrsv2_solve solves a sparse triangular linear system of a sparse
# \f$m \times m\f$ matrix, defined in CSR storage format, a dense solution vector
# \f$y\f$ and the right-hand side \f$x\f$ that is multiplied by \f$\alpha\f$, such that
# \f[
#   op(A) \cdot y = \alpha \cdot x,
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# \p hipsparseXcsrsv2_solve requires a user allocated temporary buffer. Its size is
# returned by hipsparseXcsrsv2_bufferSize() or hipsparseXcsrsv2_bufferSizeExt().
# Furthermore, analysis meta data is required. It can be obtained by
# hipsparseXcsrsv2_analysis(). \p hipsparseXcsrsv2_solve reports the first zero pivot
# (either numerical or structural zero). The zero pivot status can be checked calling
# hipsparseXcsrsv2_zeroPivot(). If
# \ref hipsparseDiagType_t == \ref HIPSPARSE_DIAG_TYPE_UNIT, no zero pivot will be
# reported, even if \f$A_{j,j} = 0\f$ for some \f$j\f$.
# 
# \note
# The sparse CSR matrix has to be sorted. This can be achieved by calling
# hipsparseXcsrsort().
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Currently, only \p trans == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE and
# \p trans == \ref HIPSPARSE_OPERATION_TRANSPOSE is supported.
# 
# \par Example
# \code{.c}
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // alpha * ( 1.0  0.0  2.0  0.0 ) * ( x_0 ) = ( 32.0 )
#     //         ( 3.0  2.0  4.0  1.0 ) * ( x_1 ) = ( 14.7 )
#     //         ( 5.0  6.0  1.0  3.0 ) * ( x_2 ) = ( 33.6 )
#     //         ( 7.0  0.0  8.0  0.6 ) * ( x_3 ) = ( 10.0 )
# 
#     int m = 4;
#     int nnz = 13;
# 
#     // CSR row pointers
#     int hcsrRowPtr[5] = {0, 2, 6, 10, 13};
# 
#     // CSR column indices
#     int hcsrColInd[13] = {0, 2, 0, 1, 2, 3, 0, 1, 2, 3, 0, 2, 3};
# 
#     // CSR values
#     double hcsrVal[13] = {1.0, 2.0, 3.0, 2.0, 4.0, 1.0, 5.0, 6.0, 1.0, 3.0, 7.0, 8.0, 0.6};
# 
#     // Transposition of the matrix
#     hipsparseOperation_t trans = HIPSPARSE_OPERATION_NON_TRANSPOSE;
#     hipsparseSolvePolicy_t policy = HIPSPARSE_SOLVE_POLICY_USE_LEVEL;
# 
#     // Scalar alpha
#     double alpha = 1.0;
# 
#     // f and x
#     double hf[4] = {32.0, 14.7, 33.6, 10.0};
#     double hx[4];
# 
#     // Matrix descriptor
#     hipsparseMatDescr_t descr;
#     hipsparseCreateMatDescr(&descr);
# 
#     // Set index base on descriptor
#     hipsparseSetMatIndexBase(descr, HIPSPARSE_INDEX_BASE_ZERO);
# 
#     // Set fill mode on descriptor
#     hipsparseSetMatFillMode(descr, HIPSPARSE_FILL_MODE_LOWER);
# 
#     // Set diag type on descriptor
#     hipsparseSetMatDiagType(descr, HIPSPARSE_DIAG_TYPE_UNIT);
# 
#     // Csrsv info
#     csrsv2Info_t info;
#     hipsparseCreateCsrsv2Info(&info);
# 
#     // Offload data to device
#     int* dcsrRowPtr;
#     int* dcsrColInd;
#     double*        dcsrVal;
#     double*        df;
#     double*        dx;
# 
#     hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#     hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#     hipMalloc((void**)&dcsrVal, sizeof(double) * nnz);
#     hipMalloc((void**)&df, sizeof(double) * m);
#     hipMalloc((void**)&dx, sizeof(double) * m);
# 
#     hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#     hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dcsrVal, hcsrVal, sizeof(double) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(df, hf, sizeof(double) * m, hipMemcpyHostToDevice);
# 
#     int bufferSize = 0;
#     hipsparseDcsrsv2_bufferSize(handle,
#                                 trans,
#                                 m,
#                                 nnz,
#                                 descr,
#                                 dcsrVal,
#                                 dcsrRowPtr,
#                                 dcsrColInd,
#                                 info,
#                                 &bufferSize);
# 
#     void* dbuffer = nullptr;
#     hipMalloc((void**)&dbuffer, bufferSize);
# 
#     hipsparseDcsrsv2_analysis(handle,
#                               trans,
#                               m,
#                               nnz,
#                               descr,
#                               dcsrVal,
#                               dcsrRowPtr,
#                               dcsrColInd,
#                               info,
#                               policy,
#                               dbuffer);
# 
#     // Call dcsrsv to perform alpha * A * x = f
#     hipsparseDcsrsv2_solve(handle,
#                            trans,
#                            m,
#                            nnz,
#                            &alpha,
#                            descr,
#                            dcsrVal,
#                            dcsrRowPtr,
#                            dcsrColInd,
#                            info,
#                            df,
#                            dx,
#                            policy,
#                            dbuffer);
# 
#     // Copy result back to host
#     hipMemcpy(hx, dx, sizeof(double) * m, hipMemcpyDeviceToHost);
# 
#     // Clear hipSPARSE
#     hipsparseDestroyMatDescr(descr);
#     hipsparseDestroyCsrsv2Info(info);
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dcsrRowPtr);
#     hipFree(dcsrColInd);
#     hipFree(dcsrVal);
#     hipFree(df);
#     hipFree(dx);
#     hipFree(dbuffer);
# \endcode
cdef hipsparseStatus_t hipsparseScsrsv2_solve(void * handle,hipsparseOperation_t transA,int m,int nnz,const float * alpha,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,const float * f,float * x,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsrsv2_solve(void * handle,hipsparseOperation_t transA,int m,int nnz,const double * alpha,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,const double * f,double * x,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsrsv2_solve(void * handle,hipsparseOperation_t transA,int m,int nnz,float2 * alpha,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,float2 * f,float2 * x,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsrsv2_solve(void * handle,hipsparseOperation_t transA,int m,int nnz,double2 * alpha,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrsv2Info_t info,double2 * f,double2 * x,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup level2_module
# \brief Sparse matrix vector multiplication using HYB storage format
# 
# \details
# \p hipsparseXhybmv multiplies the scalar \f$\alpha\f$ with a sparse \f$m \times n\f$
# matrix, defined in HYB storage format, and the dense vector \f$x\f$ and adds the
# result to the dense vector \f$y\f$ that is multiplied by the scalar \f$\beta\f$,
# such that
# \f[
#   y := \alpha \cdot op(A) \cdot x + \beta \cdot y,
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Currently, only \p trans == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE is supported.
# 
# \par Example
# \code{.c}
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // A sparse matrix
#     // 1 0 3 4
#     // 0 0 5 1
#     // 0 2 0 0
#     // 4 0 0 8
#     int hAptr[5] = {0, 3, 5, 6, 8};
#     int hAcol[8] = {0, 2, 3, 2, 3, 1, 0, 3};
#     double hAval[8] = {1.0, 3.0, 4.0, 5.0, 1.0, 2.0, 4.0, 8.0};
# 
#     int m = 4;
#     int n = 4;
#     int nnz = 8;
# 
#     double halpha = 1.0;
#     double hbeta  = 0.0;
# 
#     double  hx[4] = {1.0, 2.0, 3.0, 4.0};
#     double  hy[4] = {4.0, 5.0, 6.0, 7.0};
# 
#     // Matrix descriptor
#     hipsparseMatDescr_t descrA;
#     hipsparseCreateMatDescr(&descrA);
# 
#     // Offload data to device
#     int* dAptr = NULL;
#     int* dAcol = NULL;
#     double*        dAval = NULL;
#     double*        dx    = NULL;
#     double*        dy    = NULL;
# 
#     hipMalloc((void**)&dAptr, sizeof(int) * (m + 1));
#     hipMalloc((void**)&dAcol, sizeof(int) * nnz);
#     hipMalloc((void**)&dAval, sizeof(double) * nnz);
#     hipMalloc((void**)&dx, sizeof(double) * n);
#     hipMalloc((void**)&dy, sizeof(double) * m);
# 
#     hipMemcpy(dAptr, hAptr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#     hipMemcpy(dAcol, hAcol, sizeof(int) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dAval, hAval, sizeof(double) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dx, hx, sizeof(double) * n, hipMemcpyHostToDevice);
# 
#     // Convert CSR matrix to HYB format
#     hipsparseHybMat_t hybA;
#     hipsparseCreateHybMat(&hybA);
# 
#     hipsparseDcsr2hyb(handle, m, n, descrA, dAval, dAptr, dAcol, hybA, 0, HIPSPARSE_HYB_PARTITION_AUTO);
# 
#     // Clean up CSR structures
#     hipFree(dAptr);
#     hipFree(dAcol);
#     hipFree(dAval);
# 
#     // Call hipsparse hybmv
#     hipsparseDhybmv(handle, HIPSPARSE_OPERATION_NON_TRANSPOSE, &halpha, descrA, hybA, dx, &hbeta, dy);
# 
#     // Copy result back to host
#     hipMemcpy(hy, dy, sizeof(double) * m, hipMemcpyDeviceToHost);
# 
#     // Clear up on device
#     hipsparseDestroyHybMat(hybA);
#     hipsparseDestroyMatDescr(descrA);
#     hipsparseDestroy(handle);
# 
#     hipFree(dx);
#     hipFree(dy);
# \endcode
cdef hipsparseStatus_t hipsparseShybmv(void * handle,hipsparseOperation_t transA,const float * alpha,void *const descrA,void *const hybA,const float * x,const float * beta,float * y)



cdef hipsparseStatus_t hipsparseDhybmv(void * handle,hipsparseOperation_t transA,const double * alpha,void *const descrA,void *const hybA,const double * x,const double * beta,double * y)



cdef hipsparseStatus_t hipsparseChybmv(void * handle,hipsparseOperation_t transA,float2 * alpha,void *const descrA,void *const hybA,float2 * x,float2 * beta,float2 * y)



cdef hipsparseStatus_t hipsparseZhybmv(void * handle,hipsparseOperation_t transA,double2 * alpha,void *const descrA,void *const hybA,double2 * x,double2 * beta,double2 * y)


#  \ingroup level2_module
# \brief Sparse matrix vector multiplication using BSR storage format
# 
# \details
# \p hipsparseXbsrmv multiplies the scalar \f$\alpha\f$ with a sparse
# \f$(mb \cdot \text{blockDim}) \times (nb \cdot \text{blockDim})\f$
# matrix, defined in BSR storage format, and the dense vector \f$x\f$ and adds the
# result to the dense vector \f$y\f$ that is multiplied by the scalar \f$\beta\f$,
# such that
# \f[
#   y := \alpha \cdot op(A) \cdot x + \beta \cdot y,
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Currently, only \p trans == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE is supported.
# 
# \par Example
# \code{.c}
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // alpha * ( 1.0  0.0  2.0 ) * ( 1.0 ) + beta * ( 4.0 ) = (  31.1 )
#     //         ( 3.0  0.0  4.0 ) * ( 2.0 )          ( 5.0 ) = (  62.0 )
#     //         ( 5.0  6.0  0.0 ) * ( 3.0 )          ( 6.0 ) = (  70.7 )
#     //         ( 7.0  0.0  8.0 ) *                  ( 7.0 ) = ( 123.8 )
# 
#     // BSR block dimension
#     int bsr_dim = 2;
# 
#     // Number of block rows and columns
#     int mb = 2;
#     int nb = 2;
# 
#     // Number of non-zero blocks
#     int nnzb = 4;
# 
#     // BSR row pointers
#     int hbsrRowPtr[3] = {0, 2, 4};
# 
#     // BSR column indices
#     int hbsrColInd[4] = {0, 1, 0, 1};
# 
#     // BSR values
#     double hbsrVal[16]
#       = {1.0, 3.0, 0.0, 0.0, 2.0, 4.0, 0.0, 0.0, 5.0, 7.0, 6.0, 0.0, 0.0, 8.0, 0.0, 0.0};
# 
#     // Block storage in column major
#     hipsparseDirection_t dir = HIPSPARSE_DIRECTION_COLUMN;
# 
#     // Transposition of the matrix
#     hipsparseOperation_t trans = HIPSPARSE_OPERATION_NON_TRANSPOSE;
# 
#     // Scalar alpha and beta
#     double alpha = 3.7;
#     double beta  = 1.3;
# 
#     // x and y
#     double hx[4] = {1.0, 2.0, 3.0, 0.0};
#     double hy[4] = {4.0, 5.0, 6.0, 7.0};
# 
#     // Matrix descriptor
#     hipsparseMatDescr_t descr;
#     hipsparseCreateMatDescr(&descr);
# 
#     // Offload data to device
#     int* dbsrRowPtr;
#     int* dbsrColInd;
#     double*        dbsrVal;
#     double*        dx;
#     double*        dy;
# 
#     hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
#     hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
#     hipMalloc((void**)&dbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim);
#     hipMalloc((void**)&dx, sizeof(double) * nb * bsr_dim);
#     hipMalloc((void**)&dy, sizeof(double) * mb * bsr_dim);
# 
#     hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
#     hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
#     hipMemcpy(dbsrVal, hbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim, hipMemcpyHostToDevice);
#     hipMemcpy(dx, hx, sizeof(double) * nb * bsr_dim, hipMemcpyHostToDevice);
#     hipMemcpy(dy, hy, sizeof(double) * mb * bsr_dim, hipMemcpyHostToDevice);
# 
#     // Call dbsrmv to perform y = alpha * A x + beta * y
#     hipsparseDbsrmv(handle,
#                     dir,
#                     trans,
#                     mb,
#                     nb,
#                     nnzb,
#                     &alpha,
#                     descr,
#                     dbsrVal,
#                     dbsrRowPtr,
#                     dbsrColInd,
#                     bsr_dim,
#                     dx,
#                     &beta,
#                     dy);
# 
#     // Copy result back to host
#     hipMemcpy(hy, dy, sizeof(double) * mb * bsr_dim, hipMemcpyDeviceToHost);
# 
#     // Clear hipSPARSE
#     hipsparseDestroyMatDescr(descr);
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dbsrRowPtr);
#     hipFree(dbsrColInd);
#     hipFree(dbsrVal);
#     hipFree(dx);
#     hipFree(dy);
# \endcode
cdef hipsparseStatus_t hipsparseSbsrmv(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nb,int nnzb,const float * alpha,void *const descrA,const float * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,const float * x,const float * beta,float * y)



cdef hipsparseStatus_t hipsparseDbsrmv(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nb,int nnzb,const double * alpha,void *const descrA,const double * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,const double * x,const double * beta,double * y)



cdef hipsparseStatus_t hipsparseCbsrmv(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nb,int nnzb,float2 * alpha,void *const descrA,float2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,float2 * x,float2 * beta,float2 * y)



cdef hipsparseStatus_t hipsparseZbsrmv(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nb,int nnzb,double2 * alpha,void *const descrA,double2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,double2 * x,double2 * beta,double2 * y)


#  \ingroup level2_module
# \brief Sparse matrix vector multiplication with mask operation using BSR storage format
# 
# \details
# \p hipsparseXbsrxmv multiplies the scalar \f$\alpha\f$ with a sparse
# \f$(mb \cdot \text{blockDim}) \times (nb \cdot \text{blockDim})\f$
# modified matrix, defined in BSR storage format, and the dense vector \f$x\f$ and adds the
# result to the dense vector \f$y\f$ that is multiplied by the scalar \f$\beta\f$,
# such that
# \f[
#   y := \left( \alpha \cdot op(A) \cdot x + \beta \cdot y \right)\left( \text{mask} \right),
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# The \f$\text{mask}\f$ is defined as an array of block row indices.
# The input sparse matrix is defined with a modified BSR storage format where the beginning and the end of each row
# is defined with two arrays, \p bsrRowPtr and \p bsr_end_ptr (both of size \p mb), rather the usual \p bsrRowPtr of size \p mb + 1.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Currently, only \p trans == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE is supported.
# Currently, \p blockDim == 1 is not supported.
cdef hipsparseStatus_t hipsparseSbsrxmv(void * handle,hipsparseDirection_t dir,hipsparseOperation_t trans,int sizeOfMask,int mb,int nb,int nnzb,const float * alpha,void *const descr,const float * bsrVal,const int * bsrMaskPtr,const int * bsrRowPtr,const int * bsrEndPtr,const int * bsrColInd,int blockDim,const float * x,const float * beta,float * y)



cdef hipsparseStatus_t hipsparseDbsrxmv(void * handle,hipsparseDirection_t dir,hipsparseOperation_t trans,int sizeOfMask,int mb,int nb,int nnzb,const double * alpha,void *const descr,const double * bsrVal,const int * bsrMaskPtr,const int * bsrRowPtr,const int * bsrEndPtr,const int * bsrColInd,int blockDim,const double * x,const double * beta,double * y)



cdef hipsparseStatus_t hipsparseCbsrxmv(void * handle,hipsparseDirection_t dir,hipsparseOperation_t trans,int sizeOfMask,int mb,int nb,int nnzb,float2 * alpha,void *const descr,float2 * bsrVal,const int * bsrMaskPtr,const int * bsrRowPtr,const int * bsrEndPtr,const int * bsrColInd,int blockDim,float2 * x,float2 * beta,float2 * y)



cdef hipsparseStatus_t hipsparseZbsrxmv(void * handle,hipsparseDirection_t dir,hipsparseOperation_t trans,int sizeOfMask,int mb,int nb,int nnzb,double2 * alpha,void *const descr,double2 * bsrVal,const int * bsrMaskPtr,const int * bsrRowPtr,const int * bsrEndPtr,const int * bsrColInd,int blockDim,double2 * x,double2 * beta,double2 * y)


#  \ingroup level2_module
# \brief Sparse triangular solve using BSR storage format
# 
# \details
# \p hipsparseXbsrsv2_zeroPivot returns \ref HIPSPARSE_STATUS_ZERO_PIVOT, if either a
# structural or numerical zero has been found during hipsparseXbsrsv2_analysis() or
# hipsparseXbsrsv2_solve() computation. The first zero pivot \f$j\f$ at \f$A_{j,j}\f$
# is stored in \p position, using same index base as the BSR matrix.
# 
# \p position can be in host or device memory. If no zero pivot has been found,
# \p position is set to -1 and \ref HIPSPARSE_STATUS_SUCCESS is returned instead.
# 
# \note \p hipsparseXbsrsv2_zeroPivot is a blocking function. It might influence
# performance negatively.
cdef hipsparseStatus_t hipsparseXbsrsv2_zeroPivot(void * handle,bsrsv2Info_t info,int * position)


#  \ingroup level2_module
# \brief Sparse triangular solve using BSR storage format
# 
# \details
# \p hipsparseXbsrsv2_bufferSize returns the size of the temporary storage buffer in bytes
# that is required by hipsparseXbsrsv2_analysis() and hipsparseXbsrsv2_solve(). The
# temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSbsrsv2_bufferSize(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,float * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDbsrsv2_bufferSize(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,double * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCbsrsv2_bufferSize(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,float2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZbsrsv2_bufferSize(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,double2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,int * pBufferSizeInBytes)


#  \ingroup level2_module
# \brief Sparse triangular solve using BSR storage format
# 
# \details
# \p hipsparseXbsrsv2_bufferSizeExt returns the size of the temporary storage buffer in bytes
# that is required by hipsparseXbsrsv2_analysis() and hipsparseXbsrsv2_solve(). The
# temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSbsrsv2_bufferSizeExt(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,float * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDbsrsv2_bufferSizeExt(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,double * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCbsrsv2_bufferSizeExt(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,float2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZbsrsv2_bufferSizeExt(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,double2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,unsigned long * pBufferSizeInBytes)


#  \ingroup level2_module
# \brief Sparse triangular solve using BSR storage format
# 
# \details
# \p hipsparseXbsrsv2_analysis performs the analysis step for hipsparseXbsrsv2_solve().
# 
# \note
# If the matrix sparsity pattern changes, the gathered information will become invalid.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSbsrsv2_analysis(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,const float * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDbsrsv2_analysis(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,const double * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCbsrsv2_analysis(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,float2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZbsrsv2_analysis(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,void *const descrA,double2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup level2_module
# \brief Sparse triangular solve using BSR storage format
# 
# \details
# \p hipsparseXbsrsv2_solve solves a sparse triangular linear system of a sparse
# \f$m \times m\f$ matrix, defined in BSR storage format, a dense solution vector
# \f$y\f$ and the right-hand side \f$x\f$ that is multiplied by \f$\alpha\f$, such that
# \f[
#   op(A) \cdot y = \alpha \cdot x,
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# \p hipsparseXbsrsv2_solve requires a user allocated temporary buffer. Its size is
# returned by hipsparseXbsrsv2_bufferSize() or hipsparseXbsrsv2_bufferSizeExt().
# Furthermore, analysis meta data is required. It can be obtained by
# hipsparseXbsrsv2_analysis(). \p hipsparseXbsrsv2_solve reports the first zero pivot
# (either numerical or structural zero). The zero pivot status can be checked calling
# hipsparseXbsrsv2_zeroPivot(). If
# \ref hipsparseDiagType_t == \ref HIPSPARSE_DIAG_TYPE_UNIT, no zero pivot will be
# reported, even if \f$A_{j,j} = 0\f$ for some \f$j\f$.
# 
# \note
# The sparse BSR matrix has to be sorted.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Currently, only \p trans == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE and
# \p trans == \ref HIPSPARSE_OPERATION_TRANSPOSE is supported.
# 
# \par Example
# \code{.c}
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // A = ( 1.0  0.0  0.0  0.0 )
#     //     ( 2.0  3.0  0.0  0.0 )
#     //     ( 4.0  5.0  6.0  0.0 )
#     //     ( 7.0  0.0  8.0  9.0 )
#     //
#     // with bsr_dim = 2
#     //
#     //      -------------------
#     //   = | 1.0 0.0 | 0.0 0.0 |
#     //     | 2.0 3.0 | 0.0 0.0 |
#     //      -------------------
#     //     | 4.0 5.0 | 6.0 0.0 |
#     //     | 7.0 0.0 | 8.0 9.0 |
#     //      -------------------
# 
#     // Number of rows and columns
#     int m = 4;
# 
#     // Number of block rows and block columns
#     int mb = 2;
#     int nb = 2;
# 
#     // BSR block dimension
#     int bsr_dim = 2;
# 
#     // Number of non-zero blocks
#     int nnzb = 3;
# 
#     // BSR row pointers
#     int hbsrRowPtr[3] = {0, 1, 3};
# 
#     // BSR column indices
#     int hbsrColInd[3] = {0, 0, 1};
# 
#     // BSR values
#     double hbsrVal[12] = {1.0, 2.0, 0.0, 3.0, 4.0, 7.0, 5.0, 0.0, 6.0, 8.0, 0.0, 9.0};
# 
#     // Storage scheme of the BSR blocks
#     hipsparseDirection_t dir = HIPSPARSE_DIRECTION_COLUMN;
# 
#     // Transposition of the matrix and rhs matrix
#     hipsparseOperation_t trans = HIPSPARSE_OPERATION_NON_TRANSPOSE;
# 
#     // Solve policy
#     hipsparseSolvePolicy_t solve_policy = HIPSPARSE_SOLVE_POLICY_USE_LEVEL;
# 
#     // Scalar alpha and beta
#     double alpha = 3.7;
# 
#     double hx[4] = {1, 2, 3, 4};
#     double hy[4];
# 
#     // Offload data to device
#     int* dbsrRowPtr;
#     int* dbsrColInd;
#     double* dbsrVal;
#     double* dx;
#     double* dy;
# 
#     hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
#     hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
#     hipMalloc((void**)&dbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim);
#     hipMalloc((void**)&dx, sizeof(double) * nb * bsr_dim);
#     hipMalloc((void**)&dy, sizeof(double) * mb * bsr_dim);
# 
#     hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
#     hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
#     hipMemcpy(dbsrVal, hbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim, hipMemcpyHostToDevice);
#     hipMemcpy(dx, hx, sizeof(double) * nb * bsr_dim, hipMemcpyHostToDevice);
# 
#     // Matrix descriptor
#     hipsparseMatDescr_t descr;
#     hipsparseCreateMatDescr(&descr);
# 
#     // Matrix fill mode
#     hipsparseSetMatFillMode(descr, HIPSPARSE_FILL_MODE_LOWER);
# 
#     // Matrix diagonal type
#     hipsparseSetMatDiagType(descr, HIPSPARSE_DIAG_TYPE_UNIT);
# 
#     // Matrix info structure
#     bsrsv2Info_t info;
#     hipsparseCreateBsrsv2Info(&info);
# 
#     // Obtain required buffer size
#     int buffer_size;
#     hipsparseDbsrsv2_bufferSize(handle,
#                                 dir,
#                                 trans,
#                                 mb,
#                                 nnzb,
#                                 descr,
#                                 dbsrVal,
#                                 dbsrRowPtr,
#                                 dbsrColInd,
#                                 bsr_dim,
#                                 info,
#                                 &buffer_size);
# 
#     // Allocate temporary buffer
#     void* dbuffer;
#     hipMalloc(&dbuffer, buffer_size);
# 
#     // Perform analysis step
#     hipsparseDbsrsv2_analysis(handle,
#                               dir,
#                               trans,
#                               mb,
#                               nnzb,
#                               descr,
#                               dbsrVal,
#                               dbsrRowPtr,
#                               dbsrColInd,
#                               bsr_dim,
#                               info,
#                               solve_policy,
#                               dbuffer);
# 
#     // Call dbsrsm to perform lower triangular solve LX = B
#     hipsparseDbsrsv2_solve(handle,
#                            dir,
#                            trans,
#                            mb,
#                            nnzb,
#                            &alpha,
#                            descr,
#                            dbsrVal,
#                            dbsrRowPtr,
#                            dbsrColInd,
#                            bsr_dim,
#                            info,
#                            dx,
#                            dy,
#                            solve_policy,
#                            dbuffer);
# 
#     // Check for zero pivots
#     int    pivot;
#     hipsparseStatus_t status = hipsparseXbsrsv2_zeroPivot(handle, info, &pivot);
# 
#     if(status == HIPSPARSE_STATUS_ZERO_PIVOT)
#     {
#         std::cout << "Found zero pivot in matrix row " << pivot << std::endl;
#     }
# 
#     // Copy results back to the host
#     hipMemcpy(hy, dy, sizeof(double) * mb * bsr_dim, hipMemcpyDeviceToHost);
# 
#     // Clear hipSPARSE
#     hipsparseDestroyBsrsv2Info(info);
#     hipsparseDestroyMatDescr(descr);
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dbsrRowPtr);
#     hipFree(dbsrColInd);
#     hipFree(dbsrVal);
#     hipFree(dx);
#     hipFree(dy);
#     hipFree(dbuffer);
# \endcode
cdef hipsparseStatus_t hipsparseSbsrsv2_solve(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,const float * alpha,void *const descrA,const float * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,const float * f,float * x,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDbsrsv2_solve(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,const double * alpha,void *const descrA,const double * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,const double * f,double * x,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCbsrsv2_solve(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,float2 * alpha,void *const descrA,float2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,float2 * f,float2 * x,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZbsrsv2_solve(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,int mb,int nnzb,double2 * alpha,void *const descrA,double2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsv2Info_t info,double2 * f,double2 * x,hipsparseSolvePolicy_t policy,void * pBuffer)


# \ingroup level2_module
# \brief Dense matrix sparse vector multiplication
# 
# \details
# \p hipsparseXgemvi_bufferSize returns the size of the temporary storage buffer in bytes
# required by hipsparseXgemvi(). The temporary storage buffer must be allocated by the
# user.
cdef hipsparseStatus_t hipsparseSgemvi_bufferSize(void * handle,hipsparseOperation_t transA,int m,int n,int nnz,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDgemvi_bufferSize(void * handle,hipsparseOperation_t transA,int m,int n,int nnz,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCgemvi_bufferSize(void * handle,hipsparseOperation_t transA,int m,int n,int nnz,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZgemvi_bufferSize(void * handle,hipsparseOperation_t transA,int m,int n,int nnz,int * pBufferSizeInBytes)


# \ingroup level2_module
# \brief Dense matrix sparse vector multiplication
# 
# \details
# \p hipsparseXgemvi multiplies the scalar \f$\alpha\f$ with a dense \f$m \times n\f$
# matrix \f$A\f$ and the sparse vector \f$x\f$ and adds the result to the dense vector
# \f$y\f$ that is multiplied by the scalar \f$\beta\f$, such that
# \f[
#   y := \alpha \cdot op(A) \cdot x + \beta \cdot y,
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if trans == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if trans == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if trans == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# \p hipsparseXgemvi requires a user allocated temporary buffer. Its size is returned
# by hipsparseXgemvi_bufferSize().
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Currently, only \p trans == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE is supported.
cdef hipsparseStatus_t hipsparseSgemvi(void * handle,hipsparseOperation_t transA,int m,int n,const float * alpha,const float * A,int lda,int nnz,const float * x,const int * xInd,const float * beta,float * y,hipsparseIndexBase_t idxBase,void * pBuffer)



cdef hipsparseStatus_t hipsparseDgemvi(void * handle,hipsparseOperation_t transA,int m,int n,const double * alpha,const double * A,int lda,int nnz,const double * x,const int * xInd,const double * beta,double * y,hipsparseIndexBase_t idxBase,void * pBuffer)



cdef hipsparseStatus_t hipsparseCgemvi(void * handle,hipsparseOperation_t transA,int m,int n,float2 * alpha,float2 * A,int lda,int nnz,float2 * x,const int * xInd,float2 * beta,float2 * y,hipsparseIndexBase_t idxBase,void * pBuffer)



cdef hipsparseStatus_t hipsparseZgemvi(void * handle,hipsparseOperation_t transA,int m,int n,double2 * alpha,double2 * A,int lda,int nnz,double2 * x,const int * xInd,double2 * beta,double2 * y,hipsparseIndexBase_t idxBase,void * pBuffer)


# \ingroup level3_module
# \brief Sparse matrix dense matrix multiplication using BSR storage format
# 
# \details
# \p hipsparseXbsrmm multiplies the scalar \f$\alpha\f$ with a sparse \f$mb \times kb\f$
# matrix \f$A\f$, defined in BSR storage format, and the dense \f$k \times n\f$
# matrix \f$B\f$ (where \f$k = block\_dim \times kb\f$) and adds the result to the dense
# \f$m \times n\f$ matrix \f$C\f$ (where \f$m = block\_dim \times mb\f$) that
# is multiplied by the scalar \f$\beta\f$, such that
# \f[
#   C := \alpha \cdot op(A) \cdot op(B) + \beta \cdot C,
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#   \end{array}
#   \right.
# \f]
# and
# \f[
#   op(B) = \left\{
#   \begin{array}{ll}
#       B,   & \text{if transB == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       B^T, & \text{if transB == HIPSPARSE_OPERATION_TRANSPOSE} \\
#   \end{array}
#   \right.
# \f]
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Currently, only \p transA == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE is supported.
# 
# \par Example
# \code{.c}
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     //     1 2 0 3 0 0
#     // A = 0 4 5 0 0 0
#     //     0 0 0 7 8 0
#     //     0 0 1 2 4 1
# 
#     int blockDim = 2;
#     int mb   = 2;
#     int kb   = 3;
#     int nnzb = 4;
#     hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;
# 
#     int hbsrRowPtr[2 + 1]   = {0, 2, 4};
#     int hbsrColInd[4]       = {0, 1, 1, 2};
#     float hbsrVal[4 * 2 * 2] = {1, 2, 0, 4, 0, 3, 5, 0, 0, 7, 1, 2, 8, 0, 4, 1};
# 
#     // Set dimension n of B
#     int n = 3;
#     int m = mb * blockDim;
#     int k = kb * blockDim;
# 
#     // Allocate and generate dense matrix B (k x n)
#     float hB[6 * 3] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f,
#                     11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f, 17.0f, 18.0f};
# 
#     int* dbsrRowPtr = NULL;
#     int* dbsrColInd = NULL;
#     float* dbsrVal = NULL;
#     hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
#     hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
#     hipMalloc((void**)&dbsrVal, sizeof(float) * nnzb * blockDim * blockDim);
#     hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
#     hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
#     hipMemcpy(dbsrVal, hbsrVal, sizeof(float) * nnzb * blockDim * blockDim, hipMemcpyHostToDevice);
# 
#     // Copy B to the device
#     float* dB;
#     hipMalloc((void**)&dB, sizeof(float) * k * n);
#     hipMemcpy(dB, hB, sizeof(float) * k * n, hipMemcpyHostToDevice);
# 
#     // alpha and beta
#     float alpha = 1.0f;
#     float beta  = 0.0f;
# 
#     // Allocate memory for the resulting matrix C
#     float* dC;
#     hipMalloc((void**)&dC, sizeof(float) * m * n);
# 
#     // Matrix descriptor
#     hipsparseMatDescr_t descr;
#     hipsparseCreateMatDescr(&descr);
# 
#     // Perform the matrix multiplication
#     hipsparseSbsrmm(handle,
#                     dir,
#                     HIPSPARSE_OPERATION_NON_TRANSPOSE,
#                     HIPSPARSE_OPERATION_NON_TRANSPOSE,
#                     mb,
#                     n,
#                     kb,
#                     nnzb,
#                     &alpha,
#                     descr,
#                     dbsrVal,
#                     dbsrRowPtr,
#                     dbsrColInd,
#                     blockDim,
#                     dB,
#                     k,
#                     &beta,
#                     dC,
#                     m);
# 
#     // Copy results to host
#     float hC[6 * 3];
#     hipMemcpy(hC, dC, sizeof(float) * m * n, hipMemcpyDeviceToHost);
# 
#     hipFree(dbsrRowPtr);
#     hipFree(dbsrColInd);
#     hipFree(dbsrVal);
#     hipFree(dB);
#     hipFree(dC);
# \endcode
cdef hipsparseStatus_t hipsparseSbsrmm(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transB,int mb,int n,int kb,int nnzb,const float * alpha,void *const descrA,const float * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,const float * B,int ldb,const float * beta,float * C,int ldc)



cdef hipsparseStatus_t hipsparseDbsrmm(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transB,int mb,int n,int kb,int nnzb,const double * alpha,void *const descrA,const double * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,const double * B,int ldb,const double * beta,double * C,int ldc)



cdef hipsparseStatus_t hipsparseCbsrmm(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transB,int mb,int n,int kb,int nnzb,float2 * alpha,void *const descrA,float2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,float2 * B,int ldb,float2 * beta,float2 * C,int ldc)



cdef hipsparseStatus_t hipsparseZbsrmm(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transB,int mb,int n,int kb,int nnzb,double2 * alpha,void *const descrA,double2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,double2 * B,int ldb,double2 * beta,double2 * C,int ldc)


#  \ingroup level3_module
# \brief Sparse matrix dense matrix multiplication using CSR storage format
# 
# \details
# \p hipsparseXcsrmm multiplies the scalar \f$\alpha\f$ with a sparse \f$m \times k\f$
# matrix \f$A\f$, defined in CSR storage format, and the dense \f$k \times n\f$
# matrix \f$B\f$ and adds the result to the dense \f$m \times n\f$ matrix \f$C\f$ that
# is multiplied by the scalar \f$\beta\f$, such that
# \f[
#   C := \alpha \cdot op(A) \cdot B + \beta \cdot C,
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if transA == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if transA == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# \code{.c}
#     for(i = 0; i < ldc; ++i)
#     {
#         for(j = 0; j < n; ++j)
#         {
#             C[i][j] = beta * C[i][j];
# 
#             for(k = csrRowPtr[i]; k < csrRowPtr[i + 1]; ++k)
#             {
#                 C[i][j] += alpha * csrVal[k] * B[csrColInd[k]][j];
#             }
#         }
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     //     1 2 0 3 0 0
#     // A = 0 4 5 0 0 0
#     //     0 0 0 7 8 0
#     //     0 0 1 2 4 1
# 
#     int m   = 4;
#     int k   = 6;
#     int nnz = 11;
#     hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;
# 
#     int hcsrRowPtr[4 + 1] = {0, 3, 5, 7, 11};
#     int hcsrColInd[11]    = {0, 1, 3, 1, 2, 3, 4, 2, 3, 4, 5};
#     float hcsrVal[11]      = {1, 2, 3, 4, 5, 7, 8, 1, 2, 4, 1};
# 
#     // Set dimension n of B
#     int n = 3;
# 
#     // Allocate and generate dense matrix B (k x n)
#     float hB[6 * 3] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f,
#                        11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f, 17.0f, 18.0f};
# 
#     int* dcsrRowPtr = NULL;
#     int* dcsrColInd = NULL;
#     float* dcsrVal = NULL;
#     hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#     hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#     hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
#     hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#     hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#     // Copy B to the device
#     float* dB;
#     hipMalloc((void**)&dB, sizeof(float) * k * n);
#     hipMemcpy(dB, hB, sizeof(float) * k * n, hipMemcpyHostToDevice);
# 
#     // alpha and beta
#     float alpha = 1.0f;
#     float beta  = 0.0f;
# 
#     // Allocate memory for the resulting matrix C
#     float* dC;
#     hipMalloc((void**)&dC, sizeof(float) * m * n);
# 
#     // Matrix descriptor
#     hipsparseMatDescr_t descr;
#     hipsparseCreateMatDescr(&descr);
# 
#     // Perform the matrix multiplication
#     hipsparseScsrmm(handle,
#                     HIPSPARSE_OPERATION_NON_TRANSPOSE,
#                     m,
#                     n,
#                     k,
#                     nnz,
#                     &alpha,
#                     descr,
#                     dcsrVal,
#                     dcsrRowPtr,
#                     dcsrColInd,
#                     dB,
#                     k,
#                     &beta,
#                     dC,
#                     m);
# 
#     // Copy results to host
#     float hC[6 * 3];
#     hipMemcpy(hC, dC, sizeof(float) * m * n, hipMemcpyDeviceToHost);
# 
#     hipFree(dcsrRowPtr);
#     hipFree(dcsrColInd);
#     hipFree(dcsrVal);
#     hipFree(dB);
#     hipFree(dC);
# \endcode
cdef hipsparseStatus_t hipsparseScsrmm(void * handle,hipsparseOperation_t transA,int m,int n,int k,int nnz,const float * alpha,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const float * B,int ldb,const float * beta,float * C,int ldc)



cdef hipsparseStatus_t hipsparseDcsrmm(void * handle,hipsparseOperation_t transA,int m,int n,int k,int nnz,const double * alpha,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const double * B,int ldb,const double * beta,double * C,int ldc)



cdef hipsparseStatus_t hipsparseCcsrmm(void * handle,hipsparseOperation_t transA,int m,int n,int k,int nnz,float2 * alpha,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,float2 * B,int ldb,float2 * beta,float2 * C,int ldc)



cdef hipsparseStatus_t hipsparseZcsrmm(void * handle,hipsparseOperation_t transA,int m,int n,int k,int nnz,double2 * alpha,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,double2 * B,int ldb,double2 * beta,double2 * C,int ldc)


#  \ingroup level3_module
# \brief Sparse matrix dense matrix multiplication using CSR storage format
# 
# \details
# \p hipsparseXcsrmm2 multiplies the scalar \f$\alpha\f$ with a sparse \f$m \times k\f$
# matrix \f$A\f$, defined in CSR storage format, and the dense \f$k \times n\f$
# matrix \f$B\f$ and adds the result to the dense \f$m \times n\f$ matrix \f$C\f$ that
# is multiplied by the scalar \f$\beta\f$, such that
# \f[
#   C := \alpha \cdot op(A) \cdot op(B) + \beta \cdot C,
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if transA == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if transA == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# and
# \f[
#   op(B) = \left\{
#   \begin{array}{ll}
#       B,   & \text{if transB == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       B^T, & \text{if transB == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       B^H, & \text{if transB == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# \code{.c}
#     for(i = 0; i < ldc; ++i)
#     {
#         for(j = 0; j < n; ++j)
#         {
#             C[i][j] = beta * C[i][j];
# 
#             for(k = csrRowPtr[i]; k < csrRowPtr[i + 1]; ++k)
#             {
#                 C[i][j] += alpha * csrVal[k] * B[csrColInd[k]][j];
#             }
#         }
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseScsrmm2(void * handle,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int n,int k,int nnz,const float * alpha,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const float * B,int ldb,const float * beta,float * C,int ldc)



cdef hipsparseStatus_t hipsparseDcsrmm2(void * handle,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int n,int k,int nnz,const double * alpha,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const double * B,int ldb,const double * beta,double * C,int ldc)



cdef hipsparseStatus_t hipsparseCcsrmm2(void * handle,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int n,int k,int nnz,float2 * alpha,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,float2 * B,int ldb,float2 * beta,float2 * C,int ldc)



cdef hipsparseStatus_t hipsparseZcsrmm2(void * handle,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int n,int k,int nnz,double2 * alpha,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,double2 * B,int ldb,double2 * beta,double2 * C,int ldc)


#  \ingroup level3_module
# \brief Sparse triangular system solve using BSR storage format
# 
# \details
# \p hipsparseXbsrsm2_zeroPivot returns \ref HIPSPARSE_STATUS_ZERO_PIVOT, if either a
# structural or numerical zero has been found during hipsparseXbsrsm2_analysis() or
# hipsparseXbsrsm2_solve() computation. The first zero pivot \f$j\f$ at \f$A_{j,j}\f$
# is stored in \p position, using same index base as the BSR matrix.
# 
# \p position can be in host or device memory. If no zero pivot has been found,
# \p position is set to -1 and \ref HIPSPARSE_STATUS_SUCCESS is returned instead.
# 
# \note \p hipsparseXbsrsm2_zeroPivot is a blocking function. It might influence
# performance negatively.
cdef hipsparseStatus_t hipsparseXbsrsm2_zeroPivot(void * handle,bsrsm2Info_t info,int * position)


#  \ingroup level3_module
# \brief Sparse triangular system solve using BSR storage format
# 
# \details
# \p hipsparseXbsrsm2_buffer_size returns the size of the temporary storage buffer in bytes
# that is required by hipsparseXbsrsm2_analysis() and hipsparseXbsrsm2_solve(). The
# temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSbsrsm2_bufferSize(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,void *const descrA,float * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDbsrsm2_bufferSize(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,void *const descrA,double * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCbsrsm2_bufferSize(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,void *const descrA,float2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZbsrsm2_bufferSize(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,void *const descrA,double2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,int * pBufferSizeInBytes)


#  \ingroup level3_module
# \brief Sparse triangular system solve using BSR storage format
# 
# \details
# \p hipsparseXbsrsm2_analysis performs the analysis step for hipsparseXbsrsm2_solve().
# 
# \note
# If the matrix sparsity pattern changes, the gathered information will become invalid.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSbsrsm2_analysis(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,void *const descrA,const float * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDbsrsm2_analysis(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,void *const descrA,const double * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCbsrsm2_analysis(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,void *const descrA,float2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZbsrsm2_analysis(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,void *const descrA,double2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup level3_module
# \brief Sparse triangular system solve using BSR storage format
# 
# \details
# \p hipsparseXbsrsm2_solve solves a sparse triangular linear system of a sparse
# \f$m \times m\f$ matrix, defined in BSR storage format, a dense solution matrix
# \f$X\f$ and the right-hand side matrix \f$B\f$ that is multiplied by \f$\alpha\f$, such that
# \f[
#   op(A) \cdot op(X) = \alpha \cdot op(B),
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if transA == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if transA == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# ,
# \f[
#   op(X) = \left\{
#   \begin{array}{ll}
#       X,   & \text{if transX == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       X^T, & \text{if transX == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       X^H, & \text{if transX == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# \p hipsparseXbsrsm2_solve requires a user allocated temporary buffer. Its size is
# returned by hipsparseXbsrsm2_bufferSize(). Furthermore, analysis meta data is
# required. It can be obtained by hipsparseXbsrsm2_analysis(). \p hipsparseXbsrsm2_solve
# reports the first zero pivot (either numerical or structural zero). The zero pivot
# status can be checked calling hipsparseXbsrsm2_zeroPivot(). If
# \ref hipsparseDiagType_t == \ref HIPSPARSE_DIAG_TYPE_UNIT, no zero pivot will be
# reported, even if \f$A_{j,j} = 0\f$ for some \f$j\f$.
# 
# \note
# The sparse BSR matrix has to be sorted.
# 
# \note
# Operation type of B and X must match, if \f$op(B)=B, op(X)=X\f$.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Currently, only \p transA != \ref HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE and
# \p transX != \ref HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE is supported.
# 
# \par Example
# \code{.c}
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // A = ( 1.0  0.0  0.0  0.0 )
#     //     ( 2.0  3.0  0.0  0.0 )
#     //     ( 4.0  5.0  6.0  0.0 )
#     //     ( 7.0  0.0  8.0  9.0 )
#     //
#     // with bsr_dim = 2
#     //
#     //      -------------------
#     //   = | 1.0 0.0 | 0.0 0.0 |
#     //     | 2.0 3.0 | 0.0 0.0 |
#     //      -------------------
#     //     | 4.0 5.0 | 6.0 0.0 |
#     //     | 7.0 0.0 | 8.0 9.0 |
#     //      -------------------
# 
#     // Number of rows and columns
#     int m = 4;
# 
#     // Number of block rows and block columns
#     int mb = 2;
#     int nb = 2;
# 
#     // BSR block dimension
#     int bsr_dim = 2;
# 
#     // Number of right-hand-sides
#     int nrhs = 4;
# 
#     // Number of non-zero blocks
#     int nnzb = 3;
# 
#     // BSR row pointers
#     int hbsrRowPtr[3] = {0, 1, 3};
# 
#     // BSR column indices
#     int hbsrColInd[3] = {0, 0, 1};
# 
#     // BSR values
#     double hbsrVal[12] = {1.0, 2.0, 0.0, 3.0, 4.0, 7.0, 5.0, 0.0, 6.0, 8.0, 0.0, 9.0};
# 
#     // Storage scheme of the BSR blocks
#     hipsparseDirection_t dir = HIPSPARSE_DIRECTION_COLUMN;
# 
#     // Transposition of the matrix and rhs matrix
#     hipsparseOperation_t transA = HIPSPARSE_OPERATION_NON_TRANSPOSE;
#     hipsparseOperation_t transX = HIPSPARSE_OPERATION_NON_TRANSPOSE;
# 
#     // Solve policy
#     hipsparseSolvePolicy_t solve_policy = HIPSPARSE_SOLVE_POLICY_NO_LEVEL;
# 
#     // Scalar alpha and beta
#     double alpha = 1.0;
# 
#     // rhs and solution matrix
#     int ldb = nb * bsr_dim;
#     int ldx = mb * bsr_dim;
# 
#     double hB[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
#     double hX[16];
# 
#     // Offload data to device
#     int* dbsrRowPtr;
#     int* dbsrColInd;
#     double*        dbsrVal;
#     double*        dB;
#     double*        dX;
# 
#     hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
#     hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
#     hipMalloc((void**)&dbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim);
#     hipMalloc((void**)&dB, sizeof(double) * nb * bsr_dim * nrhs);
#     hipMalloc((void**)&dX, sizeof(double) * mb * bsr_dim * nrhs);
# 
#     hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
#     hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
#     hipMemcpy(dbsrVal, hbsrVal, sizeof(double) * nnzb * bsr_dim * bsr_dim, hipMemcpyHostToDevice);
#     hipMemcpy(dB, hB, sizeof(double) * nb * bsr_dim * nrhs, hipMemcpyHostToDevice);
# 
#     // Matrix descriptor
#     hipsparseMatDescr_t descr;
#     hipsparseCreateMatDescr(&descr);
# 
#     // Matrix fill mode
#     hipsparseSetMatFillMode(descr, HIPSPARSE_FILL_MODE_LOWER);
# 
#     // Matrix diagonal type
#     hipsparseSetMatDiagType(descr, HIPSPARSE_DIAG_TYPE_NON_UNIT);
# 
#     // Matrix info structure
#     bsrsm2Info_t info;
#     hipsparseCreateBsrsm2Info(&info);
# 
#     // Obtain required buffer size
#     int buffer_size;
#     hipsparseDbsrsm2_bufferSize(handle,
#                                 dir,
#                                 transA,
#                                 transX,
#                                 mb,
#                                 nrhs,
#                                 nnzb,
#                                 descr,
#                                 dbsrVal,
#                                 dbsrRowPtr,
#                                 dbsrColInd,
#                                 bsr_dim,
#                                 info,
#                                 &buffer_size);
# 
#     // Allocate temporary buffer
#     void* dbuffer;
#     hipMalloc(&dbuffer, buffer_size);
# 
#     // Perform analysis step
#     hipsparseDbsrsm2_analysis(handle,
#                               dir,
#                               transA,
#                               transX,
#                               mb,
#                               nrhs,
#                               nnzb,
#                               descr,
#                               dbsrVal,
#                               dbsrRowPtr,
#                               dbsrColInd,
#                               bsr_dim,
#                               info,
#                               solve_policy,
#                               dbuffer);
# 
#     // Call dbsrsm to perform lower triangular solve LX = B
#     hipsparseDbsrsm2_solve(handle,
#                            dir,
#                            transA,
#                            transX,
#                            mb,
#                            nrhs,
#                            nnzb,
#                            &alpha,
#                            descr,
#                            dbsrVal,
#                            dbsrRowPtr,
#                            dbsrColInd,
#                            bsr_dim,
#                            info,
#                            dB,
#                            ldb,
#                            dX,
#                            ldx,
#                            solve_policy,
#                            dbuffer);
# 
#     // Check for zero pivots
#     int    pivot;
#     hipsparseStatus_t status = hipsparseXbsrsm2_zeroPivot(handle, info, &pivot);
# 
#     if(status == HIPSPARSE_STATUS_ZERO_PIVOT)
#     {
#         std::cout << "Found zero pivot in matrix row " << pivot << std::endl;
#     }
# 
#     // Copy result back to host
#     hipMemcpy(hX, dX, sizeof(double) * mb * bsr_dim * nrhs, hipMemcpyDeviceToHost);
# 
#     // Clear hipSPARSE
#     hipsparseDestroyBsrsm2Info(info);
#     hipsparseDestroyMatDescr(descr);
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dbsrRowPtr);
#     hipFree(dbsrColInd);
#     hipFree(dbsrVal);
#     hipFree(dB);
#     hipFree(dX);
#     hipFree(dbuffer);
# \endcode
cdef hipsparseStatus_t hipsparseSbsrsm2_solve(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,const float * alpha,void *const descrA,const float * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,const float * B,int ldb,float * X,int ldx,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDbsrsm2_solve(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,const double * alpha,void *const descrA,const double * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,const double * B,int ldb,double * X,int ldx,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCbsrsm2_solve(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,float2 * alpha,void *const descrA,float2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,float2 * B,int ldb,float2 * X,int ldx,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZbsrsm2_solve(void * handle,hipsparseDirection_t dirA,hipsparseOperation_t transA,hipsparseOperation_t transX,int mb,int nrhs,int nnzb,double2 * alpha,void *const descrA,double2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrsm2Info_t info,double2 * B,int ldb,double2 * X,int ldx,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup level3_module
# \brief Sparse triangular system solve using CSR storage format
# 
# \details
# \p hipsparseXcsrsm2_zeroPivot returns \ref HIPSPARSE_STATUS_ZERO_PIVOT, if either a
# structural or numerical zero has been found during hipsparseXcsrsm2_analysis() or
# hipsparseXcsrsm2_solve() computation. The first zero pivot \f$j\f$ at \f$A_{j,j}\f$
# is stored in \p position, using same index base as the CSR matrix.
# 
# \p position can be in host or device memory. If no zero pivot has been found,
# \p position is set to -1 and \ref HIPSPARSE_STATUS_SUCCESS is returned instead.
# 
# \note \p hipsparseXcsrsm2_zeroPivot is a blocking function. It might influence
# performance negatively.
cdef hipsparseStatus_t hipsparseXcsrsm2_zeroPivot(void * handle,csrsm2Info_t info,int * position)


#  \ingroup level3_module
# \brief Sparse triangular system solve using CSR storage format
# 
# \details
# \p hipsparseXcsrsm2_bufferSizeExt returns the size of the temporary storage buffer
# in bytes that is required by hipsparseXcsrsm2_analysis() and hipsparseXcsrsm2_solve().
# The temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseScsrsm2_bufferSizeExt(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,const float * alpha,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const float * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsrsm2_bufferSizeExt(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,const double * alpha,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const double * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsrsm2_bufferSizeExt(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,float2 * alpha,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,float2 * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsrsm2_bufferSizeExt(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,double2 * alpha,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,double2 * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,unsigned long * pBufferSizeInBytes)


#  \ingroup level3_module
# \brief Sparse triangular system solve using CSR storage format
# 
# \details
# \p hipsparseXcsrsm2_analysis performs the analysis step for hipsparseXcsrsm2_solve().
# 
# \note
# If the matrix sparsity pattern changes, the gathered information will become invalid.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseScsrsm2_analysis(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,const float * alpha,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const float * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsrsm2_analysis(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,const double * alpha,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const double * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsrsm2_analysis(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,float2 * alpha,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,float2 * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsrsm2_analysis(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,double2 * alpha,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,double2 * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup level3_module
# \brief Sparse triangular system solve using CSR storage format
# 
# \details
# \p hipsparseXcsrsm2_solve solves a sparse triangular linear system of a sparse
# \f$m \times m\f$ matrix, defined in CSR storage format, a dense solution matrix
# \f$X\f$ and the right-hand side matrix \f$B\f$ that is multiplied by \f$\alpha\f$, such that
# \f[
#   op(A) \cdot op(X) = \alpha \cdot op(B),
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if transA == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if transA == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# ,
# \f[
#   op(B) = \left\{
#   \begin{array}{ll}
#       B,   & \text{if transB == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       B^T, & \text{if transB == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       B^H, & \text{if transB == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# and
# \f[
#   op(X) = \left\{
#   \begin{array}{ll}
#       X,   & \text{if transB == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       X^T, & \text{if transB == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       X^H, & \text{if transB == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# \p hipsparseXcsrsm2_solve requires a user allocated temporary buffer. Its size is
# returned by hipsparseXcsrsm2_bufferSizeExt(). Furthermore, analysis meta data is
# required. It can be obtained by hipsparseXcsrsm2_analysis().
# \p hipsparseXcsrsm2_solve reports the first zero pivot (either numerical or structural
# zero). The zero pivot status can be checked calling hipsparseXcsrsm2_zeroPivot(). If
# \ref hipsparseDiagType_t == \ref HIPSPARSE_DIAG_TYPE_UNIT, no zero pivot will be
# reported, even if \f$A_{j,j} = 0\f$ for some \f$j\f$.
# 
# \note
# The sparse CSR matrix has to be sorted. This can be achieved by calling
# hipsparseXcsrsort().
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Currently, only \p transA != \ref HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE and
# \p transB != \ref HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE is supported.
# 
# \par Example
# \code{.c}
#     // hipSPARSE handle
#     hipsparseHandle_t handle;
#     hipsparseCreate(&handle);
# 
#     // A = ( 1.0  0.0  0.0  0.0 )
#     //     ( 2.0  3.0  0.0  0.0 )
#     //     ( 4.0  5.0  6.0  0.0 )
#     //     ( 7.0  0.0  8.0  9.0 )
# 
#     // Number of rows and columns
#     int m = 4;
#     int n = 4;
# 
#     // Number of right-hand-sides
#     int nrhs = 4;
# 
#     // Number of non-zeros
#     int nnz = 9;
# 
#     // CSR row pointers
#     int hcsrRowPtr[5] = {0, 1, 3, 6, 9};
# 
#     // CSR column indices
#     int hcsrColInd[9] = {0, 0, 1, 0, 1, 2, 0, 2, 3};
# 
#     // CSR values
#     double hcsrVal[9] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};
# 
#     // Transposition of the matrix and rhs matrix
#     hipsparseOperation_t transA = HIPSPARSE_OPERATION_NON_TRANSPOSE;
#     hipsparseOperation_t transB = HIPSPARSE_OPERATION_NON_TRANSPOSE;
# 
#     // Solve policy
#     hipsparseSolvePolicy_t solve_policy = HIPSPARSE_SOLVE_POLICY_NO_LEVEL;
# 
#     // Scalar alpha and beta
#     double alpha = 1.0;
# 
#     // rhs and solution matrix
#     int ldb = n;
# 
#     double hB[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
# 
#     // Offload data to device
#     int* dcsrRowPtr;
#     int* dcsrColInd;
#     double*        dcsrVal;
#     double*        dB;
# 
#     hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#     hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#     hipMalloc((void**)&dcsrVal, sizeof(double) * nnz);
#     hipMalloc((void**)&dB, sizeof(double) * n * nrhs);
# 
#     hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#     hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dcsrVal, hcsrVal, sizeof(double) * nnz, hipMemcpyHostToDevice);
#     hipMemcpy(dB, hB, sizeof(double) * n * nrhs, hipMemcpyHostToDevice);
# 
#     // Matrix descriptor
#     hipsparseMatDescr_t descr;
#     hipsparseCreateMatDescr(&descr);
# 
#     // Matrix fill mode
#     hipsparseSetMatFillMode(descr, HIPSPARSE_FILL_MODE_LOWER);
# 
#     // Matrix diagonal type
#     hipsparseSetMatDiagType(descr, HIPSPARSE_DIAG_TYPE_NON_UNIT);
# 
#     // Matrix info structure
#     csrsm2Info_t info;
#     hipsparseCreateCsrsm2Info(&info);
# 
#     // Obtain required buffer size
#     size_t buffer_size;
#     hipsparseDcsrsm2_bufferSizeExt(handle,
#                                    0,
#                                    transA,
#                                    transB,
#                                    m,
#                                    nrhs,
#                                    nnz,
#                                    &alpha,
#                                    descr,
#                                    dcsrVal,
#                                    dcsrRowPtr,
#                                    dcsrColInd,
#                                    dB,
#                                    ldb,
#                                    info,
#                                    solve_policy,
#                                    &buffer_size);
# 
#     // Allocate temporary buffer
#     void* dbuffer;
#     hipMalloc(&dbuffer, buffer_size);
# 
#     // Perform analysis step
#     hipsparseDcsrsm2_analysis(handle,
#                               0,
#                               transA,
#                               transB,
#                               m,
#                               nrhs,
#                               nnz,
#                               &alpha,
#                               descr,
#                               dcsrVal,
#                               dcsrRowPtr,
#                               dcsrColInd,
#                               dB,
#                               ldb,
#                               info,
#                               solve_policy,
#                               dbuffer);
# 
#     // Call dcsrsm to perform lower triangular solve LB = B
#     hipsparseDcsrsm2_solve(handle,
#                            0,
#                            transA,
#                            transB,
#                            m,
#                            nrhs,
#                            nnz,
#                            &alpha,
#                            descr,
#                            dcsrVal,
#                            dcsrRowPtr,
#                            dcsrColInd,
#                            dB,
#                            ldb,
#                            info,
#                            solve_policy,
#                            dbuffer);
# 
#     // Check for zero pivots
#     int    pivot;
#     hipsparseStatus_t status = hipsparseXcsrsm2_zeroPivot(handle, info, &pivot);
# 
#     if(status == HIPSPARSE_STATUS_ZERO_PIVOT)
#     {
#         std::cout << "Found zero pivot in matrix row " << pivot << std::endl;
#     }
# 
#     // Copy result back to host
#     hipMemcpy(hB, dB, sizeof(double) * m * nrhs, hipMemcpyDeviceToHost);
# 
#     // Clear hipSPARSE
#     hipsparseDestroyCsrsm2Info(info);
#     hipsparseDestroyMatDescr(descr);
#     hipsparseDestroy(handle);
# 
#     // Clear device memory
#     hipFree(dcsrRowPtr);
#     hipFree(dcsrColInd);
#     hipFree(dcsrVal);
#     hipFree(dB);
#     hipFree(dbuffer);
# \endcode
cdef hipsparseStatus_t hipsparseScsrsm2_solve(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,const float * alpha,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,float * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsrsm2_solve(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,const double * alpha,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,double * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsrsm2_solve(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,float2 * alpha,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,float2 * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsrsm2_solve(void * handle,int algo,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int nrhs,int nnz,double2 * alpha,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,double2 * B,int ldb,csrsm2Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup level3_module
# \brief Dense matrix sparse matrix multiplication using CSC storage format
# 
# \details
# \p hipsparseXgemmi multiplies the scalar \f$\alpha\f$ with a dense \f$m \times k\f$
# matrix \f$A\f$ and the sparse \f$k \times n\f$ matrix \f$B\f$, defined in CSC
# storage format and adds the result to the dense \f$m \times n\f$ matrix \f$C\f$ that
# is multiplied by the scalar \f$\beta\f$, such that
# \f[
#   C := \alpha \cdot A \cdot B + \beta \cdot C
# \f]
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // A, B, and C are mk, kn, and mn
#   int m = 3, n = 5, k = 4;
#   int lda = m, ldc = m;
#   int nnz_A = m * k, nnz_B = 10, nnz_C = m * n;
# 
#   // alpha and beta
#   float alpha = 0.5f;
#   float beta  = 0.25f;
# 
#   std::vector<int> hcscColPtr = {0, 2, 5, 7, 8, 10};
#   std::vector<int> hcscRowInd = {0, 2, 0, 1, 3, 1, 3, 2, 0, 2};
#   std::vector<float> hcsc_val     = {1, 6, 2, 4, 9, 5, 2, 7, 3, 8};
# 
#   std::vector<float> hA(nnz_A, 1.0f);
#   std::vector<float> hC(nnz_C, 1.0f);
# 
#   int *dcscColPtr;
#   int *dcscRowInd;
#   float *dcsc_val;
#   hipMalloc((void**)&dcscColPtr, sizeof(int) * (n + 1));
#   hipMalloc((void**)&dcscRowInd, sizeof(int) * nnz_B);
#   hipMalloc((void**)&dcsc_val, sizeof(float) * nnz_B);
# 
#   hipMemcpy(dcscColPtr, hcscColPtr.data(), sizeof(int) * (n + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcscRowInd, hcscRowInd.data(), sizeof(int) * nnz_B, hipMemcpyHostToDevice);
#   hipMemcpy(dcsc_val, hcsc_val.data(), sizeof(float) * nnz_B, hipMemcpyHostToDevice);
# 
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Allocate memory for the matrix A
#   float* dA;
#   hipMalloc((void**)&dA, sizeof(float) * nnz_A);
#   hipMemcpy(dA, hA.data(), sizeof(float) * nnz_A, hipMemcpyHostToDevice);
# 
#   // Allocate memory for the resulting matrix C
#   float* dC;
#   hipMalloc((void**)&dC, sizeof(float) * nnz_C);
#   hipMemcpy(dC, hC.data(), sizeof(float) * nnz_C, hipMemcpyHostToDevice);
# 
#   // Perform operation
#   hipsparseSgemmi(handle,
#                   m,
#                   n,
#                   k,
#                   nnz_B,
#                   &alpha,
#                   dA,
#                   lda,
#                   dcsc_val,
#                   dcscColPtr,
#                   dcscRowInd,
#                   &beta,
#                   dC,
#                   ldc);
# 
#   // Copy device to host
#   hipMemcpy(hC.data(), dC, sizeof(float) * nnz_C, hipMemcpyDeviceToHost);
# 
#   // Destroy matrix descriptors and handles
#   hipsparseDestroy(handle);
# 
#   hipFree(dcscColPtr);
#   hipFree(dcscRowInd);
#   hipFree(dcsc_val);
#   hipFree(dA);
#   hipFree(dC);
# \endcode
cdef hipsparseStatus_t hipsparseSgemmi(void * handle,int m,int n,int k,int nnz,const float * alpha,const float * A,int lda,const float * cscValB,const int * cscColPtrB,const int * cscRowIndB,const float * beta,float * C,int ldc)



cdef hipsparseStatus_t hipsparseDgemmi(void * handle,int m,int n,int k,int nnz,const double * alpha,const double * A,int lda,const double * cscValB,const int * cscColPtrB,const int * cscRowIndB,const double * beta,double * C,int ldc)



cdef hipsparseStatus_t hipsparseCgemmi(void * handle,int m,int n,int k,int nnz,float2 * alpha,float2 * A,int lda,float2 * cscValB,const int * cscColPtrB,const int * cscRowIndB,float2 * beta,float2 * C,int ldc)



cdef hipsparseStatus_t hipsparseZgemmi(void * handle,int m,int n,int k,int nnz,double2 * alpha,double2 * A,int lda,double2 * cscValB,const int * cscColPtrB,const int * cscRowIndB,double2 * beta,double2 * C,int ldc)


#  \ingroup extra_module
# \brief Sparse matrix sparse matrix addition using CSR storage format
# 
# \details
# \p hipsparseXcsrgeamNnz computes the total CSR non-zero elements and the CSR row
# offsets, that point to the start of every row of the sparse CSR matrix, of the
# resulting matrix C. It is assumed that \p csrRowPtrC has been allocated with
# size \p m+1. The desired index base in the output CSR matrix is set in the
# hipsparseMatDescr_t. See hipsparseSetMatIndexBase().
# 
# For full code example, see hipsparseScsrgeam().
# 
# \note
# As indicated, nnzTotalDevHostPtr can point either to host or device memory. This is controlled
# by setting the pointer mode. See hipsparseSetPointerMode().
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# \note
# Currently, only \ref HIPSPARSE_MATRIX_TYPE_GENERAL is supported.
cdef hipsparseStatus_t hipsparseXcsrgeamNnz(void * handle,int m,int n,void *const descrA,int nnzA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const int * csrRowPtrB,const int * csrColIndB,void *const descrC,int * csrRowPtrC,int * nnzTotalDevHostPtr)


#  \ingroup extra_module
# \brief Sparse matrix sparse matrix addition using CSR storage format
# 
# \details
# \p hipsparseXcsrgeam multiplies the scalar \f$\alpha\f$ with the sparse
# \f$m \times n\f$ matrix \f$A\f$, defined in CSR storage format, multiplies the
# scalar \f$\beta\f$ with the sparse \f$m \times n\f$ matrix \f$B\f$, defined in CSR
# storage format, and adds both resulting matrices to obtain the sparse
# \f$m \times n\f$ matrix \f$C\f$, defined in CSR storage format, such that
# \f[
#   C := \alpha \cdot A + \beta \cdot B.
# \f]
# 
# This computation involves a multi step process. First the user must allocate \p csrRowPtrC
# to have size \p m+1. The user then calls \p hipsparseXcsrgeamNnz which fills in the \p csrRowPtrC
# array as well as computes the total number of nonzeros in C, \p nnzC. The user then allocates both
# arrays \p csrColIndC and \p csrValC to have size \p nnzC and calls \p hipsparseXcsrgeam to complete
# the computation. The desired index base in the output CSR matrix C is set in the
# hipsparseMatDescr_t \p descrC. See hipsparseSetMatIndexBase().
# 
# \note Both scalars \f$\alpha\f$ and \f$beta\f$ have to be valid.
# \note Currently, only \ref HIPSPARSE_MATRIX_TYPE_GENERAL is supported.
# \note This function is non blocking and executed asynchronously with respect to the
#       host. It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   int m = 4;
#   int n = 4;
#   int nnzA = 9;
#   int nnzB = 6;
# 
#   float alpha{1.0f};
#   float beta{1.0f};
# 
#   // A, B, and C are mn
# 
#   // A
#   // 1 0 0 2
#   // 3 4 0 0
#   // 5 6 7 8
#   // 0 0 9 0
#   std::vector<int> hcsrRowPtrA = {0, 2, 4, 8, 9};
#   std::vector<int> hcsrColIndA = {0, 3, 0, 1, 0, 1, 2, 3, 2};
#   std::vector<float> hcsrValA = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f};
# 
#   // B
#   // 0 1 0 0
#   // 1 0 1 0
#   // 0 1 0 1
#   // 0 0 1 0
#   std::vector<int> hcsrRowPtrB = {0, 1, 3, 5, 6};
#   std::vector<int> hcsrColIndB = {1, 0, 2, 1, 3, 2};
#   std::vector<float> hcsrValB = {1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f};
# 
#   // Device memory management: Allocate and copy A, B
#   int* dcsrRowPtrA;
#   int* dcsrColIndA;
#   float* dcsrValA;
#   int* dcsrRowPtrB;
#   int* dcsrColIndB;
#   float* dcsrValB;
#   int* dcsrRowPtrC;
#   hipMalloc((void**)&dcsrRowPtrA, (m + 1) * sizeof(int));
#   hipMalloc((void**)&dcsrColIndA, nnzA * sizeof(int));
#   hipMalloc((void**)&dcsrValA, nnzA * sizeof(float));
#   hipMalloc((void**)&dcsrRowPtrB, (m + 1) * sizeof(int));
#   hipMalloc((void**)&dcsrColIndB, nnzB * sizeof(int));
#   hipMalloc((void**)&dcsrValB, nnzB * sizeof(float));
#   hipMalloc((void**)&dcsrRowPtrC, (m + 1) * sizeof(int));
# 
#   hipMemcpy(dcsrRowPtrA, hcsrRowPtrA.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColIndA, hcsrColIndA.data(), nnzA * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrValA, hcsrValA.data(), nnzA * sizeof(float), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrRowPtrB, hcsrRowPtrB.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColIndB, hcsrColIndB.data(), nnzB * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrValB, hcsrValB.data(), nnzB * sizeof(float), hipMemcpyHostToDevice);
# 
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t descrA;
#   hipsparseCreateMatDescr(&descrA);
# 
#   hipsparseMatDescr_t descrB;
#   hipsparseCreateMatDescr(&descrB);
# 
#   hipsparseMatDescr_t descrC;
#   hipsparseCreateMatDescr(&descrC);
# 
#   int nnzC;
#   hipsparseXcsrgeamNnz(handle,
#                       m,
#                       n,
#                       descrA,
#                       nnzA,
#                       dcsrRowPtrA,
#                       dcsrColIndA,
#                       descrB,
#                       nnzB,
#                       dcsrRowPtrB,
#                       dcsrColIndB,
#                       descrC,
#                       dcsrRowPtrC,
#                       &nnzC);
# 
#   int* dcsrColIndC = nullptr;
#   float* dcsrValC = nullptr;
#   hipMalloc((void**)&dcsrColIndC, sizeof(int) * nnzC);
#   hipMalloc((void**)&dcsrValC, sizeof(float) * nnzC);
# 
#   hipsparseScsrgeam(handle,
#                     m,
#                     n,
#                     &alpha,
#                     descrA,
#                     nnzA,
#                     dcsrValA,
#                     dcsrRowPtrA,
#                     dcsrColIndA,
#                     &beta,
#                     descrB,
#                     nnzB,
#                     dcsrValB,
#                     dcsrRowPtrB,
#                     dcsrColIndB,
#                     descrC,
#                     dcsrValC,
#                     dcsrRowPtrC,
#                     dcsrColIndC);
# 
#   hipFree(dcsrRowPtrA);
#   hipFree(dcsrColIndA);
#   hipFree(dcsrValA);
#   hipFree(dcsrRowPtrB);
#   hipFree(dcsrColIndB);
#   hipFree(dcsrValB);
#   hipFree(dcsrRowPtrC);
#   hipFree(dcsrColIndC);
#   hipFree(dcsrValC);
# 
#   hipsparseDestroyMatDescr(descrA);
#   hipsparseDestroyMatDescr(descrB);
#   hipsparseDestroyMatDescr(descrC);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseScsrgeam(void * handle,int m,int n,const float * alpha,void *const descrA,int nnzA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,const float * beta,void *const descrB,int nnzB,const float * csrValB,const int * csrRowPtrB,const int * csrColIndB,void *const descrC,float * csrValC,int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseDcsrgeam(void * handle,int m,int n,const double * alpha,void *const descrA,int nnzA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,const double * beta,void *const descrB,int nnzB,const double * csrValB,const int * csrRowPtrB,const int * csrColIndB,void *const descrC,double * csrValC,int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseCcsrgeam(void * handle,int m,int n,float2 * alpha,void *const descrA,int nnzA,float2 * csrValA,const int * csrRowPtrA,const int * csrColIndA,float2 * beta,void *const descrB,int nnzB,float2 * csrValB,const int * csrRowPtrB,const int * csrColIndB,void *const descrC,float2 * csrValC,int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseZcsrgeam(void * handle,int m,int n,double2 * alpha,void *const descrA,int nnzA,double2 * csrValA,const int * csrRowPtrA,const int * csrColIndA,double2 * beta,void *const descrB,int nnzB,double2 * csrValB,const int * csrRowPtrB,const int * csrColIndB,void *const descrC,double2 * csrValC,int * csrRowPtrC,int * csrColIndC)


#  \ingroup extra_module
# \brief Sparse matrix sparse matrix multiplication using CSR storage format
# 
# \details
# \p hipsparseXcsrgeam2_bufferSizeExt returns the size of the temporary storage buffer
# in bytes that is required by hipsparseXcsrgeam2Nnz() and hipsparseXcsrgeam2(). The
# temporary storage buffer must be allocated by the user.
# 
# \note
# Currently, only \ref HIPSPARSE_MATRIX_TYPE_GENERAL is supported.
cdef hipsparseStatus_t hipsparseScsrgeam2_bufferSizeExt(void * handle,int m,int n,const float * alpha,void *const descrA,int nnzA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const float * beta,void *const descrB,int nnzB,const float * csrSortedValB,const int * csrSortedRowPtrB,const int * csrSortedColIndB,void *const descrC,const float * csrSortedValC,const int * csrSortedRowPtrC,const int * csrSortedColIndC,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsrgeam2_bufferSizeExt(void * handle,int m,int n,const double * alpha,void *const descrA,int nnzA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const double * beta,void *const descrB,int nnzB,const double * csrSortedValB,const int * csrSortedRowPtrB,const int * csrSortedColIndB,void *const descrC,const double * csrSortedValC,const int * csrSortedRowPtrC,const int * csrSortedColIndC,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsrgeam2_bufferSizeExt(void * handle,int m,int n,float2 * alpha,void *const descrA,int nnzA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,float2 * beta,void *const descrB,int nnzB,float2 * csrSortedValB,const int * csrSortedRowPtrB,const int * csrSortedColIndB,void *const descrC,float2 * csrSortedValC,const int * csrSortedRowPtrC,const int * csrSortedColIndC,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsrgeam2_bufferSizeExt(void * handle,int m,int n,double2 * alpha,void *const descrA,int nnzA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,double2 * beta,void *const descrB,int nnzB,double2 * csrSortedValB,const int * csrSortedRowPtrB,const int * csrSortedColIndB,void *const descrC,double2 * csrSortedValC,const int * csrSortedRowPtrC,const int * csrSortedColIndC,unsigned long * pBufferSizeInBytes)


#  \ingroup extra_module
# \brief Sparse matrix sparse matrix addition using CSR storage format
# 
# \details
# \p hipsparseXcsrgeam2Nnz computes the total CSR non-zero elements and the CSR row
# offsets, that point to the start of every row of the sparse CSR matrix, of the
# resulting matrix C. It is assumed that \p csrRowPtrC has been allocated with
# size \p m+1. The required buffer size can be obtained by hipsparseXcsrgeam2_bufferSizeExt().
# The desired index base in the output CSR matrix C is set in the hipsparseMatDescr_t
# \p descrC. See hipsparseSetMatIndexBase().
# 
# \note
# As indicated, nnzTotalDevHostPtr can point either to host or device memory. This is controlled
# by setting the pointer mode. See hipsparseSetPointerMode().
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# \note
# Currently, only \ref HIPSPARSE_MATRIX_TYPE_GENERAL is supported.
cdef hipsparseStatus_t hipsparseXcsrgeam2Nnz(void * handle,int m,int n,void *const descrA,int nnzA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,void *const descrB,int nnzB,const int * csrSortedRowPtrB,const int * csrSortedColIndB,void *const descrC,int * csrSortedRowPtrC,int * nnzTotalDevHostPtr,void * workspace)


#  \ingroup extra_module
# \brief Sparse matrix sparse matrix addition using CSR storage format
# 
# \details
# \p hipsparseXcsrgeam2 multiplies the scalar \f$\alpha\f$ with the sparse
# \f$m \times n\f$ matrix \f$A\f$, defined in CSR storage format, multiplies the
# scalar \f$\beta\f$ with the sparse \f$m \times n\f$ matrix \f$B\f$, defined in CSR
# storage format, and adds both resulting matrices to obtain the sparse
# \f$m \times n\f$ matrix \f$C\f$, defined in CSR storage format, such that
# \f[
#   C := \alpha \cdot A + \beta \cdot B.
# \f]
# 
# This computation involves a multi step process. First the user must call
# \p hipsparseZcsrgeam2_bufferSizeExt in order to determine the required user allocated
# temporary buffer size. The user then allocates this buffer and also allocates \p csrRowPtrC
# to have size \p m+1. Both the temporary storage buffer and \p csrRowPtrC array are then passed to
# \p hipsparseXcsrgeam2Nnz which fills in the \p csrRowPtrC array as well as computes the total number
# of nonzeros in C, \p nnzC. The user then allocates both arrays \p csrColIndC and \p csrValC to have
# size \p nnzC and calls \p hipsparseXcsrgeam2 to complete the computation. The desired index base in
# the output CSR matrix C is set in the hipsparseMatDescr_t \p descrC. See hipsparseSetMatIndexBase().
# 
# \note Both scalars \f$\alpha\f$ and \f$beta\f$ have to be valid.
# \note Currently, only \ref HIPSPARSE_MATRIX_TYPE_GENERAL is supported.
# \note This function is non blocking and executed asynchronously with respect to the
#       host. It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   int m = 4;
#   int n = 4;
#   int nnzA = 9;
#   int nnzB = 6;
# 
#   float alpha{1.0f};
#   float beta{1.0f};
# 
#   // A, B, and C are mn
# 
#   // A
#   // 1 0 0 2
#   // 3 4 0 0
#   // 5 6 7 8
#   // 0 0 9 0
#   std::vector<int> hcsrRowPtrA = {0, 2, 4, 8, 9};
#   std::vector<int> hcsrColIndA = {0, 3, 0, 1, 0, 1, 2, 3, 2};
#   std::vector<float> hcsrValA = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f};
# 
#   // B
#   // 0 1 0 0
#   // 1 0 1 0
#   // 0 1 0 1
#   // 0 0 1 0
#   std::vector<int> hcsrRowPtrB = {0, 1, 3, 5, 6};
#   std::vector<int> hcsrColIndB = {1, 0, 2, 1, 3, 2};
#   std::vector<float> hcsrValB = {1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f};
# 
#   // Device memory management: Allocate and copy A, B
#   int* dcsrRowPtrA;
#   int* dcsrColIndA;
#   float* dcsrValA;
#   int* dcsrRowPtrB;
#   int* dcsrColIndB;
#   float* dcsrValB;
#   int* dcsrRowPtrC;
#   hipMalloc((void**)&dcsrRowPtrA, (m + 1) * sizeof(int));
#   hipMalloc((void**)&dcsrColIndA, nnzA * sizeof(int));
#   hipMalloc((void**)&dcsrValA, nnzA * sizeof(float));
#   hipMalloc((void**)&dcsrRowPtrB, (m + 1) * sizeof(int));
#   hipMalloc((void**)&dcsrColIndB, nnzB * sizeof(int));
#   hipMalloc((void**)&dcsrValB, nnzB * sizeof(float));
#   hipMalloc((void**)&dcsrRowPtrC, (m + 1) * sizeof(int));
# 
#   hipMemcpy(dcsrRowPtrA, hcsrRowPtrA.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColIndA, hcsrColIndA.data(), nnzA * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrValA, hcsrValA.data(), nnzA * sizeof(float), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrRowPtrB, hcsrRowPtrB.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColIndB, hcsrColIndB.data(), nnzB * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrValB, hcsrValB.data(), nnzB * sizeof(float), hipMemcpyHostToDevice);
# 
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t descrA;
#   hipsparseCreateMatDescr(&descrA);
# 
#   hipsparseMatDescr_t descrB;
#   hipsparseCreateMatDescr(&descrB);
# 
#   hipsparseMatDescr_t descrC;
#   hipsparseCreateMatDescr(&descrC);
# 
#   size_t bufferSize;
#   hipsparseScsrgeam2_bufferSizeExt(handle,
#                                    m,
#                                    n,
#                                    &alpha,
#                                    descrA,
#                                    nnzA,
#                                    dcsrValA,
#                                    dcsrRowPtrA,
#                                    dcsrColIndA,
#                                    &beta,
#                                    descrB,
#                                    nnzB,
#                                    dcsrValB,
#                                    dcsrRowPtrB,
#                                    dcsrColIndB,
#                                    descrC,
#                                    nullptr,
#                                    dcsrRowPtrC,
#                                    nullptr,
#                                    &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   int nnzC;
#   hipsparseXcsrgeam2Nnz(handle,
#                       m,
#                       n,
#                       descrA,
#                       nnzA,
#                       dcsrRowPtrA,
#                       dcsrColIndA,
#                       descrB,
#                       nnzB,
#                       dcsrRowPtrB,
#                       dcsrColIndB,
#                       descrC,
#                       dcsrRowPtrC,
#                       &nnzC,
#                       dbuffer);
# 
#   int* dcsrColIndC = nullptr;
#   float* dcsrValC = nullptr;
#   hipMalloc((void**)&dcsrColIndC, sizeof(int) * nnzC);
#   hipMalloc((void**)&dcsrValC, sizeof(float) * nnzC);
# 
#   hipsparseScsrgeam2(handle,
#                     m,
#                     n,
#                     &alpha,
#                     descrA,
#                     nnzA,
#                     dcsrValA,
#                     dcsrRowPtrA,
#                     dcsrColIndA,
#                     &beta,
#                     descrB,
#                     nnzB,
#                     dcsrValB,
#                     dcsrRowPtrB,
#                     dcsrColIndB,
#                     descrC,
#                     dcsrValC,
#                     dcsrRowPtrC,
#                     dcsrColIndC,
#                     dbuffer);
# 
#   hipFree(dcsrRowPtrA);
#   hipFree(dcsrColIndA);
#   hipFree(dcsrValA);
#   hipFree(dcsrRowPtrB);
#   hipFree(dcsrColIndB);
#   hipFree(dcsrValB);
#   hipFree(dcsrRowPtrC);
#   hipFree(dcsrColIndC);
#   hipFree(dcsrValC);
# 
#   hipFree(dbuffer);
# 
#   hipsparseDestroyMatDescr(descrA);
#   hipsparseDestroyMatDescr(descrB);
#   hipsparseDestroyMatDescr(descrC);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseScsrgeam2(void * handle,int m,int n,const float * alpha,void *const descrA,int nnzA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const float * beta,void *const descrB,int nnzB,const float * csrSortedValB,const int * csrSortedRowPtrB,const int * csrSortedColIndB,void *const descrC,float * csrSortedValC,int * csrSortedRowPtrC,int * csrSortedColIndC,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsrgeam2(void * handle,int m,int n,const double * alpha,void *const descrA,int nnzA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,const double * beta,void *const descrB,int nnzB,const double * csrSortedValB,const int * csrSortedRowPtrB,const int * csrSortedColIndB,void *const descrC,double * csrSortedValC,int * csrSortedRowPtrC,int * csrSortedColIndC,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsrgeam2(void * handle,int m,int n,float2 * alpha,void *const descrA,int nnzA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,float2 * beta,void *const descrB,int nnzB,float2 * csrSortedValB,const int * csrSortedRowPtrB,const int * csrSortedColIndB,void *const descrC,float2 * csrSortedValC,int * csrSortedRowPtrC,int * csrSortedColIndC,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsrgeam2(void * handle,int m,int n,double2 * alpha,void *const descrA,int nnzA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,double2 * beta,void *const descrB,int nnzB,double2 * csrSortedValB,const int * csrSortedRowPtrB,const int * csrSortedColIndB,void *const descrC,double2 * csrSortedValC,int * csrSortedRowPtrC,int * csrSortedColIndC,void * pBuffer)


#  \ingroup extra_module
# \brief Sparse matrix sparse matrix multiplication using CSR storage format
# 
# \details
# \p hipsparseXcsrgemmNnz computes the total CSR non-zero elements and the CSR row
# offsets, that point to the start of every row of the sparse CSR matrix, of the
# resulting multiplied matrix C. It is assumed that \p csrRowPtrC has been allocated
# with size \p m+1. The desired index base in the output CSR matrix C is set in the
# hipsparseMatDescr_t \p descrC. See hipsparseSetMatIndexBase().
# 
# \note
# As indicated, nnzTotalDevHostPtr can point either to host or device memory. This is controlled
# by setting the pointer mode. See hipsparseSetPointerMode().
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Please note, that for matrix products with more than 8192 intermediate products per
# row, additional temporary storage buffer is allocated by the algorithm.
# 
# \note
# Currently, only \p transA == \p transB == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE is
# supported.
# 
# \note
# Currently, only \ref HIPSPARSE_MATRIX_TYPE_GENERAL is supported.
cdef hipsparseStatus_t hipsparseXcsrgemmNnz(void * handle,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int n,int k,void *const descrA,int nnzA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const int * csrRowPtrB,const int * csrColIndB,void *const descrC,int * csrRowPtrC,int * nnzTotalDevHostPtr)


#  \ingroup extra_module
# \brief Sparse matrix sparse matrix multiplication using CSR storage format
# 
# \details
# \p hipsparseXcsrgemm multiplies the sparse \f$m \times k\f$ matrix \f$op(A)\f$, defined in
# CSR storage format with the sparse \f$k \times n\f$ matrix \f$op(B)\f$, defined in CSR
# storage format, and stores the result in the sparse \f$m \times n\f$ matrix \f$C\f$,
# defined in CSR storage format, such that
# \f[
#   C := op(A) \cdot op(B),
# \f]
# with
# \f[
#   op(A) = \left\{
#   \begin{array}{ll}
#       A,   & \text{if transA == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       A^T, & \text{if transA == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       A^H, & \text{if transA == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# and
# \f[
#   op(B) = \left\{
#   \begin{array}{ll}
#       B,   & \text{if transB == HIPSPARSE_OPERATION_NON_TRANSPOSE} \\
#       B^T, & \text{if transB == HIPSPARSE_OPERATION_TRANSPOSE} \\
#       B^H, & \text{if transB == HIPSPARSE_OPERATION_CONJUGATE_TRANSPOSE}
#   \end{array}
#   \right.
# \f]
# 
# This computation involves a multi step process. First the user must allocate \p csrRowPtrC
# to have size \p m+1. The user then calls \p hipsparseXcsrgemmNnz which fills in the \p csrRowPtrC
# array as well as computes the total number of nonzeros in C, \p nnzC. The user then allocates both
# arrays \p csrColIndC and \p csrValC to have size \p nnzC and calls \p hipsparseXcsrgemm to complete
# the computation. The desired index base in the output CSR matrix C is set in the
# hipsparseMatDescr_t \p descrC. See hipsparseSetMatIndexBase().
# 
# \note Currently, only \p transA == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE is supported.
# \note Currently, only \p transB == \ref HIPSPARSE_OPERATION_NON_TRANSPOSE is supported.
# \note Currently, only \ref HIPSPARSE_MATRIX_TYPE_GENERAL is supported.
# \note This function is non blocking and executed asynchronously with respect to the
#       host. It may return before the actual computation has finished.
# \note Please note, that for matrix products with more than 4096 non-zero entries per
# row, additional temporary storage buffer is allocated by the algorithm.
# 
# \par Example
# \code{.c}
#   int m = 4;
#   int k = 3;
#   int n = 2;
#   int nnzA = 7;
#   int nnzB = 3;
# 
#   hipsparseOperation_t transA = HIPSPARSE_OPERATION_NON_TRANSPOSE;
#   hipsparseOperation_t transB = HIPSPARSE_OPERATION_NON_TRANSPOSE;
# 
#   // A, B, and C are mxk, kxn, and mn
# 
#   // A
#   // 1 0 0
#   // 3 4 0
#   // 5 6 7
#   // 0 0 9
#   std::vector<int> hcsrRowPtrA = {0, 1, 3, 6, 7};
#   std::vector<int> hcsrColIndA = {0, 0, 1, 0, 1, 2, 2};
#   std::vector<float> hcsrValA = {1.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 9.0f};
# 
#   // B
#   // 0 1
#   // 1 0
#   // 0 1
#   std::vector<int> hcsrRowPtrB = {0, 1, 2, 3};
#   std::vector<int> hcsrColIndB = {1, 0, 1};
#   std::vector<float> hcsrValB = {1.0f, 1.0f, 1.0f};
# 
#   // Device memory management: Allocate and copy A, B
#   int* dcsrRowPtrA;
#   int* dcsrColIndA;
#   float* dcsrValA;
#   int* dcsrRowPtrB;
#   int* dcsrColIndB;
#   float* dcsrValB;
#   int* dcsrRowPtrC;
#   hipMalloc((void**)&dcsrRowPtrA, (m + 1) * sizeof(int));
#   hipMalloc((void**)&dcsrColIndA, nnzA * sizeof(int));
#   hipMalloc((void**)&dcsrValA, nnzA * sizeof(float));
#   hipMalloc((void**)&dcsrRowPtrB, (m + 1) * sizeof(int));
#   hipMalloc((void**)&dcsrColIndB, nnzB * sizeof(int));
#   hipMalloc((void**)&dcsrValB, nnzB * sizeof(float));
#   hipMalloc((void**)&dcsrRowPtrC, (m + 1) * sizeof(int));
# 
#   hipMemcpy(dcsrRowPtrA, hcsrRowPtrA.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColIndA, hcsrColIndA.data(), nnzA * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrValA, hcsrValA.data(), nnzA * sizeof(float), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrRowPtrB, hcsrRowPtrB.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColIndB, hcsrColIndB.data(), nnzB * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrValB, hcsrValB.data(), nnzB * sizeof(float), hipMemcpyHostToDevice);
# 
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t descrA;
#   hipsparseCreateMatDescr(&descrA);
# 
#   hipsparseMatDescr_t descrB;
#   hipsparseCreateMatDescr(&descrB);
# 
#   hipsparseMatDescr_t descrC;
#   hipsparseCreateMatDescr(&descrC);
# 
#   int nnzC;
#   hipsparseXcsrgemmNnz(handle,
#                   transA,
#                   transB,
#                   m,
#                   n,
#                   k,
#                   descrA,
#                   nnzA,
#                   dcsrRowPtrA,
#                   dcsrColIndA,
#                   descrB,
#                   nnzB,
#                   dcsrRowPtrB,
#                   dcsrColIndB,
#                   descrC,
#                   dcsrRowPtrC,
#                   &nnzC);
# 
#   int* dcsrColIndC = nullptr;
#   float* dcsrValC = nullptr;
#   hipMalloc((void**)&dcsrColIndC, sizeof(int) * nnzC);
#   hipMalloc((void**)&dcsrValC, sizeof(float) * nnzC);
# 
#   hipsparseScsrgemm(handle,
#                     transA,
#                     transB,
#                     m,
#                     n,
#                     k,
#                     descrA,
#                     nnzA,
#                     dcsrValA,
#                     dcsrRowPtrA,
#                     dcsrColIndA,
#                     descrB,
#                     nnzB,
#                     dcsrValB,
#                     dcsrRowPtrB,
#                     dcsrColIndB,
#                     descrC,
#                     dcsrValC,
#                     dcsrRowPtrC,
#                     dcsrColIndC);
# 
#   hipFree(dcsrRowPtrA);
#   hipFree(dcsrColIndA);
#   hipFree(dcsrValA);
#   hipFree(dcsrRowPtrB);
#   hipFree(dcsrColIndB);
#   hipFree(dcsrValB);
#   hipFree(dcsrRowPtrC);
#   hipFree(dcsrColIndC);
#   hipFree(dcsrValC);
# 
#   hipsparseDestroyMatDescr(descrA);
#   hipsparseDestroyMatDescr(descrB);
#   hipsparseDestroyMatDescr(descrC);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseScsrgemm(void * handle,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int n,int k,void *const descrA,int nnzA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const float * csrValB,const int * csrRowPtrB,const int * csrColIndB,void *const descrC,float * csrValC,const int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseDcsrgemm(void * handle,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int n,int k,void *const descrA,int nnzA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const double * csrValB,const int * csrRowPtrB,const int * csrColIndB,void *const descrC,double * csrValC,const int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseCcsrgemm(void * handle,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int n,int k,void *const descrA,int nnzA,float2 * csrValA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,float2 * csrValB,const int * csrRowPtrB,const int * csrColIndB,void *const descrC,float2 * csrValC,const int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseZcsrgemm(void * handle,hipsparseOperation_t transA,hipsparseOperation_t transB,int m,int n,int k,void *const descrA,int nnzA,double2 * csrValA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,double2 * csrValB,const int * csrRowPtrB,const int * csrColIndB,void *const descrC,double2 * csrValC,const int * csrRowPtrC,int * csrColIndC)


#  \ingroup extra_module
# \brief Sparse matrix sparse matrix multiplication using CSR storage format
# 
# \details
# \p hipsparseXcsrgemm2_bufferSizeExt returns the size of the temporary storage buffer
# in bytes that is required by hipsparseXcsrgemm2Nnz() and hipsparseXcsrgemm2(). The
# temporary storage buffer must be allocated by the user.
# 
# \note
# Please note, that for matrix products with more than 4096 non-zero entries per row,
# additional temporary storage buffer is allocated by the algorithm.
# 
# \note
# Please note, that for matrix products with more than 8192 intermediate products per
# row, additional temporary storage buffer is allocated by the algorithm.
# 
# \note
# Currently, only \ref HIPSPARSE_MATRIX_TYPE_GENERAL is supported.
cdef hipsparseStatus_t hipsparseScsrgemm2_bufferSizeExt(void * handle,int m,int n,int k,const float * alpha,void *const descrA,int nnzA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const int * csrRowPtrB,const int * csrColIndB,const float * beta,void *const descrD,int nnzD,const int * csrRowPtrD,const int * csrColIndD,csrgemm2Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsrgemm2_bufferSizeExt(void * handle,int m,int n,int k,const double * alpha,void *const descrA,int nnzA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const int * csrRowPtrB,const int * csrColIndB,const double * beta,void *const descrD,int nnzD,const int * csrRowPtrD,const int * csrColIndD,csrgemm2Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsrgemm2_bufferSizeExt(void * handle,int m,int n,int k,float2 * alpha,void *const descrA,int nnzA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const int * csrRowPtrB,const int * csrColIndB,float2 * beta,void *const descrD,int nnzD,const int * csrRowPtrD,const int * csrColIndD,csrgemm2Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsrgemm2_bufferSizeExt(void * handle,int m,int n,int k,double2 * alpha,void *const descrA,int nnzA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const int * csrRowPtrB,const int * csrColIndB,double2 * beta,void *const descrD,int nnzD,const int * csrRowPtrD,const int * csrColIndD,csrgemm2Info_t info,unsigned long * pBufferSizeInBytes)


#  \ingroup extra_module
# \brief Sparse matrix sparse matrix multiplication using CSR storage format
# 
# \details
# \p hipsparseXcsrgemm2Nnz computes the total CSR non-zero elements and the CSR row
# offsets, that point to the start of every row of the sparse CSR matrix, of the
# resulting multiplied matrix C. It is assumed that \p csrRowPtrC has been allocated
# with size \p m+1. The required buffer size can be obtained by hipsparseXcsrgemm2_bufferSizeExt().
# The desired index base in the output CSR matrix C is set in the hipsparseMatDescr_t
# \p descrC. See hipsparseSetMatIndexBase().
# 
# \note
# As indicated, nnzTotalDevHostPtr can point either to host or device memory. This is controlled
# by setting the pointer mode. See hipsparseSetPointerMode().
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \note
# Please note, that for matrix products with more than 8192 intermediate products per
# row, additional temporary storage buffer is allocated by the algorithm.
# 
# \note
# Currently, only \ref HIPSPARSE_MATRIX_TYPE_GENERAL is supported.
cdef hipsparseStatus_t hipsparseXcsrgemm2Nnz(void * handle,int m,int n,int k,void *const descrA,int nnzA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const int * csrRowPtrB,const int * csrColIndB,void *const descrD,int nnzD,const int * csrRowPtrD,const int * csrColIndD,void *const descrC,int * csrRowPtrC,int * nnzTotalDevHostPtr,csrgemm2Info_t info,void * pBuffer)


#  \ingroup extra_module
# \brief Sparse matrix sparse matrix multiplication using CSR storage format
# 
# \details
# \p hipsparseXcsrgemm2 multiplies the scalar \f$\alpha\f$ with the sparse
# \f$m \times k\f$ matrix \f$A\f$, defined in CSR storage format, and the sparse
# \f$k \times n\f$ matrix \f$B\f$, defined in CSR storage format, and adds the result
# to the sparse \f$m \times n\f$ matrix \f$D\f$ that is multiplied by \f$\beta\f$. The
# final result is stored in the sparse \f$m \times n\f$ matrix \f$C\f$, defined in CSR
# storage format, such
# that
# \f[
#   C := \alpha \cdot A \cdot B + \beta \cdot D
# \f]
# 
# This computation involves a multi step process. First the user must call \p
# \p hipsparseZcsrgemm2_bufferSizeExt in order to determine the required user allocated
# temporary buffer size. The user then allocates this buffer and also allocates \p csrRowPtrC
# to have size \p m+1. Both the temporary storage buffer and \p csrRowPtrC array are then passed to
# \p hipsparseXcsrgemm2Nnz which fills in the \p csrRowPtrC array as well as computes the total number
# of nonzeros in C, \p nnzC. The user then allocates both arrays \p csrColIndC and \p csrValC to have
# size \p nnzC and calls \p hipsparseXcsrgemm2 to complete the computation. The desired index base in
# the output CSR matrix C is set in the hipsparseMatDescr_t \p descrC. See hipsparseSetMatIndexBase().
# 
# \note If \f$\alpha == 0\f$, then \f$C = \beta \cdot D\f$ will be computed.
# \note If \f$\beta == 0\f$, then \f$C = \alpha \cdot A \cdot B\f$ will be computed.
# \note \f$\alpha == beta == 0\f$ is invalid.
# \note Currently, only \ref HIPSPARSE_MATRIX_TYPE_GENERAL is supported.
# \note This function is non blocking and executed asynchronously with respect to the
#       host. It may return before the actual computation has finished.
# \note Please note, that for matrix products with more than 4096 non-zero entries per
# row, additional temporary storage buffer is allocated by the algorithm.
# 
# \par Example
# \code{.c}
#   int m = 4;
#   int k = 3;
#   int n = 2;
#   int nnzA = 7;
#   int nnzB = 3;
#   int nnzD = 6;
# 
#   float alpha{1.0f};
#   float beta{1.0f};
# 
#   // A, B, and C are mxk, kxn, and mn
# 
#   // A
#   // 1 0 0
#   // 3 4 0
#   // 5 6 7
#   // 0 0 9
#   std::vector<int> hcsrRowPtrA = {0, 1, 3, 6, 7};
#   std::vector<int> hcsrColIndA = {0, 0, 1, 0, 1, 2, 2};
#   std::vector<float> hcsrValA = {1.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 9.0f};
# 
#   // B
#   // 0 1
#   // 1 0
#   // 0 1
#   std::vector<int> hcsrRowPtrB = {0, 1, 2, 3};
#   std::vector<int> hcsrColIndB = {1, 0, 1};
#   std::vector<float> hcsrValB = {1.0f, 1.0f, 1.0f};
# 
#   // D
#   // 0 1
#   // 2 3
#   // 4 5
#   // 0 6
#   std::vector<int> hcsrRowPtrD = {0, 1, 3, 5, 6};
#   std::vector<int> hcsrColIndD = {1, 0, 1, 0, 1, 1};
#   std::vector<float> hcsrValD = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};
# 
#   // Device memory management: Allocate and copy A, B
#   int* dcsrRowPtrA;
#   int* dcsrColIndA;
#   float* dcsrValA;
#   int* dcsrRowPtrB;
#   int* dcsrColIndB;
#   float* dcsrValB;
#   int* dcsrRowPtrD;
#   int* dcsrColIndD;
#   float* dcsrValD;
#   int* dcsrRowPtrC;
#   hipMalloc((void**)&dcsrRowPtrA, (m + 1) * sizeof(int));
#   hipMalloc((void**)&dcsrColIndA, nnzA * sizeof(int));
#   hipMalloc((void**)&dcsrValA, nnzA * sizeof(float));
#   hipMalloc((void**)&dcsrRowPtrB, (k + 1) * sizeof(int));
#   hipMalloc((void**)&dcsrColIndB, nnzB * sizeof(int));
#   hipMalloc((void**)&dcsrValB, nnzB * sizeof(float));
#   hipMalloc((void**)&dcsrRowPtrD, (m + 1) * sizeof(int));
#   hipMalloc((void**)&dcsrColIndD, nnzD * sizeof(int));
#   hipMalloc((void**)&dcsrValD, nnzD * sizeof(float));
#   hipMalloc((void**)&dcsrRowPtrC, (m + 1) * sizeof(int));
# 
#   hipMemcpy(dcsrRowPtrA, hcsrRowPtrA.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColIndA, hcsrColIndA.data(), nnzA * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrValA, hcsrValA.data(), nnzA * sizeof(float), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrRowPtrB, hcsrRowPtrB.data(), (k + 1) * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColIndB, hcsrColIndB.data(), nnzB * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrValB, hcsrValB.data(), nnzB * sizeof(float), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrRowPtrD, hcsrRowPtrD.data(), (m + 1) * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColIndD, hcsrColIndD.data(), nnzD * sizeof(int), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrValD, hcsrValD.data(), nnzD * sizeof(float), hipMemcpyHostToDevice);
# 
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t descrA;
#   hipsparseCreateMatDescr(&descrA);
# 
#   hipsparseMatDescr_t descrB;
#   hipsparseCreateMatDescr(&descrB);
# 
#   hipsparseMatDescr_t descrC;
#   hipsparseCreateMatDescr(&descrC);
# 
#   hipsparseMatDescr_t descrD;
#   hipsparseCreateMatDescr(&descrD);
# 
#   csrgemm2Info_t info;
#   hipsparseCreateCsrgemm2Info(&info);
# 
#   size_t bufferSize;
#   hipsparseScsrgemm2_bufferSizeExt(handle,
#                                    m,
#                                    n,
#                                    k,
#                                    &alpha,
#                                    descrA,
#                                    nnzA,
#                                    dcsrRowPtrA,
#                                    dcsrColIndA,
#                                    descrB,
#                                    nnzB,
#                                    dcsrRowPtrB,
#                                    dcsrColIndB,
#                                    &beta,
#                                    descrD,
#                                    nnzD,
#                                    dcsrRowPtrD,
#                                    dcsrColIndD,
#                                    info,
#                                    &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   int nnzC;
#   hipsparseXcsrgemm2Nnz(handle,
#                   m,
#                   n,
#                   k,
#                   descrA,
#                   nnzA,
#                   dcsrRowPtrA,
#                   dcsrColIndA,
#                   descrB,
#                   nnzB,
#                   dcsrRowPtrB,
#                   dcsrColIndB,
#                   descrD,
#                   nnzD,
#                   dcsrRowPtrD,
#                   dcsrColIndD,
#                   descrC,
#                   dcsrRowPtrC,
#                   &nnzC,
#                   info,
#                   dbuffer);
# 
#   int* dcsrColIndC = nullptr;
#   float* dcsrValC = nullptr;
#   hipMalloc((void**)&dcsrColIndC, sizeof(int) * nnzC);
#   hipMalloc((void**)&dcsrValC, sizeof(float) * nnzC);
# 
#   hipsparseScsrgemm2(handle,
#                     m,
#                     n,
#                     k,
#                     &alpha,
#                     descrA,
#                     nnzA,
#                     dcsrValA,
#                     dcsrRowPtrA,
#                     dcsrColIndA,
#                     descrB,
#                     nnzB,
#                     dcsrValB,
#                     dcsrRowPtrB,
#                     dcsrColIndB,
#                     &beta,
#                     descrD,
#                     nnzD,
#                     dcsrValD,
#                     dcsrRowPtrD,
#                     dcsrColIndD,
#                     descrC,
#                     dcsrValC,
#                     dcsrRowPtrC,
#                     dcsrColIndC,
#                     info,
#                     dbuffer);
# 
#   hipFree(dcsrRowPtrA);
#   hipFree(dcsrColIndA);
#   hipFree(dcsrValA);
#   hipFree(dcsrRowPtrB);
#   hipFree(dcsrColIndB);
#   hipFree(dcsrValB);
#   hipFree(dcsrRowPtrC);
#   hipFree(dcsrColIndC);
#   hipFree(dcsrValC);
#   hipFree(dcsrRowPtrD);
#   hipFree(dcsrColIndD);
#   hipFree(dcsrValD);
# 
#   hipFree(dbuffer);
# 
#   hipsparseDestroyMatDescr(descrA);
#   hipsparseDestroyMatDescr(descrB);
#   hipsparseDestroyMatDescr(descrC);
#   hipsparseDestroyMatDescr(descrD);
#   hipsparseDestroyCsrgemm2Info(info);
# 
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseScsrgemm2(void * handle,int m,int n,int k,const float * alpha,void *const descrA,int nnzA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const float * csrValB,const int * csrRowPtrB,const int * csrColIndB,const float * beta,void *const descrD,int nnzD,const float * csrValD,const int * csrRowPtrD,const int * csrColIndD,void *const descrC,float * csrValC,const int * csrRowPtrC,int * csrColIndC,csrgemm2Info_t info,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsrgemm2(void * handle,int m,int n,int k,const double * alpha,void *const descrA,int nnzA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,const double * csrValB,const int * csrRowPtrB,const int * csrColIndB,const double * beta,void *const descrD,int nnzD,const double * csrValD,const int * csrRowPtrD,const int * csrColIndD,void *const descrC,double * csrValC,const int * csrRowPtrC,int * csrColIndC,csrgemm2Info_t info,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsrgemm2(void * handle,int m,int n,int k,float2 * alpha,void *const descrA,int nnzA,float2 * csrValA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,float2 * csrValB,const int * csrRowPtrB,const int * csrColIndB,float2 * beta,void *const descrD,int nnzD,float2 * csrValD,const int * csrRowPtrD,const int * csrColIndD,void *const descrC,float2 * csrValC,const int * csrRowPtrC,int * csrColIndC,csrgemm2Info_t info,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsrgemm2(void * handle,int m,int n,int k,double2 * alpha,void *const descrA,int nnzA,double2 * csrValA,const int * csrRowPtrA,const int * csrColIndA,void *const descrB,int nnzB,double2 * csrValB,const int * csrRowPtrB,const int * csrColIndB,double2 * beta,void *const descrD,int nnzD,double2 * csrValD,const int * csrRowPtrD,const int * csrColIndD,void *const descrC,double2 * csrValC,const int * csrRowPtrC,int * csrColIndC,csrgemm2Info_t info,void * pBuffer)


# \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage
# format
# 
# \details
# \p hipsparseXbsrilu02_zeroPivot returns \ref HIPSPARSE_STATUS_ZERO_PIVOT, if either a
# structural or numerical zero has been found during hipsparseXbsrilu02_analysis() or
# hipsparseXbsrilu02() computation. The first zero pivot \f$j\f$ at \f$A_{j,j}\f$ is
# stored in \p position, using same index base as the BSR matrix.
# 
# \p position can be in host or device memory. If no zero pivot has been found,
# \p position is set to -1 and \ref HIPSPARSE_STATUS_SUCCESS is returned instead.
# 
# \note
# If a zero pivot is found, \p position \f$=j\f$ means that either the diagonal block
# \f$A_{j,j}\f$ is missing (structural zero) or the diagonal block \f$A_{j,j}\f$ is not
# invertible (numerical zero).
# 
# \note \p hipsparseXbsrilu02_zeroPivot is a blocking function. It might influence
# performance negatively.
cdef hipsparseStatus_t hipsparseXbsrilu02_zeroPivot(void * handle,bsrilu02Info_t info,int * position)


# \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage
# format
# 
# \details
# \p hipsparseXbsrilu02_numericBoost enables the user to replace a numerical value in
# an incomplete LU factorization. \p tol is used to determine whether a numerical value
# is replaced by \p boost_val, such that \f$A_{j,j} = \text{boost_val}\f$ if
# \f$\text{tol} \ge \left|A_{j,j}\right|\f$.
# 
# \note The boost value is enabled by setting \p enable_boost to 1 or disabled by
# setting \p enable_boost to 0.
# 
# \note \p tol and \p boost_val can be in host or device memory.
cdef hipsparseStatus_t hipsparseSbsrilu02_numericBoost(void * handle,bsrilu02Info_t info,int enable_boost,double * tol,float * boost_val)



cdef hipsparseStatus_t hipsparseDbsrilu02_numericBoost(void * handle,bsrilu02Info_t info,int enable_boost,double * tol,double * boost_val)



cdef hipsparseStatus_t hipsparseCbsrilu02_numericBoost(void * handle,bsrilu02Info_t info,int enable_boost,double * tol,float2 * boost_val)



cdef hipsparseStatus_t hipsparseZbsrilu02_numericBoost(void * handle,bsrilu02Info_t info,int enable_boost,double * tol,double2 * boost_val)


# \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage
# format
# 
# \details
# \p hipsparseXbsrilu02_bufferSize returns the size of the temporary storage buffer
# in bytes that is required by hipsparseXbsrilu02_analysis() and hipsparseXbsrilu02().
# The temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSbsrilu02_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDbsrilu02_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCbsrilu02_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZbsrilu02_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,int * pBufferSizeInBytes)


# \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage
# format
# 
# \details
# \p hipsparseXbsrilu02_analysis performs the analysis step for hipsparseXbsrilu02().
# 
# \note
# If the matrix sparsity pattern changes, the gathered information will become invalid.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSbsrilu02_analysis(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDbsrilu02_analysis(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCbsrilu02_analysis(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZbsrilu02_analysis(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double2 * bsrSortedValA,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


# \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage
# format
# 
# \details
# \p hipsparseXbsrilu02 computes the incomplete LU factorization with 0 fill-ins and no
# pivoting of a sparse \f$mb \times mb\f$ BSR matrix \f$A\f$, such that
# \f[
#   A \approx LU
# \f]
# 
# \p hipsparseXbsrilu02 requires a user allocated temporary buffer. Its size is
# returned by hipsparseXbsrilu02_bufferSize(). Furthermore, analysis meta data is
# required. It can be obtained by hipsparseXbsrilu02_analysis(). \p hipsparseXbsrilu02
# reports the first zero pivot (either numerical or structural zero). The zero pivot
# status can be obtained by calling hipsparseXbsrilu02_zeroPivot().
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSbsrilu02(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float * bsrSortedValA_valM,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDbsrilu02(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double * bsrSortedValA_valM,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCbsrilu02(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float2 * bsrSortedValA_valM,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZbsrilu02(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double2 * bsrSortedValA_valM,const int * bsrSortedRowPtrA,const int * bsrSortedColIndA,int blockDim,bsrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR
# storage format
# 
# \details
# \p hipsparseXcsrilu02_zeroPivot returns \ref HIPSPARSE_STATUS_ZERO_PIVOT, if either a
# structural or numerical zero has been found during hipsparseXcsrilu02() computation.
# The first zero pivot \f$j\f$ at \f$A_{j,j}\f$ is stored in \p position, using same
# index base as the CSR matrix.
# 
# \p position can be in host or device memory. If no zero pivot has been found,
# \p position is set to -1 and \ref HIPSPARSE_STATUS_SUCCESS is returned instead.
# 
# \note \p hipsparseXcsrilu02_zeroPivot is a blocking function. It might influence
# performance negatively.
cdef hipsparseStatus_t hipsparseXcsrilu02_zeroPivot(void * handle,csrilu02Info_t info,int * position)


# \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR storage
# format
# 
# \details
# \p hipsparseXcsrilu02_numericBoost enables the user to replace a numerical value in
# an incomplete LU factorization. \p tol is used to determine whether a numerical value
# is replaced by \p boost_val, such that \f$A_{j,j} = \text{boost_val}\f$ if
# \f$\text{tol} \ge \left|A_{j,j}\right|\f$.
# 
# \note The boost value is enabled by setting \p enable_boost to 1 or disabled by
# setting \p enable_boost to 0.
# 
# \note \p tol and \p boost_val can be in host or device memory.
cdef hipsparseStatus_t hipsparseScsrilu02_numericBoost(void * handle,csrilu02Info_t info,int enable_boost,double * tol,float * boost_val)



cdef hipsparseStatus_t hipsparseDcsrilu02_numericBoost(void * handle,csrilu02Info_t info,int enable_boost,double * tol,double * boost_val)



cdef hipsparseStatus_t hipsparseCcsrilu02_numericBoost(void * handle,csrilu02Info_t info,int enable_boost,double * tol,float2 * boost_val)



cdef hipsparseStatus_t hipsparseZcsrilu02_numericBoost(void * handle,csrilu02Info_t info,int enable_boost,double * tol,double2 * boost_val)


#  \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR
# storage format
# 
# \details
# \p hipsparseXcsrilu02_bufferSize returns the size of the temporary storage buffer
# in bytes that is required by hipsparseXcsrilu02_analysis() and hipsparseXcsrilu02_solve().
# The temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseScsrilu02_bufferSize(void * handle,int m,int nnz,void *const descrA,float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsrilu02_bufferSize(void * handle,int m,int nnz,void *const descrA,double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsrilu02_bufferSize(void * handle,int m,int nnz,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsrilu02_bufferSize(void * handle,int m,int nnz,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,int * pBufferSizeInBytes)


#  \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR
# storage format
# 
# \details
# \p hipsparseXcsrilu02_bufferSizeExt returns the size of the temporary storage buffer
# in bytes that is required by hipsparseXcsrilu02_analysis() and hipsparseXcsrilu02_solve().
# The temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseScsrilu02_bufferSizeExt(void * handle,int m,int nnz,void *const descrA,float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsrilu02_bufferSizeExt(void * handle,int m,int nnz,void *const descrA,double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsrilu02_bufferSizeExt(void * handle,int m,int nnz,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsrilu02_bufferSizeExt(void * handle,int m,int nnz,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,unsigned long * pBufferSizeInBytes)


#  \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR
# storage format
# 
# \details
# \p hipsparseXcsrilu02_analysis performs the analysis step for hipsparseXcsrilu02().
# 
# \note
# If the matrix sparsity pattern changes, the gathered information will become invalid.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseScsrilu02_analysis(void * handle,int m,int nnz,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsrilu02_analysis(void * handle,int m,int nnz,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsrilu02_analysis(void * handle,int m,int nnz,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsrilu02_analysis(void * handle,int m,int nnz,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup precond_module
# \brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR
# storage format
# 
# \details
# \p hipsparseXcsrilu02 computes the incomplete LU factorization with 0 fill-ins and no
# pivoting of a sparse \f$m \times m\f$ CSR matrix \f$A\f$, such that
# \f[
#   A \approx LU
# \f]
# 
# \p hipsparseXcsrilu02 requires a user allocated temporary buffer. Its size is returned
# by hipsparseXcsrilu02_bufferSize() or hipsparseXcsrilu02_bufferSizeExt(). Furthermore,
# analysis meta data is required. It can be obtained by hipsparseXcsrilu02_analysis().
# \p hipsparseXcsrilu02 reports the first zero pivot (either numerical or structural
# zero). The zero pivot status can be obtained by calling hipsparseXcsrilu02_zeroPivot().
# 
# \note
# The sparse CSR matrix has to be sorted. This can be achieved by calling
# hipsparseXcsrsort().
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseScsrilu02(void * handle,int m,int nnz,void *const descrA,float * csrSortedValA_valM,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsrilu02(void * handle,int m,int nnz,void *const descrA,double * csrSortedValA_valM,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsrilu02(void * handle,int m,int nnz,void *const descrA,float2 * csrSortedValA_valM,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsrilu02(void * handle,int m,int nnz,void *const descrA,double2 * csrSortedValA_valM,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csrilu02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


# \ingroup precond_module
# \brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR
# storage format
# 
# \details
# \p hipsparseXbsric02_zeroPivot returns \ref HIPSPARSE_STATUS_ZERO_PIVOT, if either a
# structural or numerical zero has been found during hipsparseXbsric02_analysis() or
# hipsparseXbsric02() computation. The first zero pivot \f$j\f$ at \f$A_{j,j}\f$ is
# stored in \p position, using same index base as the BSR matrix.
# 
# \p position can be in host or device memory. If no zero pivot has been found,
# \p position is set to -1 and \ref HIPSPARSE_STATUS_SUCCESS is returned instead.
# 
# \note
# If a zero pivot is found, \p position=j means that either the diagonal block \p A(j,j)
# is missing (structural zero) or the diagonal block \p A(j,j) is not positive definite
# (numerical zero).
# 
# \note \p hipsparseXbsric02_zeroPivot is a blocking function. It might influence
# performance negatively.
cdef hipsparseStatus_t hipsparseXbsric02_zeroPivot(void * handle,bsric02Info_t info,int * position)


# \ingroup precond_module
# \brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR
# storage format
# 
# \details
# \p hipsparseXbsric02_bufferSize returns the size of the temporary storage buffer
# in bytes that is required by hipsparseXbsric02_analysis() and hipsparseXbsric02().
# The temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSbsric02_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDbsric02_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCbsric02_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZbsric02_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,int * pBufferSizeInBytes)


# \ingroup precond_module
# \brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR
# storage format
# 
# \details
# \p hipsparseXbsric02_analysis performs the analysis step for hipsparseXbsric02().
# 
# \note
# If the matrix sparsity pattern changes, the gathered information will become invalid.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSbsric02_analysis(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,const float * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDbsric02_analysis(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,const double * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCbsric02_analysis(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZbsric02_analysis(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


# \ingroup precond_module
# \brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR
# storage format
# 
# \details
# \p hipsparseXbsric02 computes the incomplete Cholesky factorization with 0 fill-ins
# and no pivoting of a sparse \f$mb \times mb\f$ BSR matrix \f$A\f$, such that
# \f[
#   A \approx LL^T
# \f]
# 
# \p hipsparseXbsric02 requires a user allocated temporary buffer. Its size is returned
# by hipsparseXbsric02_bufferSize(). Furthermore, analysis meta data is required. It
# can be obtained by hipsparseXbsric02_analysis(). \p hipsparseXbsric02 reports the
# first zero pivot (either numerical or structural zero). The zero pivot status can be
# obtained by calling hipsparseXbsric02_zeroPivot().
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSbsric02(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDbsric02(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCbsric02(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,float2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZbsric02(void * handle,hipsparseDirection_t dirA,int mb,int nnzb,void *const descrA,double2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,bsric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup precond_module
# \brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR
# storage format
# 
# \details
# \p hipsparseXcsric02_zeroPivot returns \ref HIPSPARSE_STATUS_ZERO_PIVOT, if either a
# structural or numerical zero has been found during hipsparseXcsric02_analysis() or
# hipsparseXcsric02() computation. The first zero pivot \f$j\f$ at \f$A_{j,j}\f$
# is stored in \p position, using same index base as the CSR matrix.
# 
# \p position can be in host or device memory. If no zero pivot has been found,
# \p position is set to -1 and \ref HIPSPARSE_STATUS_SUCCESS is returned instead.
# 
# \note \p hipsparseXcsric02_zeroPivot is a blocking function. It might influence
# performance negatively.
cdef hipsparseStatus_t hipsparseXcsric02_zeroPivot(void * handle,csric02Info_t info,int * position)


#  \ingroup precond_module
# \brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR
# storage format
# 
# \details
# \p hipsparseXcsric02_bufferSize returns the size of the temporary storage buffer in bytes
# that is required by hipsparseXcsric02_analysis() and hipsparseXcsric02().
cdef hipsparseStatus_t hipsparseScsric02_bufferSize(void * handle,int m,int nnz,void *const descrA,float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsric02_bufferSize(void * handle,int m,int nnz,void *const descrA,double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsric02_bufferSize(void * handle,int m,int nnz,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsric02_bufferSize(void * handle,int m,int nnz,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,int * pBufferSizeInBytes)


#  \ingroup precond_module
# \brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR
# storage format
# 
# \details
# \p hipsparseXcsric02_bufferSizeExt returns the size of the temporary storage buffer
# in bytes that is required by hipsparseXcsric02_analysis() and hipsparseXcsric02().
cdef hipsparseStatus_t hipsparseScsric02_bufferSizeExt(void * handle,int m,int nnz,void *const descrA,float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsric02_bufferSizeExt(void * handle,int m,int nnz,void *const descrA,double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsric02_bufferSizeExt(void * handle,int m,int nnz,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsric02_bufferSizeExt(void * handle,int m,int nnz,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,unsigned long * pBufferSizeInBytes)


#  \ingroup precond_module
# \brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR
# storage format
# 
# \details
# \p hipsparseXcsric02_analysis performs the analysis step for hipsparseXcsric02().
# 
# \note
# If the matrix sparsity pattern changes, the gathered information will become invalid.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseScsric02_analysis(void * handle,int m,int nnz,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsric02_analysis(void * handle,int m,int nnz,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsric02_analysis(void * handle,int m,int nnz,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsric02_analysis(void * handle,int m,int nnz,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup precond_module
# \brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR
# storage format
# 
# \details
# \p hipsparseXcsric02 computes the incomplete Cholesky factorization with 0 fill-ins
# and no pivoting of a sparse \f$m \times m\f$ CSR matrix \f$A\f$, such that
# \f[
#   A \approx LL^T
# \f]
# 
# \p hipsparseXcsric02 requires a user allocated temporary buffer. Its size is returned
# by hipsparseXcsric02_bufferSize() or hipsparseXcsric02_bufferSizeExt(). Furthermore,
# analysis meta data is required. It can be obtained by hipsparseXcsric02_analysis().
# \p hipsparseXcsric02 reports the first zero pivot (either numerical or structural
# zero). The zero pivot status can be obtained by calling hipsparseXcsric02_zeroPivot().
# 
# \note
# The sparse CSR matrix has to be sorted. This can be achieved by calling
# hipsparseXcsrsort().
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseScsric02(void * handle,int m,int nnz,void *const descrA,float * csrSortedValA_valM,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsric02(void * handle,int m,int nnz,void *const descrA,double * csrSortedValA_valM,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsric02(void * handle,int m,int nnz,void *const descrA,float2 * csrSortedValA_valM,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsric02(void * handle,int m,int nnz,void *const descrA,double2 * csrSortedValA_valM,const int * csrSortedRowPtrA,const int * csrSortedColIndA,csric02Info_t info,hipsparseSolvePolicy_t policy,void * pBuffer)


#  \ingroup precond_module
# \brief Tridiagonal solver with pivoting
# 
# \details
# \p hipsparseXgtsv2_bufferSize returns the size of the temporary storage buffer
# in bytes that is required by hipsparseXgtsv2(). The temporary storage buffer must
# be allocated by the user.
cdef hipsparseStatus_t hipsparseSgtsv2_bufferSizeExt(void * handle,int m,int n,const float * dl,const float * d,const float * du,const float * B,int ldb,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDgtsv2_bufferSizeExt(void * handle,int m,int n,const double * dl,const double * d,const double * du,const double * B,int db,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCgtsv2_bufferSizeExt(void * handle,int m,int n,float2 * dl,float2 * d,float2 * du,float2 * B,int ldb,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZgtsv2_bufferSizeExt(void * handle,int m,int n,double2 * dl,double2 * d,double2 * du,double2 * B,int ldb,unsigned long * pBufferSizeInBytes)


#  \ingroup precond_module
# \brief Tridiagonal solver with pivoting
# 
# \details
# \p hipsparseXgtsv2 solves a tridiagonal system for multiple right hand sides using pivoting.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSgtsv2(void * handle,int m,int n,const float * dl,const float * d,const float * du,float * B,int ldb,void * pBuffer)



cdef hipsparseStatus_t hipsparseDgtsv2(void * handle,int m,int n,const double * dl,const double * d,const double * du,double * B,int ldb,void * pBuffer)



cdef hipsparseStatus_t hipsparseCgtsv2(void * handle,int m,int n,float2 * dl,float2 * d,float2 * du,float2 * B,int ldb,void * pBuffer)



cdef hipsparseStatus_t hipsparseZgtsv2(void * handle,int m,int n,double2 * dl,double2 * d,double2 * du,double2 * B,int ldb,void * pBuffer)


#  \ingroup precond_module
# \brief Tridiagonal solver (no pivoting)
# 
# \details
# \p hipsparseXgtsv2_nopivot_bufferSizeExt returns the size of the temporary storage
# buffer in bytes that is required by hipsparseXgtsv2_nopivot(). The temporary storage
# buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSgtsv2_nopivot_bufferSizeExt(void * handle,int m,int n,const float * dl,const float * d,const float * du,const float * B,int ldb,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDgtsv2_nopivot_bufferSizeExt(void * handle,int m,int n,const double * dl,const double * d,const double * du,const double * B,int db,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCgtsv2_nopivot_bufferSizeExt(void * handle,int m,int n,float2 * dl,float2 * d,float2 * du,float2 * B,int ldb,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZgtsv2_nopivot_bufferSizeExt(void * handle,int m,int n,double2 * dl,double2 * d,double2 * du,double2 * B,int ldb,unsigned long * pBufferSizeInBytes)


#  \ingroup precond_module
# \brief Tridiagonal solver (no pivoting)
# 
# \details
# \p hipsparseXgtsv2_nopivot solves a tridiagonal linear system for multiple right-hand sides
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSgtsv2_nopivot(void * handle,int m,int n,const float * dl,const float * d,const float * du,float * B,int ldb,void * pBuffer)



cdef hipsparseStatus_t hipsparseDgtsv2_nopivot(void * handle,int m,int n,const double * dl,const double * d,const double * du,double * B,int ldb,void * pBuffer)



cdef hipsparseStatus_t hipsparseCgtsv2_nopivot(void * handle,int m,int n,float2 * dl,float2 * d,float2 * du,float2 * B,int ldb,void * pBuffer)



cdef hipsparseStatus_t hipsparseZgtsv2_nopivot(void * handle,int m,int n,double2 * dl,double2 * d,double2 * du,double2 * B,int ldb,void * pBuffer)


#  \ingroup precond_module
# \brief Strided Batch tridiagonal solver (no pivoting)
# 
# \details
# \p hipsparseXgtsv2StridedBatch_bufferSizeExt returns the size of the temporary storage
# buffer in bytes that is required by hipsparseXgtsv2StridedBatch(). The temporary
# storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSgtsv2StridedBatch_bufferSizeExt(void * handle,int m,const float * dl,const float * d,const float * du,const float * x,int batchCount,int batchStride,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDgtsv2StridedBatch_bufferSizeExt(void * handle,int m,const double * dl,const double * d,const double * du,const double * x,int batchCount,int batchStride,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCgtsv2StridedBatch_bufferSizeExt(void * handle,int m,float2 * dl,float2 * d,float2 * du,float2 * x,int batchCount,int batchStride,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZgtsv2StridedBatch_bufferSizeExt(void * handle,int m,double2 * dl,double2 * d,double2 * du,double2 * x,int batchCount,int batchStride,unsigned long * pBufferSizeInBytes)


#  \ingroup precond_module
# \brief Strided Batch tridiagonal solver (no pivoting)
# 
# \details
# \p hipsparseXgtsv2StridedBatch solves a batched tridiagonal linear system
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSgtsv2StridedBatch(void * handle,int m,const float * dl,const float * d,const float * du,float * x,int batchCount,int batchStride,void * pBuffer)



cdef hipsparseStatus_t hipsparseDgtsv2StridedBatch(void * handle,int m,const double * dl,const double * d,const double * du,double * x,int batchCount,int batchStride,void * pBuffer)



cdef hipsparseStatus_t hipsparseCgtsv2StridedBatch(void * handle,int m,float2 * dl,float2 * d,float2 * du,float2 * x,int batchCount,int batchStride,void * pBuffer)



cdef hipsparseStatus_t hipsparseZgtsv2StridedBatch(void * handle,int m,double2 * dl,double2 * d,double2 * du,double2 * x,int batchCount,int batchStride,void * pBuffer)


#  \ingroup precond_module
# \brief Interleaved Batch tridiagonal solver
# 
# \details
# \p hipsparseXgtsvInterleavedBatch_bufferSizeExt returns the size of the temporary storage
# buffer in bytes that is required by hipsparseXgtsvInterleavedBatch(). The temporary storage
# buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSgtsvInterleavedBatch_bufferSizeExt(void * handle,int algo,int m,const float * dl,const float * d,const float * du,const float * x,int batchCount,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDgtsvInterleavedBatch_bufferSizeExt(void * handle,int algo,int m,const double * dl,const double * d,const double * du,const double * x,int batchCount,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCgtsvInterleavedBatch_bufferSizeExt(void * handle,int algo,int m,float2 * dl,float2 * d,float2 * du,float2 * x,int batchCount,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZgtsvInterleavedBatch_bufferSizeExt(void * handle,int algo,int m,double2 * dl,double2 * d,double2 * du,double2 * x,int batchCount,unsigned long * pBufferSizeInBytes)


#  \ingroup precond_module
# \brief Interleaved Batch tridiagonal solver
# 
# \details
# \p hipsparseXgtsvInterleavedBatch solves a batched tridiagonal linear system
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSgtsvInterleavedBatch(void * handle,int algo,int m,float * dl,float * d,float * du,float * x,int batchCount,void * pBuffer)



cdef hipsparseStatus_t hipsparseDgtsvInterleavedBatch(void * handle,int algo,int m,double * dl,double * d,double * du,double * x,int batchCount,void * pBuffer)



cdef hipsparseStatus_t hipsparseCgtsvInterleavedBatch(void * handle,int algo,int m,float2 * dl,float2 * d,float2 * du,float2 * x,int batchCount,void * pBuffer)



cdef hipsparseStatus_t hipsparseZgtsvInterleavedBatch(void * handle,int algo,int m,double2 * dl,double2 * d,double2 * du,double2 * x,int batchCount,void * pBuffer)


#  \ingroup precond_module
# \brief Interleaved Batch pentadiagonal solver
# 
# \details
# \p hipsparseXgpsvInterleavedBatch_bufferSizeExt returns the size of the temporary storage
# buffer in bytes that is required by hipsparseXgpsvInterleavedBatch(). The temporary
# storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSgpsvInterleavedBatch_bufferSizeExt(void * handle,int algo,int m,const float * ds,const float * dl,const float * d,const float * du,const float * dw,const float * x,int batchCount,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDgpsvInterleavedBatch_bufferSizeExt(void * handle,int algo,int m,const double * ds,const double * dl,const double * d,const double * du,const double * dw,const double * x,int batchCount,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCgpsvInterleavedBatch_bufferSizeExt(void * handle,int algo,int m,float2 * ds,float2 * dl,float2 * d,float2 * du,float2 * dw,float2 * x,int batchCount,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZgpsvInterleavedBatch_bufferSizeExt(void * handle,int algo,int m,double2 * ds,double2 * dl,double2 * d,double2 * du,double2 * dw,double2 * x,int batchCount,unsigned long * pBufferSizeInBytes)


#  \ingroup precond_module
# \brief Interleaved Batch pentadiagonal solver
# 
# \details
# \p hipsparseXgpsvInterleavedBatch solves a batched pentadiagonal linear system
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseSgpsvInterleavedBatch(void * handle,int algo,int m,float * ds,float * dl,float * d,float * du,float * dw,float * x,int batchCount,void * pBuffer)



cdef hipsparseStatus_t hipsparseDgpsvInterleavedBatch(void * handle,int algo,int m,double * ds,double * dl,double * d,double * du,double * dw,double * x,int batchCount,void * pBuffer)



cdef hipsparseStatus_t hipsparseCgpsvInterleavedBatch(void * handle,int algo,int m,float2 * ds,float2 * dl,float2 * d,float2 * du,float2 * dw,float2 * x,int batchCount,void * pBuffer)



cdef hipsparseStatus_t hipsparseZgpsvInterleavedBatch(void * handle,int algo,int m,double2 * ds,double2 * dl,double2 * d,double2 * du,double2 * dw,double2 * x,int batchCount,void * pBuffer)


#  \ingroup conv_module
# \brief
# \p hipsparseXnnz computes the number of nonzero elements per row or column and the total
# number of nonzero elements in a dense matrix.
# 
# \details
# For example, given the dense matrix:
# \f[
#   \begin{bmatrix}
#   1 & 0 & 0 & 2 \\
#   3 & 4 & 0 & 0 \\
#   5 & 0 & 6 & 7
#   \end{bmatrix}
# \f]
# 
# then using \p dirA == \ref HIPSPARSE_DIRECTION_ROW results in:
# \f[
#   \begin{align}
#   \text{nnzPerRowColumn} &= \begin{bmatrix} 2 & 2 & 3 \end{bmatrix} \\
#   \text{nnzTotalDevHostPtr} &= 7
#   \end{align}
# \f]
# 
# while using \p dirA == \ref HIPSPARSE_DIRECTION_COLUMN results in:
# \f[
#   \begin{align}
#   \text{nnzPerRowColumn} &= \begin{bmatrix} 3 & 1 & 1 & 2 \end{bmatrix} \\
#   \text{nnzTotalDevHostPtr} &= 7
#   \end{align}
# \f]
# 
# The array \p nnzPerRowColumn must be allocated by the user before calling \p hipsparseXnnz and
# has length equal to \p m if \p dirA == \ref HIPSPARSE_DIRECTION_ROW or \p n if
# \p dirA == \ref HIPSPARSE_DIRECTION_COLUMN.
# 
# For a complete code example on its usage, see the example found with hipsparseSdense2csr().
# 
# \note
# As indicated, nnzTotalDevHostPtr can point either to host or device memory. This is controlled
# by setting the pointer mode. See hipsparseSetPointerMode().
# 
# \note
# The routine does support asynchronous execution if the pointer mode is set to device.
cdef hipsparseStatus_t hipsparseSnnz(void * handle,hipsparseDirection_t dirA,int m,int n,void *const descrA,const float * A,int lda,int * nnzPerRowColumn,int * nnzTotalDevHostPtr)



cdef hipsparseStatus_t hipsparseDnnz(void * handle,hipsparseDirection_t dirA,int m,int n,void *const descrA,const double * A,int lda,int * nnzPerRowColumn,int * nnzTotalDevHostPtr)



cdef hipsparseStatus_t hipsparseCnnz(void * handle,hipsparseDirection_t dirA,int m,int n,void *const descrA,float2 * A,int lda,int * nnzPerRowColumn,int * nnzTotalDevHostPtr)



cdef hipsparseStatus_t hipsparseZnnz(void * handle,hipsparseDirection_t dirA,int m,int n,void *const descrA,double2 * A,int lda,int * nnzPerRowColumn,int * nnzTotalDevHostPtr)


#  \ingroup conv_module
# \brief
# \p hipsparseXdense2csr converts the matrix A in dense format into a sparse matrix in CSR format.
# 
# \details
# Given a dense, column ordered, matrix \p A with leading dimension \p ld where \p ld>=m,
# \p hipsparseXdense2csr converts the matrix to a sparse CSR format matrix. All the parameters
# are assumed to have been pre-allocated by the user and the arrays are filled in based on number
# of nonzeros per row, which can be pre-computed with hipsparseXnnz(). The desired index base in
# the output CSR matrix is set in the \ref hipsparseMatDescr_t. See hipsparseSetMatIndexBase().
# 
# As an example, if using index base zero (i.e. the default) and the dense
# matrix:
# 
# \f[
#   \begin{bmatrix}
#   1 & 0 & 0 & 2 \\
#   3 & 4 & 0 & 0 \\
#   5 & 0 & 6 & 7
#   \end{bmatrix}
# \f]
# 
# The conversion results in the CSR arrays:
# 
# \f[
#   \begin{align}
#   \text{csrRowPtr} &= \begin{bmatrix} 0 & 2 & 4 & 7 \end{bmatrix} \\
#   \text{csrColInd} &= \begin{bmatrix} 0 & 3 & 0 & 1 & 0 & 2 & 3 \end{bmatrix} \\
#   \text{csrVal} &= \begin{bmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 \end{bmatrix} \\
#   \end{align}
# \f]
# 
# \note
# It is executed asynchronously with respect to the host and may return control to the
# application on the host before the entire result is ready.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Matrix descriptor
#   hipsparseMatDescr_t descr;
#   hipsparseCreateMatDescr(&descr);
# 
#   // Dense matrix in column order
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   float hdense_A[15] = {1.0f, 0.0f, 6.0f, 2.0f, 4.0f, 0.0f, 0.0f, 5.0f, 0.0f, 3.0f, 0.0f, 7.0f, 0.0f, 0.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;
# 
#   float* ddense_A = nullptr;
#   hipMalloc((void**)&ddense_A, sizeof(float) * m * n);
#   hipMemcpy(ddense_A, hdense_A, sizeof(float) * m * n, hipMemcpyHostToDevice);
# 
#   // Allocate memory for the nnz_per_row_columns array
#   int* dnnz_per_row;
#   hipMalloc((void**)&dnnz_per_row, sizeof(int) * m);
# 
#   int nnz_A;
#   hipsparseSnnz(handle, dir, m, n, descr, ddense_A, m, dnnz_per_row, &nnz_A);
# 
#   // Allocate sparse CSR matrix
#   int* dcsrRowPtr = nullptr;
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz_A);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz_A);
# 
#   hipsparseSdense2csr(handle, m, n, descr, ddense_A, m, dnnz_per_row, dcsrVal, dcsrRowPtr, dcsrColInd);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
#   hipFree(dnnz_per_row);
#   hipFree(ddense_A);
# 
#   hipsparseDestroyMatDescr(descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseSdense2csr(void * handle,int m,int n,void *const descr,const float * A,int ld,const int * nnzPerRow,float * csrVal,int * csrRowPtr,int * csrColInd)



cdef hipsparseStatus_t hipsparseDdense2csr(void * handle,int m,int n,void *const descr,const double * A,int ld,const int * nnzPerRows,double * csrCal,int * csrRowPtr,int * csrColInd)



cdef hipsparseStatus_t hipsparseCdense2csr(void * handle,int m,int n,void *const descr,float2 * A,int ld,const int * nnzPerRow,float2 * csrVal,int * csrRowPtr,int * csrColInd)



cdef hipsparseStatus_t hipsparseZdense2csr(void * handle,int m,int n,void *const descr,double2 * A,int ld,const int * nnzPerRows,double2 * csrVal,int * csrRowPtr,int * csrColInd)


#  \ingroup conv_module
# \brief
# \p hipsparseSpruneDense2csr_bufferSize computes the the size of the user allocated temporary storage buffer
# used when converting a dense matrix to a pruned CSR matrix.
# 
# \details
# Specifically given an input dense column ordered matrix A, with leading dimension \p lda where \p lda>=m,
# the resulting pruned sparse CSR matrix C is computed using:
# \f[
#  |C(i,j)| = A(i, j) \text{  if |A(i, j)| > threshold}
# \f]
# 
# The first step in this conversion is to determine the required user allocated buffer size
# using hipsparseXpruneDense2csr_bufferSize() that will be passed to the subsequent steps of the conversion.
# Once the buffer size has been determined the user must allocate it. This user allocated buffer is then passed
# to hipsparseXpruneDense2csrNnz() and hipsparseXpruneDense2csr() to complete the conversion. The user is
# responsible to then free the buffer once the conversion has been completed.
# 
# See hipsparseSpruneDense2csr() for a full code example.
cdef hipsparseStatus_t hipsparseSpruneDense2csr_bufferSize(void * handle,int m,int n,const float * A,int lda,const float * threshold,void *const descr,const float * csrVal,const int * csrRowPtr,const int * csrColInd,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDpruneDense2csr_bufferSize(void * handle,int m,int n,const double * A,int lda,const double * threshold,void *const descr,const double * csrVal,const int * csrRowPtr,const int * csrColInd,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseSpruneDense2csr_bufferSizeExt(void * handle,int m,int n,const float * A,int lda,const float * threshold,void *const descr,const float * csrVal,const int * csrRowPtr,const int * csrColInd,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDpruneDense2csr_bufferSizeExt(void * handle,int m,int n,const double * A,int lda,const double * threshold,void *const descr,const double * csrVal,const int * csrRowPtr,const int * csrColInd,unsigned long * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief
# \p hipsparseXpruneDense2csrNnz function computes the number of nonzero elements per row and the total
# number of nonzero elements in a dense matrix once the elements less than the (non-negative) threshold are
# pruned from the matrix.
# 
# \details
# Specifically given an input dense column ordered matrix A, with leading dimension \p lda where \p lda>=m,
# the resulting pruned sparse CSR matrix C is computed using:
# \f[
#  |C(i,j)| = A(i, j) \text{  if |A(i, j)| > threshold}
# \f]
# 
# First the user must determine the size of the required temporary buffer using the routine
# \p hipsparseSpruneDense2csr_bufferSize and then allocate it. Next the user allocates \p csrRowPtr with size
# \p m+1. Then the passes both the temporary storage buffer as well as \p csrRowPtr to \p hipsparseXpruneDense2csrNnz
# in order to determine the total number of non-zeros that will exist in the sparse CSR matrix C (after pruning has
# been performed on A) as well as fill the output CSR row pointer array \p csrRowPtr.
# 
# For example, given the dense matrix:
# 
# \f[
#   \begin{bmatrix}
#   6 & 2 & 3 & 7 \\
#   5 & 6 & 7 & 8 \\
#   5 & 4 & 8 & 1
#   \end{bmatrix}
# \f]
# 
# and the \p threshold value 5, the resulting matrix after pruning is:
# 
# \f[
#   \begin{bmatrix}
#   6 & 0 & 0 & 7 \\
#   0 & 6 & 7 & 8 \\
#   0 & 0 & 8 & 0
#   \end{bmatrix}
# \f]
# 
# and corresponding row pointer array and non-zero count:
# 
# \f[
#   \begin{align}
#   \text{csrRowPtr} &= \begin{bmatrix} 0 & 2 & 5 & 6 \end{bmatrix} \\
#   \text{nnzTotalDevHostPtr} &= 6
#   \end{align}
# \f]
# 
# The above example assumes a zero index base for the output CSR matrix. We can set the desired index base
# in the output CSR matrix by setting it in the \ref hipsparseMatDescr_t. See hipsparseSetMatIndexBase().
# 
# For a full code example on how to use this routine, see hipsparseSpruneDense2csr().
# 
# \note
# The routine does support asynchronous execution if the pointer mode is set to device.
cdef hipsparseStatus_t hipsparseSpruneDense2csrNnz(void * handle,int m,int n,const float * A,int lda,const float * threshold,void *const descr,int * csrRowPtr,int * nnzTotalDevHostPtr,void * buffer)



cdef hipsparseStatus_t hipsparseDpruneDense2csrNnz(void * handle,int m,int n,const double * A,int lda,const double * threshold,void *const descr,int * csrRowPtr,int * nnzTotalDevHostPtr,void * buffer)


#  \ingroup conv_module
# \brief
# \p hipsparseXpruneDense2csr converts the matrix A in dense format into a sparse matrix in CSR format
# while pruning values that are less than the (non-negative) threshold. All the parameters are assumed
# to have been pre-allocated by the user.
# 
# \details
# Specifically given an input dense column ordered matrix A, with leading dimension \p lda where \p lda>=m,
# the resulting pruned sparse CSR matrix C is computed using:
# \f[
#  |C(i,j)| = A(i, j) \text{  if |A(i, j)| > threshold}
# \f]
# 
# The user first calls \p hipsparseXpruneDense2csr_bufferSize to determine the size of the required
# user allocate temporary storage buffer. The user then allocates this buffer. Next, the user
# allocates \p csrRowPtr to have \p m+1 elements and then calls hipsparseXpruneDense2csrNnz()
# which fills in the \p csrRowPtr array and stores the number of elements that are larger than the
# pruning \p threshold in \p nnzTotalDevHostPtr. The user then allocates \p csrColInd and \p csrVal to
# have size \p nnzTotalDevHostPtr and completes the conversion by calling hipsparseXpruneDense2csr().
# 
# For example, performing these steps with the dense input matrix A:
# \f[
#   \begin{bmatrix}
#   6 & 2 & 3 & 7 \\
#   5 & 6 & 7 & 8 \\
#   5 & 4 & 8 & 1
#   \end{bmatrix}
# \f]
# 
# and the \p threshold value 5, results in the pruned matrix C:
# 
# \f[
#   \begin{bmatrix}
#   6 & 0 & 0 & 7 \\
#   0 & 6 & 7 & 8 \\
#   0 & 0 & 8 & 0
#   \end{bmatrix}
# \f]
# 
# and corresponding CSR row, column, and values arrays:
# 
# \f[
#   \begin{align}
#   \text{csrRowPtr} &= \begin{bmatrix} 0 & 2 & 5 & 6 \end{bmatrix} \\
#   \text{csrColInd} &= \begin{bmatrix} 0 & 3 & 1 & 2 & 3 & 2 \end{bmatrix} \\
#   \text{csrVal} &= \begin{bmatrix} 6 & 7 & 6 & 7 & 8 & 8 \end{bmatrix} \\
#   \end{align}
# \f]
# 
# \note
# The routine hipsparseXpruneDense2csr() is executed asynchronously with respect to the host and may
# return control to the application on the host before the entire result is ready.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Matrix descriptor
#   hipsparseMatDescr_t descr;
#   hipsparseCreateMatDescr(&descr);
# 
#   // Dense matrix in column order
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   float hdense_A[15] = {1.0f, 0.0f, 6.0f, 2.0f, 4.0f, 0.0f, 0.0f, 5.0f, 0.0f, 3.0f, 0.0f, 7.0f, 0.0f, 0.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int lda       = m;
#   float threshold = 4.0f;
# 
#   float* ddense_A = nullptr;
#   hipMalloc((void**)&ddense_A, sizeof(float) * lda * n);
#   hipMemcpy(ddense_A, hdense_A, sizeof(float) * lda * n, hipMemcpyHostToDevice);
# 
#   // Allocate sparse CSR matrix
#   int* dcsrRowPtr = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
# 
#   size_t bufferSize;
#   hipsparseSpruneDense2csr_bufferSize(handle, m, n, ddense_A, lda, &threshold, descr, nullptr, dcsrRowPtr, nullptr, &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   int nnz_A;
#   hipsparseSpruneDense2csrNnz(handle, m, n, ddense_A, lda, &threshold, descr, dcsrRowPtr, &nnz_A, dbuffer);
# 
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz_A);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz_A);
# 
#   hipsparseSpruneDense2csr(handle, m, n, ddense_A, lda, &threshold, descr, dcsrVal, dcsrRowPtr, dcsrColInd, dbuffer);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
#   hipFree(ddense_A);
#   hipFree(dbuffer);
# 
#   hipsparseDestroyMatDescr(descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseSpruneDense2csr(void * handle,int m,int n,const float * A,int lda,const float * threshold,void *const descr,float * csrVal,const int * csrRowPtr,int * csrColInd,void * buffer)



cdef hipsparseStatus_t hipsparseDpruneDense2csr(void * handle,int m,int n,const double * A,int lda,const double * threshold,void *const descr,double * csrVal,const int * csrRowPtr,int * csrColInd,void * buffer)


#  \ingroup conv_module
# \brief
# \p hipsparseSpruneDense2csrByPercentage_bufferSize computes the size of the user allocated temporary
# storage buffer used when converting a dense matrix to a pruned CSR matrix where the pruning is done
# based on a percantage.
# 
# \details
# When converting and pruning a dense matrix A to a CSR matrix by percentage the
# following steps are performed. First the user calls
# \p hipsparseXpruneDense2csrByPercentage_bufferSize which determines the size of the
# temporary storage buffer. Once determined, this buffer must be allocated by the user.
# Next the user allocates the csrRowPtr array to have \p m+1 elements and calls
# \p hipsparseXpruneDense2csrNnzByPercentage. Finally the user finishes the conversion
# by allocating the csrColInd and csrVal arrays (whose size is determined by the value
# at \p nnzTotalDevHostPtr) and calling \p hipsparseXpruneDense2csrByPercentage.
# 
# The pruning by percentage works by first sorting the absolute values of the dense
# matrix \p A. We then determine a position in this sorted array by
# \f[
#   pos = ceil(m*n*(percentage/100)) - 1 \\
#   pos = min(pos, m*n-1) \\
#   pos = max(pos, 0) \\
#   threshold = sorted_A[pos]
# \f]
# 
# Once we have this threshold we prune values in the dense matrix \p A as in
# \p hipsparseXpruneDense2csr.
# 
# \note
# It is executed asynchronously with respect to the host
# and may return control to the application on the host before the entire result is
# ready.
cdef hipsparseStatus_t hipsparseSpruneDense2csrByPercentage_bufferSize(void * handle,int m,int n,const float * A,int lda,float percentage,void *const descr,const float * csrVal,const int * csrRowPtr,const int * csrColInd,pruneInfo_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDpruneDense2csrByPercentage_bufferSize(void * handle,int m,int n,const double * A,int lda,double percentage,void *const descr,const double * csrVal,const int * csrRowPtr,const int * csrColInd,pruneInfo_t info,unsigned long * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief
# This function computes the size of the user allocated temporary storage buffer used
# when converting and pruning by percentage a dense matrix to a CSR matrix.
# 
# \details
# When converting and pruning a dense matrix A to a CSR matrix by percentage the
# following steps are performed. First the user calls
# \p hipsparseXpruneDense2csrByPercentage_bufferSizeExt which determines the size of the
# temporary storage buffer. Once determined, this buffer must be allocated by the user.
# Next the user allocates the csrRowPtr array to have \p m+1 elements and calls
# \p hipsparseXpruneDense2csrNnzByPercentage. Finally the user finishes the conversion
# by allocating the csrColInd and csrVal arrays (whos size is determined by the value
# at \p nnzTotalDevHostPtr) and calling \p hipsparseXpruneDense2csrByPercentage.
# 
# The pruning by percentage works by first sorting the absolute values of the dense
# matrix \p A. We then determine a position in this sorted array by
# \f[
#   pos = ceil(m*n*(percentage/100)) - 1 \\
#   pos = min(pos, m*n-1) \\
#   pos = max(pos, 0) \\
#   threshold = sorted_A[pos]
# \f]
# 
# Once we have this threshold we prune values in the dense matrix \p A as in
# \p hipsparseXpruneDense2csr.
# 
# \note
# It is executed asynchronously with respect to the host
# and may return control to the application on the host before the entire result is
# ready.
cdef hipsparseStatus_t hipsparseSpruneDense2csrByPercentage_bufferSizeExt(void * handle,int m,int n,const float * A,int lda,float percentage,void *const descr,const float * csrVal,const int * csrRowPtr,const int * csrColInd,pruneInfo_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDpruneDense2csrByPercentage_bufferSizeExt(void * handle,int m,int n,const double * A,int lda,double percentage,void *const descr,const double * csrVal,const int * csrRowPtr,const int * csrColInd,pruneInfo_t info,unsigned long * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief
# This function computes the number of nonzero elements per row and the total number of
# nonzero elements in a dense matrix when converting and pruning by percentage a dense
# matrix to a CSR matrix.
# 
# \details
# When converting and pruning a dense matrix A to a CSR matrix by percentage the
# following steps are performed. First the user calls
# \p hipsparseXpruneDense2csrByPercentage_bufferSize which determines the size of the
# temporary storage buffer. Once determined, this buffer must be allocated by the user.
# Next the user allocates the csrRowPtr array to have \p m+1 elements and calls
# \p hipsparseXpruneDense2csrNnzByPercentage. Finally the user finishes the conversion
# by allocating the csrColInd and csrVal arrays (whos size is determined by the value
# at \p nnzTotalDevHostPtr) and calling \p hipsparseXpruneDense2csrByPercentage.
# 
# The pruning by percentage works by first sorting the absolute values of the dense
# matrix \p A. We then determine a position in this sorted array by
# \f[
#   pos = ceil(m*n*(percentage/100)) - 1 \\
#   pos = min(pos, m*n-1) \\
#   pos = max(pos, 0) \\
#   threshold = sorted_A[pos]
# \f]
# 
# Once we have this threshold we prune values in the dense matrix \p A as in
# \p hipsparseXpruneDense2csr.
# 
# \note
# The routine does support asynchronous execution if the
# pointer mode is set to device.
cdef hipsparseStatus_t hipsparseSpruneDense2csrNnzByPercentage(void * handle,int m,int n,const float * A,int lda,float percentage,void *const descr,int * csrRowPtr,int * nnzTotalDevHostPtr,pruneInfo_t info,void * buffer)



cdef hipsparseStatus_t hipsparseDpruneDense2csrNnzByPercentage(void * handle,int m,int n,const double * A,int lda,double percentage,void *const descr,int * csrRowPtr,int * nnzTotalDevHostPtr,pruneInfo_t info,void * buffer)


#  \ingroup conv_module
# \brief
# This function computes the number of nonzero elements per row and the total number of
# nonzero elements in a dense matrix when converting and pruning by percentage a dense
# matrix to a CSR matrix.
# 
# \details
# When converting and pruning a dense matrix A to a CSR matrix by percentage the
# following steps are performed. First the user calls
# \p hipsparseXpruneDense2csrByPercentage_bufferSize which determines the size of the
# temporary storage buffer. Once determined, this buffer must be allocated by the user.
# Next the user allocates the csrRowPtr array to have \p m+1 elements and calls
# \p hipsparseXpruneDense2csrNnzByPercentage. Finally the user finishes the conversion
# by allocating the csrColInd and csrVal arrays (whos size is determined by the value
# at \p nnzTotalDevHostPtr) and calling \p hipsparseXpruneDense2csrByPercentage.
# 
# The pruning by percentage works by first sorting the absolute values of the dense
# matrix \p A. We then determine a position in this sorted array by
# \f[
#   pos = ceil(m*n*(percentage/100)) - 1 \\
#   pos = min(pos, m*n-1) \\
#   pos = max(pos, 0) \\
#   threshold = sorted_A[pos]
# \f]
# 
# Once we have this threshold we prune values in the dense matrix \p A as in
# \p hipsparseXpruneDense2csr.
# 
# \note
# The routine does support asynchronous execution if the pointer mode is set to device.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Matrix descriptor
#   hipsparseMatDescr_t descr;
#   hipsparseCreateMatDescr(&descr);
# 
#   // Dense matrix in column order
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   float hdense_A[15] = {1.0f, 0.0f, 6.0f, 2.0f, 4.0f, 0.0f, 0.0f, 5.0f, 0.0f, 3.0f, 0.0f, 7.0f, 0.0f, 0.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int lda       = m;
#   float percentage = 70.0f;
# 
#   float* ddense_A = nullptr;
#   hipMalloc((void**)&ddense_A, sizeof(float) * lda * n);
#   hipMemcpy(ddense_A, hdense_A, sizeof(float) * lda * n, hipMemcpyHostToDevice);
# 
#   // Allocate sparse CSR matrix
#   int* dcsrRowPtr = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
# 
#   pruneInfo_t info;
#   hipsparseCreatePruneInfo(&info);
# 
#   size_t bufferSize;
#   hipsparseSpruneDense2csrByPercentage_bufferSize(handle, m, n, ddense_A, lda, percentage, descr, nullptr, dcsrRowPtr, nullptr, info, &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   int nnz_A;
#   hipsparseSpruneDense2csrNnzByPercentage(handle, m, n, ddense_A, lda, percentage, descr, dcsrRowPtr, &nnz_A, info, dbuffer);
# 
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz_A);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz_A);
# 
#   hipsparseSpruneDense2csrByPercentage(handle, m, n, ddense_A, lda, percentage, descr, dcsrVal, dcsrRowPtr, dcsrColInd, info, dbuffer);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
#   hipFree(ddense_A);
#   hipFree(dbuffer);
# 
#   hipsparseDestroyPruneInfo(info);
#   hipsparseDestroyMatDescr(descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseSpruneDense2csrByPercentage(void * handle,int m,int n,const float * A,int lda,float percentage,void *const descr,float * csrVal,const int * csrRowPtr,int * csrColInd,pruneInfo_t info,void * buffer)



cdef hipsparseStatus_t hipsparseDpruneDense2csrByPercentage(void * handle,int m,int n,const double * A,int lda,double percentage,void *const descr,double * csrVal,const int * csrRowPtr,int * csrColInd,pruneInfo_t info,void * buffer)


#  \ingroup conv_module
# \brief
# \p hipsparseXdense2csc converts the matrix A in dense format into a sparse matrix in CSC format.
# 
# \details
# Given a dense, column ordered, matrix \p A with leading dimension \p ld where \p ld>=m,
# \p hipsparseXdense2csc converts the matrix to a sparse CSC format matrix.
# All the parameters are assumed to have been pre-allocated by the user and the arrays
# are filled in based on number of nonzeros per row, which can be pre-computed with hipsparseXnnz().
# We can set the desired index base in the output CSC matrix by setting it in the \ref hipsparseMatDescr_t.
# See hipsparseSetMatIndexBase().
# 
# As an example, if using index base zero (i.e. the default) and the dense
# matrix:
# 
# \f[
#   \begin{bmatrix}
#   1 & 0 & 0 & 2 \\
#   3 & 4 & 0 & 0 \\
#   5 & 0 & 6 & 7
#   \end{bmatrix}
# \f]
# 
# where the \p A values have column ordering with leading dimension \p ld=m:
# \f[
#   \text{A} &= \begin{bmatrix} 1 & 3 & 5 & 0 & 4 & 0 & 0 & 0 & 6 & 2 & 0 & 7 \end{bmatrix} \\
# \f]
# 
# the conversion results in the CSC arrays:
# 
# \f[
#   \begin{align}
#   \text{cscRowInd} &= \begin{bmatrix} 0 & 1 & 2 & 1 & 2 & 0 & 2 \end{bmatrix} \\
#   \text{cscColPtr} &= \begin{bmatrix} 0 & 3 & 4 & 5 & 7 \end{bmatrix} \\
#   \text{cscVal} &= \begin{bmatrix} 1 & 3 & 5 & 4 & 6 & 2 & 7 \end{bmatrix} \\
#   \end{align}
# \f]
# 
# This function works very similar to hipsparseXdense2csr. See hipsparseSdense2csr() for a code example.
# 
# \note
# It is executed asynchronously with respect to the host and may return control to the
# application on the host before the entire result is ready.
cdef hipsparseStatus_t hipsparseSdense2csc(void * handle,int m,int n,void *const descr,const float * A,int ld,const int * nnzPerColumn,float * cscVal,int * cscRowInd,int * cscColPtr)



cdef hipsparseStatus_t hipsparseDdense2csc(void * handle,int m,int n,void *const descr,const double * A,int ld,const int * nnzPerColumn,double * cscVal,int * cscRowInd,int * cscColPtr)



cdef hipsparseStatus_t hipsparseCdense2csc(void * handle,int m,int n,void *const descr,float2 * A,int ld,const int * nnzPerColumn,float2 * cscVal,int * cscRowInd,int * cscColPtr)



cdef hipsparseStatus_t hipsparseZdense2csc(void * handle,int m,int n,void *const descr,double2 * A,int ld,const int * nnzPerColumn,double2 * cscVal,int * cscRowInd,int * cscColPtr)


#  \ingroup conv_module
# \brief
# \p hipsparseXcsr2dense function converts the sparse matrix in CSR format into a dense matrix.
# 
# \details
# Given the input CSR matrix of size \p mxn, the routine writes the matrix to the dense array \p A such
# that \p A has leading dimension \p ld and is column ordered. This means that \p A has size \p ldxn where
# \p ld>=m. All the parameters are assumed to have been pre-allocated by the user. If the input CSR matrix
# has index base of one, it must be set in the \ref hipsparseMatDescr_t. See hipsparseSetMatIndexBase()
# prior to calling \p hipsparseXcsr2dense.
# 
# For example, consider the sparse CSR matrix:
# \f[
#   \begin{align}
#   \text{csrRowPtr} &= \begin{bmatrix} 0 & 2 & 4 & 7 \end{bmatrix} \\
#   \text{csrColInd} &= \begin{bmatrix} 0 & 3 & 0 & 1 & 0 & 2 & 3 \end{bmatrix} \\
#   \text{csrVal} &= \begin{bmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 \end{bmatrix} \\
#   \end{align}
# \f]
# 
# \p hipsparseXcsr2dense is used to convert to the dense matrix:
# \f[
#   \begin{bmatrix}
#   1 & 0 & 0 & 2 \\
#   3 & 4 & 0 & 0 \\
#   5 & 0 & 6 & 7
#   \end{bmatrix}
# \f]
# 
# where the values in the \p A array are column ordered:
# \f[
#   \text{A} &= \begin{bmatrix} 1 & 3 & 5 & 0 & 4 & 0 & 0 & 0 & 6 & 2 & 0 & 7 \end{bmatrix} \\
# \f]
# 
# \note
# It is executed asynchronously with respect to the host and may return control to the application
# on the host before the entire result is ready.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Matrix descriptor
#   hipsparseMatDescr_t descr;
#   hipsparseCreateMatDescr(&descr);
# 
#   // Sparse matrix in CSR format
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcsrRowPtr[4] = {0, 3, 5, 8};
#   int hcsrColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
#   float hcsrVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int ld        = 3;
#   int nnz       = 8;
# 
#   int* dcsrRowPtr = nullptr;
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
# 
#   hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#   float* ddense_A = nullptr;
#   hipMalloc((void**)&ddense_A, sizeof(float) * ld * n);
# 
#   hipsparseScsr2dense(handle, m, n, descr, dcsrVal, dcsrRowPtr, dcsrColInd, ddense_A, ld);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
#   hipFree(ddense_A);
# 
#   hipsparseDestroyMatDescr(descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseScsr2dense(void * handle,int m,int n,void *const descr,const float * csrVal,const int * csrRowPtr,const int * csrColInd,float * A,int ld)



cdef hipsparseStatus_t hipsparseDcsr2dense(void * handle,int m,int n,void *const descr,const double * csrVal,const int * csrRowPtr,const int * csrColInd,double * A,int ld)



cdef hipsparseStatus_t hipsparseCcsr2dense(void * handle,int m,int n,void *const descr,float2 * csrVal,const int * csrRowPtr,const int * csrColInd,float2 * A,int ld)



cdef hipsparseStatus_t hipsparseZcsr2dense(void * handle,int m,int n,void *const descr,double2 * csrVal,const int * csrRowPtr,const int * csrColInd,double2 * A,int ld)


#  \ingroup conv_module
# \brief
# \p hipsparseXcsc2dense function converts the sparse matrix in CSC format into a dense matrix.
# 
# \details
# Given the input CSC matrix of size \p mxn, the routine writes the matrix to the dense array \p A such
# that \p A has leading dimension \p ld and is column ordered. This means that \p A has size \p ldxn where
# \p ld>=m. All the parameters are assumed to have been pre-allocated by the user. If the input CSC matrix
# has index base of one, it must be set in the \ref hipsparseMatDescr_t. See hipsparseSetMatIndexBase()
# prior to calling \p hipsparseXcsc2dense.
# 
# For example, consider the sparse CSC matrix:
# \f[
#   \begin{align}
#   \text{cscRowInd} &= \begin{bmatrix} 0 & 1 & 2 & 1 & 2 & 0 & 2 \end{bmatrix} \\
#   \text{cscColPtr} &= \begin{bmatrix} 0 & 3 & 4 & 5 & 7 \end{bmatrix} \\
#   \text{cscVal} &= \begin{bmatrix} 1 & 3 & 5 & 4 & 6 & 2 & 7 \end{bmatrix} \\
#   \end{align}
# \f]
# 
# \p hipsparseXcsc2dense is used to convert to the dense matrix:
# \f[
#   \begin{bmatrix}
#   1 & 0 & 0 & 2 \\
#   3 & 4 & 0 & 0 \\
#   5 & 0 & 6 & 7
#   \end{bmatrix}
# \f]
# 
# where the values in the \p A array are column ordered:
# \f[
#   \text{A} &= \begin{bmatrix} 1 & 3 & 5 & 0 & 4 & 0 & 0 & 0 & 6 & 2 & 0 & 7 \end{bmatrix} \\
# \f]
# 
# \note
# It is executed asynchronously with respect to the host and may return control to the application
# on the host before the entire result is ready.
cdef hipsparseStatus_t hipsparseScsc2dense(void * handle,int m,int n,void *const descr,const float * cscVal,const int * cscRowInd,const int * cscColPtr,float * A,int ld)



cdef hipsparseStatus_t hipsparseDcsc2dense(void * handle,int m,int n,void *const descr,const double * cscVal,const int * cscRowInd,const int * cscColPtr,double * A,int ld)



cdef hipsparseStatus_t hipsparseCcsc2dense(void * handle,int m,int n,void *const descr,float2 * cscVal,const int * cscRowInd,const int * cscColPtr,float2 * A,int ld)



cdef hipsparseStatus_t hipsparseZcsc2dense(void * handle,int m,int n,void *const descr,double2 * cscVal,const int * cscRowInd,const int * cscColPtr,double2 * A,int ld)


#  \ingroup conv_module
# \brief
# This function computes the number of nonzero block columns per row and the total number of nonzero blocks in a sparse
# BSR matrix given a sparse CSR matrix as input.
# 
# \details
# Consider the matrix:
# \f[
#   \begin{bmatrix}
#   1 & 0 & 0 & 2 \\
#   3 & 4 & 0 & 0 \\
#   5 & 0 & 6 & 7 \\
#   1 & 2 & 3 & 4
#   \end{bmatrix}
# \f]
# 
# stored as a sparse CSR matrix. This function computes both the BSR row pointer array as well as the total number
# of non-zero blocks that results when converting the CSR matrix to the BSR format. Assuming a block dimension of 2,
# the above matrix once converted to BSR format looks like:
# 
# \f[
#  \left[
#   \begin{array}{c | c}
#     \begin{array}{c c}
#      1 & 0 \\
#      3 & 4
#     \end{array} &
#     \begin{array}{c c}
#      0 & 2 \\
#      0 & 0
#     \end{array} \\
#   \hline
#     \begin{array}{c c}
#      5 & 0 \\
#      1 & 2
#     \end{array} &
#     \begin{array}{c c}
#      6 & 7 \\
#      3 & 4
#     \end{array} \\
#  \end{array}
# \right]
# \f]
# 
# and the resulting BSR row pointer array and total non-zero blocks once \p hipsparseXcsr2bsrNnz has been called:
# 
# \f[
#   \begin{align}
#   \text{bsrRowPtrC} &= \begin{bmatrix} 0 & 2 & 4 \end{bmatrix} \\
#   \text{bsrNnzb} &= 4
#   \end{align}
# \f]
# 
# In general, when converting a CSR matrix of size \p m x \p n to a BSR matrix, the resulting BSR matrix will have size
# \p mb x \p nb where \p mb and \p nb equal:
# 
# \f[
#   \begin{align}
#   \text{mb} &= \text{(m - 1) / blockDim + 1} \\
#   \text{nb} &= \text{(n - 1) / blockDim + 1}
#   \end{align}
# \f]
# 
# In particular, it may be the case that \p blockDim does not divide evenly into \p m and/or \p n. In these cases, the
# CSR matrix is expanded in size in order to fit full BSR blocks. For example, using the original CSR matrix and block
# dimension 3 instead of 2, the function \p hipsparseXcsr2bsrNnz computes the BSR row pointer array and total number of
# non-zero blocks for the BSR matrix:
# 
# \f[
#  \left[
#   \begin{array}{c | c}
#     \begin{array}{c c c}
#      1 & 0 & 0 \\
#      3 & 4 & 0 \\
#      5 & 0 & 6
#     \end{array} &
#     \begin{array}{c c c}
#      2 & 0 & 0 \\
#      0 & 0 & 0 \\
#      7 & 0 & 0
#     \end{array} \\
#   \hline
#     \begin{array}{c c c}
#      1 & 2 & 3 \\
#      0 & 0 & 0 \\
#      0 & 0 & 0
#     \end{array} &
#     \begin{array}{c c c}
#      4 & 0 & 0 \\
#      0 & 0 & 0 \\
#      0 & 0 & 0
#     \end{array} \\
#  \end{array}
# \right]
# \f]
# 
# See hipsparseScsr2bsr() for full code example.
# 
# \note
# The routine does support asynchronous execution if the pointer mode is set to device.
cdef hipsparseStatus_t hipsparseXcsr2bsrNnz(void * handle,hipsparseDirection_t dirA,int m,int n,void *const descrA,const int * csrRowPtrA,const int * csrColIndA,int blockDim,void *const descrC,int * bsrRowPtrC,int * bsrNnzb)


#  \ingroup conv_module
# This function is used as the first step in converting a CSR matrix to a compressed CSR matrix.
# 
# \details
# Given a sparse CSR matrix and a non-negative tolerance, this function computes how many entries would be left
# in each row of the matrix if elements less than the tolerance were removed. It also computes the total number
# of remaining elements in the matrix.
# 
# Specifically given an input sparse matrix A in CSR format, the resulting compressed sparse CSR matrix C is
# computed using:
# \f[
#  C(i,j) = A(i, j) \text{  if |A(i, j)| > tol}
# \f]
# 
# The user first allocates \p nnzPerRow with size \p m elements. Then calling \p hipsparseXnnz_compress,
# the function fills in the \p nnzPerRow array and sets the total number of nonzeros found in \p nnzC.
# 
# See hipsparseScsr2csr_compress() for full code example.
# 
# \note
# In the case of complex matrices only the magnitude of the real part of \p tol is used.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Matrix descriptor
#   hipsparseMatDescr_t descr_A;
#   hipsparseCreateMatDescr(&descr_A);
# 
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   float tol = 4.2f;
# 
#   int m     = 3;
#   int n     = 5;
#   int nnz_A = 8;
# 
#   int hcsrRowPtr_A[4] = {0, 3, 5, 8};
#   float hcsrVal_A[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};
# 
#   int* dcsrRowPtr_A = nullptr;
#   float* dcsrVal_A = nullptr;
#   hipMalloc((void**)&dcsrRowPtr_A, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrVal_A, sizeof(float) * nnz_A);
# 
#   hipMemcpy(dcsrRowPtr_A, hcsrRowPtr_A, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrVal_A, hcsrVal_A, sizeof(float) * nnz_A, hipMemcpyHostToDevice);
# 
#   // Allocate memory for the nnz_per_row array
#   int* dnnz_per_row;
#   hipMalloc((void**)&dnnz_per_row, sizeof(int) * m);
# 
#   // Call snnz_compress() which fills in nnz_per_row array and finds the number
#   // of entries that will be in the compressed CSR matrix
#   int nnz_C;
#   hipsparseSnnz_compress(handle, m, descr_A, dcsrVal_A, dcsrRowPtr_A, dnnz_per_row, &nnz_C, tol);
# 
#   hipFree(dcsrRowPtr_A);
#   hipFree(dcsrVal_A);
#   hipFree(dnnz_per_row);
# 
#   hipsparseDestroyMatDescr(descr_A);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseSnnz_compress(void * handle,int m,void *const descrA,const float * csrValA,const int * csrRowPtrA,int * nnzPerRow,int * nnzC,float tol)



cdef hipsparseStatus_t hipsparseDnnz_compress(void * handle,int m,void *const descrA,const double * csrValA,const int * csrRowPtrA,int * nnzPerRow,int * nnzC,double tol)



cdef hipsparseStatus_t hipsparseCnnz_compress(void * handle,int m,void *const descrA,float2 * csrValA,const int * csrRowPtrA,int * nnzPerRow,int * nnzC,float2 tol)



cdef hipsparseStatus_t hipsparseZnnz_compress(void * handle,int m,void *const descrA,double2 * csrValA,const int * csrRowPtrA,int * nnzPerRow,int * nnzC,double2 tol)


#  \ingroup conv_module
# \brief Convert a sparse CSR matrix into a sparse COO matrix
# 
# \details
# \p hipsparseXcsr2coo converts the CSR array containing the row offsets, that point
# to the start of every row, into a COO array of row indices. All arrays are assumed
# to be allocated by the user prior to calling \p hipsparseXcsr2coo.
# 
# For example, given the CSR row pointer array (assuming zero index base):
# \f[
#   \begin{align}
#   \text{csrRowPtr} &= \begin{bmatrix} 0 & 1 & 3 & 4 \end{bmatrix}
#   \end{align}
# \f]
# 
# Calling \p hipsparseXcsr2coo() results in the COO row indices array:
# \f[
#   \begin{align}
#   \text{cooRowInd} &= \begin{bmatrix} 0 & 1 & 1 & 2 \end{bmatrix}
#   \end{align}
# \f]
# 
# \note
# It can also be used to convert a CSC array containing the column offsets into a COO
# array of column indices.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseXcsr2coo(void * handle,const int * csrRowPtr,int nnz,int m,int * cooRowInd,hipsparseIndexBase_t idxBase)


#  \ingroup conv_module
# \brief Convert a sparse CSR matrix into a sparse CSC matrix
# 
# \details
# \p hipsparseXcsr2csc converts a CSR matrix into a CSC matrix. \p hipsparseXcsr2csc
# can also be used to convert a CSC matrix into a CSR matrix. \p copyValues decides
# whether \p cscSortedVal is being filled during conversion (\ref HIPSPARSE_ACTION_NUMERIC)
# or not (\ref HIPSPARSE_ACTION_SYMBOLIC).
# 
# For example given the matrix:
# \f[
#   \begin{bmatrix}
#   1 & 0 & 0 & 2 \\
#   3 & 4 & 0 & 0 \\
#   5 & 0 & 6 & 7
#   \end{bmatrix}
# \f]
# 
# Represented using the sparse CSR format as:
# \f[
#   \begin{align}
#   \text{csrSortedRowPtr} &= \begin{bmatrix} 0 & 2 & 4 & 7 \end{bmatrix}
#   \text{csrSortedColInd} &= \begin{bmatrix} 0 & 3 & 0 & 1 & 0 & 2 & 3 \end{bmatrix}
#   \text{csrSortedVal} &= \begin{bmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 \end{bmatrix}
#   \end{align}
# \f]
# 
# this function converts to sparse CSC format:
# \f[
#   \begin{align}
#   \text{cscSortedRowInd} &= \begin{bmatrix} 0 & 1 & 2 & 1 & 2 & 0 & 2 \end{bmatrix}
#   \text{cscSortedColPtr} &= \begin{bmatrix} 0 & 3 & 4 & 5 & 7 \end{bmatrix}
#   \text{cscSortedVal} &= \begin{bmatrix} 1 & 3 & 5 & 4 & 6 & 2 & 7 \end{bmatrix}
#   \end{align}
# \f]
# 
# The CSC arrays, \p cscSortedRowInd, \p cscSortedColPtr, and \p cscSortedVal must be allocated by the
# user prior to calling \p hipsparseXcsr2csc().
# 
# \note
# The resulting matrix can also be seen as the transpose of the input matrix.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Sparse matrix in CSR format
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcsrRowPtr[4] = {0, 3, 5, 8};
#   int hcsrColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
#   float hcsrVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int nnz       = 8;
#   hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;
#   hipsparseAction_t action = HIPSPARSE_ACTION_NUMERIC;
# 
#   int* dcsrRowPtr = nullptr;
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
# 
#   hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#   int* dcscRowInd = nullptr;
#   int* dcscColPtr = nullptr;
#   float* dcsc_val   = nullptr;
#   hipMalloc((void**)&dcscRowInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcscColPtr, sizeof(int) * (n + 1));
#   hipMalloc((void**)&dcsc_val, sizeof(float) * nnz);
# 
#   hipsparseScsr2csc(handle, m, n, nnz, dcsrVal, dcsrRowPtr, dcsrColInd, dcsc_val, dcscRowInd, dcscColPtr, action, base);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
# 
#   hipFree(dcscRowInd);
#   hipFree(dcscColPtr);
#   hipFree(dcsc_val);
# 
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseScsr2csc(void * handle,int m,int n,int nnz,const float * csrSortedVal,const int * csrSortedRowPtr,const int * csrSortedColInd,float * cscSortedVal,int * cscSortedRowInd,int * cscSortedColPtr,hipsparseAction_t copyValues,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseDcsr2csc(void * handle,int m,int n,int nnz,const double * csrSortedVal,const int * csrSortedRowPtr,const int * csrSortedColInd,double * cscSortedVal,int * cscSortedRowInd,int * cscSortedColPtr,hipsparseAction_t copyValues,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseCcsr2csc(void * handle,int m,int n,int nnz,float2 * csrSortedVal,const int * csrSortedRowPtr,const int * csrSortedColInd,float2 * cscSortedVal,int * cscSortedRowInd,int * cscSortedColPtr,hipsparseAction_t copyValues,hipsparseIndexBase_t idxBase)



cdef hipsparseStatus_t hipsparseZcsr2csc(void * handle,int m,int n,int nnz,double2 * csrSortedVal,const int * csrSortedRowPtr,const int * csrSortedColInd,double2 * cscSortedVal,int * cscSortedRowInd,int * cscSortedColPtr,hipsparseAction_t copyValues,hipsparseIndexBase_t idxBase)


cdef extern from "hipsparse/hipsparse.h":

    ctypedef enum hipsparseCsr2CscAlg_t:
        HIPSPARSE_CSR2CSC_ALG_DEFAULT
        HIPSPARSE_CSR2CSC_ALG1
        HIPSPARSE_CSR2CSC_ALG2

#  \ingroup conv_module
# \brief This function computes the size of the user allocated temporary storage buffer used
# when converting a sparse CSR matrix into a sparse CSC matrix.
# 
# \details
# \p hipsparseCsr2cscEx2_bufferSize calculates the required user allocated temporary buffer needed
# by \p hipsparseCsr2cscEx2 to convert a CSR matrix into a CSC matrix. \p hipsparseCsr2cscEx2
# can also be used to convert a CSC matrix into a CSR matrix. \p copyValues decides
# whether \p cscVal is being filled during conversion (\ref HIPSPARSE_ACTION_NUMERIC)
# or not (\ref HIPSPARSE_ACTION_SYMBOLIC).
# 
# \note
# The resulting matrix can also be seen as the transpose of the input matrix.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseCsr2cscEx2_bufferSize(void * handle,int m,int n,int nnz,const void * csrVal,const int * csrRowPtr,const int * csrColInd,void * cscVal,int * cscColPtr,int * cscRowInd,hipDataType valType,hipsparseAction_t copyValues,hipsparseIndexBase_t idxBase,hipsparseCsr2CscAlg_t alg,unsigned long * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief Convert a sparse CSR matrix into a sparse CSC matrix
# 
# \details
# \p hipsparseCsr2cscEx2 converts a CSR matrix into a CSC matrix. \p hipsparseCsr2cscEx2
# can also be used to convert a CSC matrix into a CSR matrix. \p copyValues decides
# whether \p cscVal is being filled during conversion (\ref HIPSPARSE_ACTION_NUMERIC)
# or not (\ref HIPSPARSE_ACTION_SYMBOLIC).
# 
# \note
# The resulting matrix can also be seen as the transpose of the input matrix.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Sparse matrix in CSR format
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcsrRowPtr[4] = {0, 3, 5, 8};
#   int hcsrColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
#   float hcsrVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int nnz       = 8;
#   hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;
#   hipsparseAction_t action = HIPSPARSE_ACTION_NUMERIC;
#   hipsparseCsr2CscAlg_t alg = HIPSPARSE_CSR2CSC_ALG_DEFAULT;
# 
#   int* dcsrRowPtr = nullptr;
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
# 
#   hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#   int* dcscRowInd = nullptr;
#   int* dcscColPtr = nullptr;
#   float* dcsc_val   = nullptr;
#   hipMalloc((void**)&dcscRowInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcscColPtr, sizeof(int) * (n + 1));
#   hipMalloc((void**)&dcsc_val, sizeof(float) * nnz);
# 
#   size_t bufferSize;
#   hipsparseCsr2cscEx2_bufferSize(handle,
#                                  m,
#                                  n,
#                                  nnz,
#                                  dcsrVal,
#                                  dcsrRowPtr,
#                                  dcsrColInd,
#                                  dcsc_val,
#                                  dcscColPtr,
#                                  dcscRowInd,
#                                  HIP_R_32F,
#                                  action,
#                                  base,
#                                  alg,
#                                  &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   hipsparseCsr2cscEx2(handle,
#                       m,
#                       n,
#                       nnz,
#                       dcsrVal,
#                       dcsrRowPtr,
#                       dcsrColInd,
#                       dcsc_val,
#                       dcscColPtr,
#                       dcscRowInd,
#                       HIP_R_32F,
#                       action,
#                       base,
#                       alg,
#                       dbuffer);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
# 
#   hipFree(dcscRowInd);
#   hipFree(dcscColPtr);
#   hipFree(dcsc_val);
# 
#   hipFree(dbuffer);
# 
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseCsr2cscEx2(void * handle,int m,int n,int nnz,const void * csrVal,const int * csrRowPtr,const int * csrColInd,void * cscVal,int * cscColPtr,int * cscRowInd,hipDataType valType,hipsparseAction_t copyValues,hipsparseIndexBase_t idxBase,hipsparseCsr2CscAlg_t alg,void * buffer)


#  \ingroup conv_module
# \brief Convert a sparse CSR matrix into a sparse HYB matrix
# 
# \details
# \p hipsparseXcsr2hyb converts a CSR matrix into a HYB matrix. It is assumed
# that \p hyb has been initialized with hipsparseCreateHybMat().
# 
# \note
# This function requires a significant amount of storage for the HYB matrix,
# depending on the matrix structure.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t descr;
#   hipsparseCreateMatDescr(&descr);
# 
#   // Sparse matrix in CSR format
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcsrRowPtr[4] = {0, 3, 5, 8};
#   int hcsrColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
#   float hcsrVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int nnz       = 8;
#   int userEllWidth = 2;
#   hipsparseHybPartition_t partitionType = HIPSPARSE_HYB_PARTITION_AUTO;
# 
#   int* dcsrRowPtr = nullptr;
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
# 
#   hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#   hipsparseHybMat_t hyb;
#   hipsparseCreateHybMat(&hyb);
# 
#   hipsparseScsr2hyb(handle, m, n, descr, dcsrVal, dcsrRowPtr, dcsrColInd, hyb, userEllWidth, partitionType);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
# 
#   hipsparseDestroyHybMat(hyb);
#   hipsparseDestroyMatDescr(descr);
# 
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseScsr2hyb(void * handle,int m,int n,void *const descrA,const float * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,void * hybA,int userEllWidth,hipsparseHybPartition_t partitionType)



cdef hipsparseStatus_t hipsparseDcsr2hyb(void * handle,int m,int n,void *const descrA,const double * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,void * hybA,int userEllWidth,hipsparseHybPartition_t partitionType)



cdef hipsparseStatus_t hipsparseCcsr2hyb(void * handle,int m,int n,void *const descrA,float2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,void * hybA,int userEllWidth,hipsparseHybPartition_t partitionType)



cdef hipsparseStatus_t hipsparseZcsr2hyb(void * handle,int m,int n,void *const descrA,double2 * csrSortedValA,const int * csrSortedRowPtrA,const int * csrSortedColIndA,void * hybA,int userEllWidth,hipsparseHybPartition_t partitionType)


#  \ingroup conv_module
# \brief Convert a sparse GEBSR matrix into a sparse GEBSC matrix
# 
# \details
# \p hipsparseXgebsr2gebsc_bufferSize returns the size of the temporary storage buffer
# required by hipsparseXgebsr2gebsc() and is the first step in converting a sparse matrix
# in GEBSR format to a sparse matrix in GEBSC format. Once the size of the temporary storage
# buffer has been determined, it must be allocated by the user.
# 
# See hipsparseSgebsr2gebsc() for a complete code example.
cdef hipsparseStatus_t hipsparseSgebsr2gebsc_bufferSize(void * handle,int mb,int nb,int nnzb,const float * bsrVal,const int * bsrRowPtr,const int * bsrColInd,int rowBlockDim,int colBlockDim,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDgebsr2gebsc_bufferSize(void * handle,int mb,int nb,int nnzb,const double * bsrVal,const int * bsrRowPtr,const int * bsrColInd,int rowBlockDim,int colBlockDim,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCgebsr2gebsc_bufferSize(void * handle,int mb,int nb,int nnzb,float2 * bsrVal,const int * bsrRowPtr,const int * bsrColInd,int rowBlockDim,int colBlockDim,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZgebsr2gebsc_bufferSize(void * handle,int mb,int nb,int nnzb,double2 * bsrVal,const int * bsrRowPtr,const int * bsrColInd,int rowBlockDim,int colBlockDim,unsigned long * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief Convert a sparse GEBSR matrix into a sparse GEBSC matrix
# 
# \details
# \p hipsparseXgebsr2gebsc converts a GEBSR matrix into a GEBSC matrix. \p hipsparseXgebsr2gebsc
# can also be used to convert a GEBSC matrix into a GEBSR matrix. \p copyValues decides
# whether \p bscVal is being filled during conversion (\ref HIPSPARSE_ACTION_NUMERIC)
# or not (\ref HIPSPARSE_ACTION_SYMBOLIC).
# 
# \p hipsparseXgebsr2gebsc requires extra temporary storage buffer that has to be allocated
# by the user. Storage buffer size can be determined by hipsparseXgebsr2gebsc_bufferSize().
# 
# For example, given the GEBSR matrix:
# \f[
#  \left[
#   \begin{array}{c | c}
#     \begin{array}{c c}
#      1 & 2 \\
#      3 & 4 \\
#      6 & 0
#     \end{array} &
#     \begin{array}{c c}
#      0 & 2 \\
#      0 & 0 \\
#      3 & 4
#     \end{array} \\
#   \hline
#     \begin{array}{c c}
#      5 & 0 \\
#      1 & 2 \\
#      3 & 4
#     \end{array} &
#     \begin{array}{c c}
#      6 & 7 \\
#      3 & 4 \\
#      3 & 4
#     \end{array} \\
#  \end{array}
# \right]
# \f]
# 
# represented with the arrays:
# \f[
#   \begin{align}
#   \text{bsrRowPtr} &= \begin{bmatrix} 0 & 2 & 4 \end{bmatrix} \\
#   \text{bsrColInd} &= \begin{bmatrix} 0 & 1 & 0 & 1 \end{bmatrix} \\
#   \text{bsrVal} &= \begin{bmatrix} 1 & 2 & 3 & 4 & 6 & 0 & 0 & 2 & 0 & 0 & 3 & 4 & 5 & 0 & 1 & 2 & 3 & 4 & 6 & 7 & 3 & 4 & 3 & 4 \end{bmatrix}
#   \end{align}
# \f]
# 
# this function converts the matrix to GEBSC format:
# \f[
#   \begin{align}
#   \text{bscRowInd} &= \begin{bmatrix} 0 & 1 & 0 & 1 \end{bmatrix} \\
#   \text{bscColPtr} &= \begin{bmatrix} 0 & 2 & 4 \end{bmatrix} \\
#   \text{bscVal} &= \begin{bmatrix} 1 & 2 & 3 & 4 & 6 & 0 & 5 & 0 & 1 & 2 & 3 & 4 & 0 & 2 & 0 & 0 & 3 & 4 & 6 & 7 & 3 & 4 & 3 & 4 \end{bmatrix}
#   \end{align}
# \f]
# 
# The GEBSC arrays, \p bscRowInd, \p bscColPtr, and \p bscVal must be allocated by the user prior
# to calling \p hipsparseXgebsr2gebsc(). The \p bscRowInd array has size \p nnzb, the \p bscColPtr
# array has size \p nb+1, and the \p bscVal array has size \p nnzb*rowBlockDim*colBlockDim.
# 
# \note
# The resulting matrix can also be seen as the transpose of the input matrix.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Sparse matrix in BSR format
#   //     1 2 | 0 3 | 0 0
#   //     0 4 | 5 0 | 0 1
#   // A = 6 0 | 0 7 | 8 0
#   //     ---------------
#   //     0 0 | 3 0 | 2 2
#   //     1 0 | 0 0 | 4 3
#   //     7 2 | 0 0 | 1 4
#   int hbsrRowPtr[3] = {0, 3, 6};
#   int hbsrColInd[6] = {0, 1, 2, 0, 1, 2};
#   float hbsrVal[36]  = {1.0f, 2.0f, 0.0f, 4.0f, 6.0f, 0.0f,
#                          0.0f, 3.0f, 5.0f, 0.0f, 0.0f, 7.0f,
#                          0.0f, 0.0f, 0.0f, 1.0f, 8.0f, 0.0f,
#                          0.0f, 0.0f, 1.0f, 0.0f, 7.0f, 2.0f,
#                          3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f,
#                          2.0f, 2.0f, 4.0f, 3.0f, 1.0f, 4.0f};
# 
#   int m           = 6;
#   int n           = 6;
#   int rowBlockDim = 3;
#   int colBlockDim = 2;
#   int nnzb        = 6;
#   hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;
#   hipsparseAction_t    action = HIPSPARSE_ACTION_NUMERIC;
#   hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;
# 
#   int mb = (m + rowBlockDim - 1) / rowBlockDim;
#   int nb = (n + colBlockDim - 1) / colBlockDim;
# 
#   int* dbsrRowPtr = nullptr;
#   int* dbsrColInd = nullptr;
#   float* dbsrVal = nullptr;
#   hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
#   hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
#   hipMalloc((void**)&dbsrVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb);
# 
#   hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
#   hipMemcpy(dbsrVal, hbsrVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb, hipMemcpyHostToDevice);
# 
#   int* dbscRowInd = nullptr;
#   int* dbscColPtr = nullptr;
#   float* dbscVal = nullptr;
#   hipMalloc((void**)&dbscRowInd, sizeof(int) * nnzb);
#   hipMalloc((void**)&dbscColPtr, sizeof(int) * (nb + 1));
#   hipMalloc((void**)&dbscVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb);
# 
#   size_t bufferSize;
#   hipsparseSgebsr2gebsc_bufferSize(handle,
#                                    mb,
#                                    nb,
#                                    nnzb,
#                                    dbsrVal,
#                                    dbsrRowPtr,
#                                    dbsrColInd,
#                                    rowBlockDim,
#                                    colBlockDim,
#                                    &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   hipsparseSgebsr2gebsc(handle,
#                         mb,
#                         nb,
#                         nnzb,
#                         dbsrVal,
#                         dbsrRowPtr,
#                         dbsrColInd,
#                         rowBlockDim,
#                         colBlockDim,
#                         dbscVal,
#                         dbscRowInd,
#                         dbscColPtr,
#                         action,
#                         base,
#                         dbuffer);
# 
#   hipFree(dbsrRowPtr);
#   hipFree(dbsrColInd);
#   hipFree(dbsrVal);
# 
#   hipFree(dbscRowInd);
#   hipFree(dbscColPtr);
#   hipFree(dbscVal);
# 
#   hipFree(dbuffer);
# 
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseSgebsr2gebsc(void * handle,int mb,int nb,int nnzb,const float * bsrVal,const int * bsrRowPtr,const int * bsrColInd,int rowBlockDim,int colBlockDim,float * bscVal,int * bscRowInd,int * bscColPtr,hipsparseAction_t copyValues,hipsparseIndexBase_t idxBase,void * temp_buffer)



cdef hipsparseStatus_t hipsparseDgebsr2gebsc(void * handle,int mb,int nb,int nnzb,const double * bsrVal,const int * bsrRowPtr,const int * bsrColInd,int rowBlockDim,int colBlockDim,double * bscVal,int * bscRowInd,int * bscColPtr,hipsparseAction_t copyValues,hipsparseIndexBase_t idxBase,void * temp_buffer)



cdef hipsparseStatus_t hipsparseCgebsr2gebsc(void * handle,int mb,int nb,int nnzb,float2 * bsrVal,const int * bsrRowPtr,const int * bsrColInd,int rowBlockDim,int colBlockDim,float2 * bscVal,int * bscRowInd,int * bscColPtr,hipsparseAction_t copyValues,hipsparseIndexBase_t idxBase,void * temp_buffer)



cdef hipsparseStatus_t hipsparseZgebsr2gebsc(void * handle,int mb,int nb,int nnzb,double2 * bsrVal,const int * bsrRowPtr,const int * bsrColInd,int rowBlockDim,int colBlockDim,double2 * bscVal,int * bscRowInd,int * bscColPtr,hipsparseAction_t copyValues,hipsparseIndexBase_t idxBase,void * temp_buffer)


#  \ingroup conv_module
# \brief Convert a sparse CSR matrix into a sparse GEBSR matrix
# 
# \details
# \p hipsparseXcsr2gebsr_bufferSize returns the size of the temporary buffer that
# is required by \p hipsparseXcsr2gebcsrNnz and \p hipsparseXcsr2gebcsr. Once the
# temporary buffer size has been determined, it must be allocated by the user prior
# to calling \p hipsparseXcsr2gebcsrNnz and \p hipsparseXcsr2gebcsr.
# 
# See hipsparseScsr2gebsr() for complete code example.
# 
# \note
# The routine does support asynchronous execution if the pointer mode is set to device.
cdef hipsparseStatus_t hipsparseScsr2gebsr_bufferSize(void * handle,hipsparseDirection_t dir,int m,int n,void *const csr_descr,const float * csrVal,const int * csrRowPtr,const int * csrColInd,int rowBlockDim,int colBlockDim,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsr2gebsr_bufferSize(void * handle,hipsparseDirection_t dir,int m,int n,void *const csr_descr,const double * csrVal,const int * csrRowPtr,const int * csrColInd,int rowBlockDim,int colBlockDim,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsr2gebsr_bufferSize(void * handle,hipsparseDirection_t dir,int m,int n,void *const csr_descr,float2 * csrVal,const int * csrRowPtr,const int * csrColInd,int rowBlockDim,int colBlockDim,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsr2gebsr_bufferSize(void * handle,hipsparseDirection_t dir,int m,int n,void *const csr_descr,double2 * csrVal,const int * csrRowPtr,const int * csrColInd,int rowBlockDim,int colBlockDim,unsigned long * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief
# This function computes the number of nonzero block columns per row and the total number of nonzero blocks in a sparse
# GEBSR matrix given a sparse CSR matrix as input.
# 
# \details
# This is the second step in conveting a CSR matrix to a GEBSR matrix. The user must first call
# \p hipsparseXcsr2gebsr_bufferSize to determine the size of the required temporary storage buffer. The user then
# allocates this buffer as well as the \p bsrRowPtr array ( size \p mb+1 ) and passes both to
# \p hipsparseXcsr2gebsrNnz(). This second step then computes the number of nonzero block columns per row and the
# total number of nonzero blocks.
# 
# In general, when converting a CSR matrix of size \p m x \p n to a GEBSR matrix, the resulting GEBSR matrix will have size
# \p mb x \p nb where \p mb and \p nb equal:
# \f[
#   \begin{align}
#   \text{mb} &= \text{(m - 1) / rowBlockDim + 1} \\
#   \text{nb} &= \text{(n - 1) / colBlockDim + 1}
#   \end{align}
# \f]
# 
# For example given a matrix:
# \f[
#   \begin{bmatrix}
#   1 & 0 & 0 & 2 & 4 & 0 \\
#   3 & 4 & 0 & 0 & 5 & 1 \\
#   5 & 0 & 6 & 7 & 6 & 2
#   \end{bmatrix}
# \f]
# 
# represented in CSR format with the arrays:
# \f[
#   \begin{align}
#   \text{csrRowPtr} &= \begin{bmatrix} 0 & 3 & 7 & 12 \end{bmatrix} \\
#   \text{csrColInd} &= \begin{bmatrix} 0 & 3 & 4 & 0 & 1 & 4 & 5 & 0 & 2 & 3 & 4 & 5 \end{bmatrix} \\
#   \text{csrVal} &= \begin{bmatrix} 1 & 2 & 4 & 3 & 4 & 5 & 1 & 5 & 6 & 7 & 6 & 2 \end{bmatrix}
#   \end{align}
# \f]
# 
# the \p bsrRowPtr array and total nonzero block count will be filled with:
# \f[
#   \begin{align}
#   \text{bsrRowPtr} &= \begin{bmatrix} 0 & 3 \end{bmatrix} \\
#   \text{*bsrNnzDevhost} &= 3
#   \end{align}
# \f]
# 
# after calling \p hipsparseXcsr2gebsrNnz with \p rowBlockDim=3 and \p colBlockDim=2.
# 
# \note
# As indicated, bsrNnzDevhost can point either to host or device memory. This is controlled
# by setting the pointer mode. See hipsparseSetPointerMode().
# 
# It may be the case that \p rowBlockDim does not divide evenly into \p m and/or that \p colBlockDim does not divide
# evenly into \p n. In these cases, the CSR matrix is expanded in size in order to fit full GEBSR blocks. For example,
# using the original CSR matrix but this time with \p rowBlockDim=2 and \p colBlockDim=3, the function
# \p hipsparseXcsr2gebsrNnz computes the GEBSR row pointer array and total number of non-zero blocks for the GEBSR matrix:
# 
# \f[
#  \left[
#   \begin{array}{c | c}
#     \begin{array}{c c c}
#      1 & 0 & 0 \\
#      3 & 4 & 0
#     \end{array} &
#     \begin{array}{c c c}
#      2 & 4 & 0 \\
#      0 & 5 & 1
#     \end{array} \\
#   \hline
#     \begin{array}{c c c}
#      5 & 0 & 6 \\
#      0 & 0 & 0
#     \end{array} &
#     \begin{array}{c c c}
#      7 & 6 & 2 \\
#      0 & 0 & 0
#     \end{array}
#  \end{array}
# \right]
# \f]
# 
# See hipsparseScsr2gebsr() for full code example.
cdef hipsparseStatus_t hipsparseXcsr2gebsrNnz(void * handle,hipsparseDirection_t dir,int m,int n,void *const csr_descr,const int * csrRowPtr,const int * csrColInd,void *const bsr_descr,int * bsrRowPtr,int rowBlockDim,int colBlockDim,int * bsrNnzDevhost,void * pbuffer)


#  \ingroup conv_module
# \brief Convert a sparse CSR matrix into a sparse GEBSR matrix
# 
# \details
# \p hipsparseXcsr2gebsr converts a CSR matrix into a GEBSR matrix. It is assumed,
# that \p bsrVal, \p bsrColInd and \p bsrRowPtr are allocated. Allocation size
# for \p bsrRowPtr is computed as \p mb+1 where \p mb is the number of block rows in
# the GEBSR matrix. The number of nonzero blocks in the resulting GEBSR matrix
# is computed using \p hipsparseXcsr2gebsrNnz which also fills in \p bsrRowPtr.
# 
# In more detail, \p hipsparseXcsr2gebsr is the third and final step on the conversion from CSR to GEBSR.
# The user first determines the size of the required user allocated temporary storage buffer using
# \p hipsparseXcsr2gebsr_bufferSize. The user then allocates this buffer as well as the row pointer array
# \p bsrRowPtr with size \p mb+1, where \p mb is the number of block rows in the GEBSR matrix and \p nb is
# the number of block columns in GEBSR matrix:
# 
# \f[
#   \begin{align}
#   \text{mb} &= \text{(m - 1) / rowBlockDim + 1} \\
#   \text{nb} &= \text{(n - 1) / colBlockDim + 1}
#   \end{align}
# \f]
# 
# Both the temporary storage buffer and the GEBSR row pointer array are then passed to \p hipsparseXcsr2gebsrNnz
# which fills the GEBSR row pointer array \p bsrRowPtr and also computes the number of nonzero blocks,
# \p bsr_nnz, that will exist in the GEBSR matrix. The user then allocates both the GEBSR column indices array
# \p bsrColInd with size \p bsr_nnz as well as the GEBSR values array \p bsrVal with size
# \p bsr_nnz*rowBlockDim*colBlockDim. Finally, with all arrays allocated, the conversion is completed by calling
# \p hipsparseXcsr2gebsr.
# 
# For example, assuming the matrix:
# \f[
#   \begin{bmatrix}
#   1 & 0 & 0 & 2 & 4 & 0 \\
#   3 & 4 & 0 & 0 & 5 & 1 \\
#   5 & 0 & 6 & 7 & 6 & 2
#   \end{bmatrix}
# \f]
# 
# represented in CSR format with the arrays:
# \f[
#   \begin{align}
#   \text{csrRowPtr} &= \begin{bmatrix} 0 & 3 & 7 & 12 \end{bmatrix} \\
#   \text{csrColInd} &= \begin{bmatrix} 0 & 3 & 4 & 0 & 1 & 4 & 5 & 0 & 2 & 3 & 4 & 5 \end{bmatrix} \\
#   \text{csrVal} &= \begin{bmatrix} 1 & 2 & 4 & 3 & 4 & 5 & 1 & 5 & 6 & 7 & 6 & 2 \end{bmatrix}
#   \end{align}
# \f]
# 
# then using \p rowBlockDim=3 and \p colBlockDim=2, the final GEBSR matrix is:
# \f[
#  \left[
#   \begin{array}{c | c}
#     \begin{array}{c c}
#      1 & 0 \\
#      3 & 4 \\
#      3 & 0
#     \end{array} &
#     \begin{array}{c c}
#      0 & 2 \\
#      0 & 0 \\
#      6 & 7
#     \end{array} &
#     \begin{array}{c c}
#      4 & 0 \\
#      5 & 1 \\
#      6 & 2
#     \end{array}
#  \end{array}
# \right]
# \f]
# 
# and is represented with the arrays:
# \f[
#   \begin{align}
#   \text{bsrRowPtr} &= \begin{bmatrix} 0 & 3 \end{bmatrix} \\
#   \text{bsrColInd} &= \begin{bmatrix} 0 & 1 & 2 \end{bmatrix} \\
#   \text{bsrVal} &= \begin{bmatrix} 1 & 0 & 3 & 4 & 3 & 0 & 0 & 2 & 0 & 0 & 6 & 7 & 4 & 0 & 5 & 1 & 6 & 2 \end{bmatrix}
#   \end{align}
# \f]
# 
# The above example assumes that the blocks are row ordered. If instead the blocks are column ordered, the \p bsrVal arrays
# becomes:
# \f[
#   \begin{align}
#   \text{bsrVal} &= \begin{bmatrix} 1 & 3 & 3 & 0 & 4 & 0 & 0 & 0 & 6 & 2 & 0 & 7 & 4 & 5 & 6 & 0 & 1 & 2 \end{bmatrix}
#   \end{align}
# \f]
# 
# The block order direction is determined by \p dir.
# 
# It may be the case that \p rowBlockDim does not divide evenly into \p m and/or that \p colBlockDim does not divide
# evenly into \p n. In these cases, the CSR matrix is expanded in size in order to fit full GEBSR blocks. For example,
# using the original CSR matrix but this time with \p rowBlockDim=2 and \p colBlockDim=3, the resulting GEBSR matrix
# would looks like:
# 
# \f[
#  \left[
#   \begin{array}{c | c}
#     \begin{array}{c c c}
#      1 & 0 & 0 \\
#      3 & 4 & 0
#     \end{array} &
#     \begin{array}{c c c}
#      2 & 4 & 0 \\
#      0 & 5 & 1
#     \end{array} \\
#   \hline
#     \begin{array}{c c c}
#      5 & 0 & 6 \\
#      0 & 0 & 0
#     \end{array} &
#     \begin{array}{c c c}
#      7 & 6 & 2 \\
#      0 & 0 & 0
#     \end{array}
#  \end{array}
# \right]
# \f]
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t csr_descr;
#   hipsparseCreateMatDescr(&csr_descr);
# 
#   hipsparseMatDescr_t bsr_descr;
#   hipsparseCreateMatDescr(&bsr_descr);
# 
#   // Sparse matrix in CSR format
#   //     1 2 0 3 0 0
#   //     0 4 5 0 0 1
#   // A = 6 0 0 7 8 0
#   //     0 0 3 0 2 2
#   //     1 0 0 0 4 3
#   //     7 2 0 0 1 4
#   int hcsrRowPtr[7] = {0, 3, 6, 9, 12, 15, 19};
#   int hcsrColInd[19] = {0, 1, 3, 1, 2, 5, 0, 3, 4, 2, 4, 5, 0, 4, 5, 0, 1, 4, 5};
#   float hcsrVal[19]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 1.0f, 6.0f, 7.0f, 8.0f, 3.0f, 2.0f, 2.0f,
#                          1.0f, 4.0f, 3.0f, 7.0f, 2.0f, 1.0f, 4.0f};
# 
#   int m           = 6;
#   int n           = 6;
#   int nnz         = 19;
#   int rowBlockDim = 3;
#   int colBlockDim = 2;
#   hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;
#   hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;
# 
#   int mb = (m + rowBlockDim - 1) / rowBlockDim;
#   int nb = (n + colBlockDim - 1) / colBlockDim;
# 
#   int* dcsrRowPtr = nullptr;
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
# 
#   hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#   int* dbsrRowPtr = nullptr;
#   hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
# 
#   size_t bufferSize;
#   hipsparseScsr2gebsr_bufferSize(handle,
#                                  dir,
#                                  m,
#                                  n,
#                                  csr_descr,
#                                  dcsrVal,
#                                  dcsrRowPtr,
#                                  dcsrColInd,
#                                  rowBlockDim,
#                                  colBlockDim,
#                                  &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   int nnzb;
#   hipsparseXcsr2gebsrNnz(handle,
#                          dir,
#                          m,
#                          n,
#                          csr_descr,
#                          dcsrRowPtr,
#                          dcsrColInd,
#                          bsr_descr,
#                          dbsrRowPtr,
#                          rowBlockDim,
#                          colBlockDim,
#                          &nnzb,
#                          dbuffer);
# 
#   int* dbsrColInd = nullptr;
#   float* dbsrVal = nullptr;
#   hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
#   hipMalloc((void**)&dbsrVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb);
# 
#   hipsparseScsr2gebsr(handle,
#                       dir,
#                       m,
#                       n,
#                       csr_descr,
#                       dcsrVal,
#                       dcsrRowPtr,
#                       dcsrColInd,
#                       bsr_descr,
#                       dbsrVal,
#                       dbsrRowPtr,
#                       dbsrColInd,
#                       rowBlockDim,
#                       colBlockDim,
#                       dbuffer);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
# 
#   hipFree(dbsrRowPtr);
#   hipFree(dbsrColInd);
#   hipFree(dbsrVal);
# 
#   hipFree(dbuffer);
# 
#   hipsparseDestroyMatDescr(csr_descr);
#   hipsparseDestroyMatDescr(bsr_descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseScsr2gebsr(void * handle,hipsparseDirection_t dir,int m,int n,void *const csr_descr,const float * csrVal,const int * csrRowPtr,const int * csrColInd,void *const bsr_descr,float * bsrVal,int * bsrRowPtr,int * bsrColInd,int rowBlockDim,int colBlockDim,void * pbuffer)



cdef hipsparseStatus_t hipsparseDcsr2gebsr(void * handle,hipsparseDirection_t dir,int m,int n,void *const csr_descr,const double * csrVal,const int * csrRowPtr,const int * csrColInd,void *const bsr_descr,double * bsrVal,int * bsrRowPtr,int * bsrColInd,int rowBlockDim,int colBlockDim,void * pbuffer)



cdef hipsparseStatus_t hipsparseCcsr2gebsr(void * handle,hipsparseDirection_t dir,int m,int n,void *const csr_descr,float2 * csrVal,const int * csrRowPtr,const int * csrColInd,void *const bsr_descr,float2 * bsrVal,int * bsrRowPtr,int * bsrColInd,int rowBlockDim,int colBlockDim,void * pbuffer)



cdef hipsparseStatus_t hipsparseZcsr2gebsr(void * handle,hipsparseDirection_t dir,int m,int n,void *const csr_descr,double2 * csrVal,const int * csrRowPtr,const int * csrColInd,void *const bsr_descr,double2 * bsrVal,int * bsrRowPtr,int * bsrColInd,int rowBlockDim,int colBlockDim,void * pbuffer)


#  \ingroup conv_module
# \brief Convert a sparse CSR matrix into a sparse BSR matrix
# 
# \details
# \p hipsparseXcsr2bsr completes the conversion of a CSR matrix into a BSR matrix.
# It is assumed, that \p bsrValC, \p bsrColIndC and \p bsrRowPtrC are allocated. The
# allocation size for \p bsrRowPtr is computed as \p mb+1 where \p mb is the number of
# block rows in the BSR matrix defined as:
# 
# \f[
#   \begin{align}
#   \text{mb} &= \text{(m - 1) / blockDim + 1}
#   \end{align}
# \f]
# 
# The allocation size for \p bsrColIndC, i.e. \p bsrNnzb, is computed using
# \p hipsparseXcsr2bsrNnz() which also fills the \p bsrRowPtrC array. The allocation size
# for \p bsrValC is then equal to:
# 
# \f[
#   \text{bsrNnzb * blockDim * blockDim}
# \f]
# 
# For example, given the CSR matrix:
# \f[
#   \begin{bmatrix}
#   1 & 0 & 0 & 2 \\
#   3 & 4 & 0 & 0 \\
#   5 & 0 & 6 & 7 \\
#   1 & 2 & 3 & 4
#   \end{bmatrix}
# \f]
# 
# The resulting BSR matrix using block dimension 2 would look like:
# \f[
#  \left[
#   \begin{array}{c | c}
#     \begin{array}{c c}
#      1 & 0 \\
#      3 & 4
#     \end{array} &
#     \begin{array}{c c}
#      0 & 2 \\
#      0 & 0
#     \end{array} \\
#   \hline
#     \begin{array}{c c}
#      5 & 0 \\
#      1 & 2
#     \end{array} &
#     \begin{array}{c c}
#      6 & 7 \\
#      3 & 4
#     \end{array} \\
#  \end{array}
# \right]
# \f]
# 
# The call to \p hipsparseXcsr2bsrNnz results in the BSR row pointer array:
# \f[
#   \begin{align}
#   \text{bsrRowPtrC} &= \begin{bmatrix} 0 & 2 & 4 \end{bmatrix} \\
#   \end{align}
# \f]
# 
# and the call to \p hipsparseXcsr2bsr completes the conversion resulting in the BSR column indices and values arrays:
# \f[
#   \begin{align}
#   \text{bsrColIndC} &= \begin{bmatrix} 0 & 1 & 0 & 1 \end{bmatrix} \\
#   \text{bsrValC} &= \begin{bmatrix} 1 & 0 & 3 & 4 & 0 & 2 & 0 & 0 & 5 & 0 & 1 & 2 & 6 & 7 & 3 & 4 \end{bmatrix} \\
#   \end{align}
# \f]
# 
# The \p dirA parameter determines the order of the BSR block values. The example above uses row order. Using column ordering
# would result instead in the BSR values array:
# 
# \f[
#   \text{bsrValC} &= \begin{bmatrix} 1 & 3 & 0 & 4 & 0 & 0 & 2 & 0 & 5 & 1 & 0 & 2 & 6 & 3 & 7 & 4 \end{bmatrix} \\
# \f]
# 
# \note
# \p hipsparseXcsr2bsr requires extra temporary storage that is allocated internally if
# \p blockDim>16
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Matrix descriptor
#   hipsparseMatDescr_t csr_descr;
#   hipsparseCreateMatDescr(&csr_descr);
# 
#   hipsparseMatDescr_t bsr_descr;
#   hipsparseCreateMatDescr(&bsr_descr);
# 
#   // Sparse matrix in CSR format
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcsrRowPtr[4] = {0, 3, 5, 8};
#   int hcsrColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
#   float hcsrVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int nnz       = 8;
#   int blockDim  = 3;
#   hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;
# 
#   int mb = (m + blockDim - 1) / blockDim;
#   int nb = (n + blockDim - 1) / blockDim;
# 
#   int* dcsrRowPtr = nullptr;
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
# 
#   hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#   int* dbsrRowPtr = nullptr;
#   hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
# 
#   int nnzb;
#   hipsparseXcsr2bsrNnz(handle, dir, m, n, csr_descr, dcsrRowPtr, dcsrColInd, blockDim, bsr_descr, dbsrRowPtr, &nnzb);
# 
#   int* dbsrColInd = nullptr;
#   float* dbsrVal = nullptr;
#   hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
#   hipMalloc((void**)&dbsrVal, sizeof(float) * blockDim * blockDim * nnzb);
# 
#   hipsparseScsr2bsr(handle, dir, m, n, csr_descr, dcsrVal, dcsrRowPtr, dcsrColInd, blockDim, bsr_descr, dbsrVal, dbsrRowPtr, dbsrColInd);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
# 
#   hipFree(dbsrRowPtr);
#   hipFree(dbsrColInd);
#   hipFree(dbsrVal);
# 
#   hipsparseDestroyMatDescr(csr_descr);
#   hipsparseDestroyMatDescr(bsr_descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseScsr2bsr(void * handle,hipsparseDirection_t dirA,int m,int n,void *const descrA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,int blockDim,void *const descrC,float * bsrValC,int * bsrRowPtrC,int * bsrColIndC)



cdef hipsparseStatus_t hipsparseDcsr2bsr(void * handle,hipsparseDirection_t dirA,int m,int n,void *const descrA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,int blockDim,void *const descrC,double * bsrValC,int * bsrRowPtrC,int * bsrColIndC)



cdef hipsparseStatus_t hipsparseCcsr2bsr(void * handle,hipsparseDirection_t dirA,int m,int n,void *const descrA,float2 * csrValA,const int * csrRowPtrA,const int * csrColIndA,int blockDim,void *const descrC,float2 * bsrValC,int * bsrRowPtrC,int * bsrColIndC)



cdef hipsparseStatus_t hipsparseZcsr2bsr(void * handle,hipsparseDirection_t dirA,int m,int n,void *const descrA,double2 * csrValA,const int * csrRowPtrA,const int * csrColIndA,int blockDim,void *const descrC,double2 * bsrValC,int * bsrRowPtrC,int * bsrColIndC)


#  \ingroup conv_module
# \brief Convert a sparse BSR matrix into a sparse CSR matrix
# 
# \details
# \p hipsparseXbsr2csr converts a BSR matrix into a CSR matrix. It is assumed,
# that \p csrValC, \p csrColIndC and \p csrRowPtrC are allocated. Allocation size
# for \p csrRowPtrC is computed by the number of block rows multiplied by the block
# dimension plus one. Allocation for \p csrValC and \p csrColInd is computed by the
# the number of blocks in the BSR matrix multiplied by the block dimension squared.
# 
# For example, given the BSR matrix using block dimension 2:
# \f[
#  \left[
#   \begin{array}{c | c}
#     \begin{array}{c c}
#      1 & 0 \\
#      3 & 4
#     \end{array} &
#     \begin{array}{c c}
#      0 & 2 \\
#      0 & 0
#     \end{array} \\
#   \hline
#     \begin{array}{c c}
#      5 & 0 \\
#      1 & 2
#     \end{array} &
#     \begin{array}{c c}
#      6 & 7 \\
#      3 & 4
#     \end{array} \\
#  \end{array}
# \right]
# \f]
# 
# The resulting CSR matrix row pointer, column indices, and values arrays are:
# \f[
#   \begin{align}
#   \text{csrRowPtrC} &= \begin{bmatrix} 0 & 4 & 8 & 12 & 16 \end{bmatrix} \\
#   \text{csrColIndC} &= \begin{bmatrix} 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 & 0 & 1 & 2 & 3 \end{bmatrix} \\
#   \text{csrValC} &= \begin{bmatrix} 1 & 0 & 0 & 2 & 3 & 4 & 0 & 0 & 5 & 0 & 6 & 7 & 1 & 2 & 3 & 4 \end{bmatrix} \\
#   \end{align}
# \f]
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t csr_descr;
#   hipsparseCreateMatDescr(&csr_descr);
# 
#   hipsparseMatDescr_t bsr_descr;
#   hipsparseCreateMatDescr(&bsr_descr);
# 
#   // Sparse matrix in BSR format
#   //     1 2 | 0 3 | 0 0
#   //     0 4 | 5 0 | 0 1
#   //     ---------------
#   // A = 6 0 | 0 7 | 8 0
#   //     0 0 | 3 0 | 2 2
#   //     ---------------
#   //     1 0 | 0 0 | 4 3
#   //     7 2 | 0 0 | 1 4
#   int hbsrRowPtr[4] = {0, 3, 6, 8};
#   int hbsrColInd[8] = {0, 1, 2, 0, 1, 2, 0, 2};
#   float hbsrVal[32]  = {1.0f, 2.0f, 0.0f, 4.0f,
#                           0.0f, 3.0f, 5.0f, 0.0f,
#                           0.0f, 0.0f, 0.0f, 1.0f,
#                           6.0f, 0.0f, 0.0f, 0.0f,
#                           0.0f, 7.0f, 3.0f, 0.0f,
#                           8.0f, 0.0f, 2.0f, 2.0f,
#                           1.0f, 0.0f, 7.0f, 2.0f,
#                           4.0f, 3.0f, 1.0f, 4.0f};
# 
#   int m        = 6;
#   int n        = 6;
#   int nnz      = 32;
#   int mb       = 3;
#   int nb       = 3;
#   int nnzb     = 8;
#   int blockDim = 2;
#   hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;
# 
#   int* dbsrRowPtr = nullptr;
#   int* dbsrColInd = nullptr;
#   float* dbsrVal = nullptr;
#   hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
#   hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
#   hipMalloc((void**)&dbsrVal, sizeof(float) * blockDim * blockDim * nnzb);
# 
#   hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
#   hipMemcpy(dbsrVal, hbsrVal, sizeof(float) * blockDim * blockDim * nnzb, hipMemcpyHostToDevice);
# 
#   int* dcsrRowPtr = nullptr;
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
# 
#   hipsparseSbsr2csr(handle,
#                     dir,
#                     mb,
#                     nb,
#                     bsr_descr,
#                     dbsrVal,
#                     dbsrRowPtr,
#                     dbsrColInd,
#                     blockDim,
#                     csr_descr,
#                     dcsrVal,
#                     dcsrRowPtr,
#                     dcsrColInd);
# 
#   hipFree(dbsrRowPtr);
#   hipFree(dbsrColInd);
#   hipFree(dbsrVal);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
# 
#   hipsparseDestroyMatDescr(csr_descr);
#   hipsparseDestroyMatDescr(bsr_descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseSbsr2csr(void * handle,hipsparseDirection_t dirA,int mb,int nb,void *const descrA,const float * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,void *const descrC,float * csrValC,int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseDbsr2csr(void * handle,hipsparseDirection_t dirA,int mb,int nb,void *const descrA,const double * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,void *const descrC,double * csrValC,int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseCbsr2csr(void * handle,hipsparseDirection_t dirA,int mb,int nb,void *const descrA,float2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,void *const descrC,float2 * csrValC,int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseZbsr2csr(void * handle,hipsparseDirection_t dirA,int mb,int nb,void *const descrA,double2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int blockDim,void *const descrC,double2 * csrValC,int * csrRowPtrC,int * csrColIndC)


#  \ingroup conv_module
# \brief Convert a sparse GEBSR matrix into a sparse CSR matrix
# 
# \details
# \p hipsparseXgebsr2csr converts a GEBSR matrix into a CSR matrix. It is assumed,
# that \p csrValC, \p csrColIndC and \p csrRowPtrC are already allocated prior to
# calling \p hipsparseXgebsr2csr. Allocation size for \p csrRowPtrC equals
# \p m+1 where:
# 
# \f[
#   \begin{align}
#   \text{m} &= \text{mb * rowBlockDim} \\
#   \text{n} &= \text{nb * colBlockDim}
#   \end{align}
# \f]
# 
# Allocation size for \p csrValC and \p csrColIndC is computed by the the number of blocks in the GEBSR
# matrix, \p nnzb, multiplied by the product of the block dimensions, i.e. \p nnz=nnzb*rocBlockDim*colBlockDim.
# 
# For example, given the GEBSR matrix:
# \f[
#  \left[
#   \begin{array}{c | c | c}
#     \begin{array}{c c}
#      6 & 2 \\
#      1 & 4 \\
#      5 & 4
#     \end{array} &
#     \begin{array}{c c}
#      0 & 3 \\
#      5 & 0 \\
#      0 & 7
#     \end{array} &
#     \begin{array}{c c}
#      0 & 0 \\
#      0 & 0 \\
#      0 & 0
#     \end{array} \\
#   \hline
#     \begin{array}{c c}
#      0 & 0 \\
#      0 & 0 \\
#      0 & 0
#     \end{array} &
#     \begin{array}{c c}
#      3 & 0 \\
#      0 & 0 \\
#      0 & 7
#     \end{array} &
#     \begin{array}{c c}
#      2 & 2 \\
#      4 & 3 \\
#      1 & 4
#     \end{array} \\
#  \end{array}
# \right]
# \f]
# 
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t csr_descr;
#   hipsparseCreateMatDescr(&csr_descr);
# 
#   hipsparseMatDescr_t bsr_descr;
#   hipsparseCreateMatDescr(&bsr_descr);
# 
#   // Sparse matrix in GEBSR format
#   //     1 2 | 0 3 | 0 0
#   //     0 4 | 5 0 | 0 1
#   // A = 6 0 | 0 7 | 8 0
#   //     ---------------
#   //     0 0 | 3 0 | 2 2
#   //     1 0 | 0 0 | 4 3
#   //     7 2 | 0 0 | 1 4
#   int hbsrRowPtr[3] = {0, 3, 6};
#   int hbsrColInd[6] = {0, 1, 2, 0, 1, 2};
#   float hbsrVal[36]  = {1.0f, 2.0f, 0.0f, 4.0f, 6.0f, 0.0f,
#                          0.0f, 3.0f, 5.0f, 0.0f, 0.0f, 7.0f,
#                          0.0f, 0.0f, 0.0f, 1.0f, 8.0f, 0.0f,
#                          0.0f, 0.0f, 1.0f, 0.0f, 7.0f, 2.0f,
#                          3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f,
#                          2.0f, 2.0f, 4.0f, 3.0f, 1.0f, 4.0f};
# 
#   int m        = 6;
#   int n        = 6;
#   int nnz      = 36;
#   int mb       = 2;
#   int nb       = 3;
#   int nnzb     = 6;
#   int rowBlockDim = 3;
#   int colBlockDim = 2;
#   hipsparseDirection_t dir = HIPSPARSE_DIRECTION_ROW;
# 
#   int* dbsrRowPtr = nullptr;
#   int* dbsrColInd = nullptr;
#   float* dbsrVal = nullptr;
#   hipMalloc((void**)&dbsrRowPtr, sizeof(int) * (mb + 1));
#   hipMalloc((void**)&dbsrColInd, sizeof(int) * nnzb);
#   hipMalloc((void**)&dbsrVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb);
# 
#   hipMemcpy(dbsrRowPtr, hbsrRowPtr, sizeof(int) * (mb + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dbsrColInd, hbsrColInd, sizeof(int) * nnzb, hipMemcpyHostToDevice);
#   hipMemcpy(dbsrVal, hbsrVal, sizeof(float) * rowBlockDim * colBlockDim * nnzb, hipMemcpyHostToDevice);
# 
#   int* dcsrRowPtr = nullptr;
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
# 
#   hipsparseSgebsr2csr(handle,
#                       dir,
#                       mb,
#                       nb,
#                       bsr_descr,
#                       dbsrVal,
#                       dbsrRowPtr,
#                       dbsrColInd,
#                       rowBlockDim,
#                       colBlockDim,
#                       csr_descr,
#                       dcsrVal,
#                       dcsrRowPtr,
#                       dcsrColInd);
# 
#   hipFree(dbsrRowPtr);
#   hipFree(dbsrColInd);
#   hipFree(dbsrVal);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
# 
#   hipsparseDestroyMatDescr(csr_descr);
#   hipsparseDestroyMatDescr(bsr_descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseSgebsr2csr(void * handle,hipsparseDirection_t dirA,int mb,int nb,void *const descrA,const float * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDim,int colBlockDim,void *const descrC,float * csrValC,int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseDgebsr2csr(void * handle,hipsparseDirection_t dirA,int mb,int nb,void *const descrA,const double * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDim,int colBlockDim,void *const descrC,double * csrValC,int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseCgebsr2csr(void * handle,hipsparseDirection_t dirA,int mb,int nb,void *const descrA,float2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDim,int colBlockDim,void *const descrC,float2 * csrValC,int * csrRowPtrC,int * csrColIndC)



cdef hipsparseStatus_t hipsparseZgebsr2csr(void * handle,hipsparseDirection_t dirA,int mb,int nb,void *const descrA,double2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDim,int colBlockDim,void *const descrC,double2 * csrValC,int * csrRowPtrC,int * csrColIndC)


#  \ingroup conv_module
# \brief Convert a sparse CSR matrix into a compressed sparse CSR matrix
# 
# \details
# \p hipsparseXcsr2csr_compress converts a CSR matrix into a compressed CSR matrix by
# removing entries in the input CSR matrix that are below a non-negative threshold \p tol:
# 
# \f[
#  C(i,j) = A(i, j) \text{  if |A(i, j)| > tol}
# \f]
# 
# The user must first call \p nnz_compress to determine the number of nonzeros per row as well as
# the total number of nonzeros that will exist in resulting compressed CSR matrix. The user then uses
# this information to allocate the column indices array \p csrColIndC and the values array \p csrValC.
# The user then calls \p hipsparseXcsr2csr_compress to complete the conversion.
# 
# \note
# In the case of complex matrices only the magnitude of the real part of \p tol is used.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Matrix descriptor
#   hipsparseMatDescr_t descr;
#   hipsparseCreateMatDescr(&descr);
# 
#   // Sparse matrix in CSR format
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcsrRowPtrA[4] = {0, 3, 5, 8};
#   int hcsrColIndA[8] = {0, 1, 3, 1, 2, 0, 3, 4};
#   float hcsrValA[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};
# 
#   int m    = 3;
#   int n    = 5;
#   int nnzA = 8;
# 
#   float tol = 5.9f;
# 
#   int* dcsrRowPtrA = nullptr;
#   int* dcsrColIndA = nullptr;
#   float* dcsrValA = nullptr;
#   hipMalloc((void**)&dcsrRowPtrA, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColIndA, sizeof(int) * nnzA);
#   hipMalloc((void**)&dcsrValA, sizeof(float) * nnzA);
# 
#   hipMemcpy(dcsrRowPtrA, hcsrRowPtrA, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColIndA, hcsrColIndA, sizeof(int) * nnzA, hipMemcpyHostToDevice);
#   hipMemcpy(dcsrValA, hcsrValA, sizeof(float) * nnzA, hipMemcpyHostToDevice);
# 
#   // Allocate memory for the nnz_per_row array
#   int* dnnz_per_row;
#   hipMalloc((void**)&dnnz_per_row, sizeof(int) * m);
# 
#   // Call snnz_compress() which fills in nnz_per_row array and finds the number
#   // of entries that will be in the compressed CSR matrix
#   int nnzC;
#   hipsparseSnnz_compress(handle, m, descr, dcsrValA, dcsrRowPtrA, dnnz_per_row, &nnzC, tol);
# 
#   int* dcsrRowPtrC = nullptr;
#   int* dcsrColIndC = nullptr;
#   float* dcsrValC = nullptr;
#   hipMalloc((void**)&dcsrRowPtrC, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColIndC, sizeof(int) * nnzC);
#   hipMalloc((void**)&dcsrValC, sizeof(float) * nnzC);
# 
#   hipsparseScsr2csr_compress(handle,
#                              m,
#                              n,
#                              descr,
#                              dcsrValA,
#                              dcsrColIndA,
#                              dcsrRowPtrA,
#                              nnzA,
#                              dnnz_per_row,
#                              dcsrValC,
#                              dcsrColIndC,
#                              dcsrRowPtrC,
#                              tol);
# 
#   hipFree(dcsrRowPtrA);
#   hipFree(dcsrColIndA);
#   hipFree(dcsrValA);
# 
#   hipFree(dcsrRowPtrC);
#   hipFree(dcsrColIndC);
#   hipFree(dcsrValC);
# 
#   hipFree(dnnz_per_row);
# 
#   hipsparseDestroyMatDescr(descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseScsr2csr_compress(void * handle,int m,int n,void *const descrA,const float * csrValA,const int * csrColIndA,const int * csrRowPtrA,int nnzA,const int * nnzPerRow,float * csrValC,int * csrColIndC,int * csrRowPtrC,float tol)



cdef hipsparseStatus_t hipsparseDcsr2csr_compress(void * handle,int m,int n,void *const descrA,const double * csrValA,const int * csrColIndA,const int * csrRowPtrA,int nnzA,const int * nnzPerRow,double * csrValC,int * csrColIndC,int * csrRowPtrC,double tol)



cdef hipsparseStatus_t hipsparseCcsr2csr_compress(void * handle,int m,int n,void *const descrA,float2 * csrValA,const int * csrColIndA,const int * csrRowPtrA,int nnzA,const int * nnzPerRow,float2 * csrValC,int * csrColIndC,int * csrRowPtrC,float2 tol)



cdef hipsparseStatus_t hipsparseZcsr2csr_compress(void * handle,int m,int n,void *const descrA,double2 * csrValA,const int * csrColIndA,const int * csrRowPtrA,int nnzA,const int * nnzPerRow,double2 * csrValC,int * csrColIndC,int * csrRowPtrC,double2 tol)


# \ingroup conv_module
# \brief Convert and prune sparse CSR matrix into a sparse CSR matrix
# 
# \details
# \p hipsparseXpruneCsr2csr_bufferSize returns the size of the temporary buffer that
# is required by \p hipsparseXpruneCsr2csrNnz and hipsparseXpruneCsr2csr. The
# temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSpruneCsr2csr_bufferSize(void * handle,int m,int n,int nnzA,void *const descrA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,const float * threshold,void *const descrC,const float * csrValC,const int * csrRowPtrC,const int * csrColIndC,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDpruneCsr2csr_bufferSize(void * handle,int m,int n,int nnzA,void *const descrA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,const double * threshold,void *const descrC,const double * csrValC,const int * csrRowPtrC,const int * csrColIndC,unsigned long * pBufferSizeInBytes)


# \ingroup conv_module
# \brief Convert and prune sparse CSR matrix into a sparse CSR matrix
# 
# \details
# \p hipsparseXpruneCsr2csr_bufferSizeExt returns the size of the temporary buffer that
# is required by \p hipsparseXpruneCsr2csrNnz and hipsparseXpruneCsr2csr. The
# temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSpruneCsr2csr_bufferSizeExt(void * handle,int m,int n,int nnzA,void *const descrA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,const float * threshold,void *const descrC,const float * csrValC,const int * csrRowPtrC,const int * csrColIndC,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDpruneCsr2csr_bufferSizeExt(void * handle,int m,int n,int nnzA,void *const descrA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,const double * threshold,void *const descrC,const double * csrValC,const int * csrRowPtrC,const int * csrColIndC,unsigned long * pBufferSizeInBytes)


# \ingroup conv_module
# \brief Convert and prune sparse CSR matrix into a sparse CSR matrix
# 
# \details
# \p hipsparseXpruneCsr2csrNnz computes the number of nonzero elements per row and the total
# number of nonzero elements in a sparse CSR matrix once elements less than the threshold are
# pruned from the matrix.
# 
# \note The routine does support asynchronous execution if the pointer mode is set to device.
cdef hipsparseStatus_t hipsparseSpruneCsr2csrNnz(void * handle,int m,int n,int nnzA,void *const descrA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,const float * threshold,void *const descrC,int * csrRowPtrC,int * nnzTotalDevHostPtr,void * buffer)



cdef hipsparseStatus_t hipsparseDpruneCsr2csrNnz(void * handle,int m,int n,int nnzA,void *const descrA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,const double * threshold,void *const descrC,int * csrRowPtrC,int * nnzTotalDevHostPtr,void * buffer)


# \ingroup conv_module
# \brief Convert and prune sparse CSR matrix into a sparse CSR matrix
# 
# \details
# This function converts the sparse CSR matrix A into a sparse CSR matrix C by pruning values in A
# that are less than the threshold. All the parameters are assumed to have been pre-allocated by the user.
# The user first calls hipsparseXpruneCsr2csr_bufferSize() to determine the size of the buffer used
# by hipsparseXpruneCsr2csrNnz() and hipsparseXpruneCsr2csr() which the user then allocates. The user then
# allocates \p csrRowPtrC to have \p m+1 elements and then calls hipsparseXpruneCsr2csrNnz() which fills
# in the \p csrRowPtrC array stores then number of elements that are larger than the pruning \p threshold
# in \p nnzTotalDevHostPtr. The user then calls hipsparseXpruneCsr2csr() to complete the conversion. It
# is executed asynchronously with respect to the host and may return control to the application on the host
# before the entire result is ready.
cdef hipsparseStatus_t hipsparseSpruneCsr2csr(void * handle,int m,int n,int nnzA,void *const descrA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,const float * threshold,void *const descrC,float * csrValC,const int * csrRowPtrC,int * csrColIndC,void * buffer)



cdef hipsparseStatus_t hipsparseDpruneCsr2csr(void * handle,int m,int n,int nnzA,void *const descrA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,const double * threshold,void *const descrC,double * csrValC,const int * csrRowPtrC,int * csrColIndC,void * buffer)


# \ingroup conv_module
# \brief Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix
# 
# \details
# \p hipsparseXpruneCsr2csrByPercentage_bufferSize returns the size of the temporary buffer that
# is required by \p hipsparseXpruneCsr2csrNnzByPercentage.
# The temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSpruneCsr2csrByPercentage_bufferSize(void * handle,int m,int n,int nnzA,void *const descrA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,float percentage,void *const descrC,const float * csrValC,const int * csrRowPtrC,const int * csrColIndC,pruneInfo_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDpruneCsr2csrByPercentage_bufferSize(void * handle,int m,int n,int nnzA,void *const descrA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,double percentage,void *const descrC,const double * csrValC,const int * csrRowPtrC,const int * csrColIndC,pruneInfo_t info,unsigned long * pBufferSizeInBytes)


# \ingroup conv_module
# \brief Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix
# 
# \details
# \p hipsparseXpruneCsr2csrByPercentage_bufferSizeExt returns the size of the temporary buffer that
# is required by \p hipsparseXpruneCsr2csrNnzByPercentage.
# The temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSpruneCsr2csrByPercentage_bufferSizeExt(void * handle,int m,int n,int nnzA,void *const descrA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,float percentage,void *const descrC,const float * csrValC,const int * csrRowPtrC,const int * csrColIndC,pruneInfo_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDpruneCsr2csrByPercentage_bufferSizeExt(void * handle,int m,int n,int nnzA,void *const descrA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,double percentage,void *const descrC,const double * csrValC,const int * csrRowPtrC,const int * csrColIndC,pruneInfo_t info,unsigned long * pBufferSizeInBytes)


# \ingroup conv_module
# \brief Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix
# 
# \details
# \p hipsparseXpruneCsr2csrNnzByPercentage computes the number of nonzero elements per row and the total
# number of nonzero elements in a sparse CSR matrix once elements less than the threshold are
# pruned from the matrix.
# 
# \note The routine does support asynchronous execution if the pointer mode is set to device.
cdef hipsparseStatus_t hipsparseSpruneCsr2csrNnzByPercentage(void * handle,int m,int n,int nnzA,void *const descrA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,float percentage,void *const descrC,int * csrRowPtrC,int * nnzTotalDevHostPtr,pruneInfo_t info,void * buffer)



cdef hipsparseStatus_t hipsparseDpruneCsr2csrNnzByPercentage(void * handle,int m,int n,int nnzA,void *const descrA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,double percentage,void *const descrC,int * csrRowPtrC,int * nnzTotalDevHostPtr,pruneInfo_t info,void * buffer)


# \ingroup conv_module
# \brief Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix
# 
# \details
# This function converts the sparse CSR matrix A into a sparse CSR matrix C by pruning values in A
# that are less than the threshold. All the parameters are assumed to have been pre-allocated by the user.
# The user first calls hipsparseXpruneCsr2csr_bufferSize() to determine the size of the buffer used
# by hipsparseXpruneCsr2csrNnz() and hipsparseXpruneCsr2csr() which the user then allocates. The user then
# allocates \p csrRowPtrC to have \p m+1 elements and then calls hipsparseXpruneCsr2csrNnz() which fills
# in the \p csrRowPtrC array stores then number of elements that are larger than the pruning \p threshold
# in \p nnzTotalDevHostPtr. The user then calls hipsparseXpruneCsr2csr() to complete the conversion. It
# is executed asynchronously with respect to the host and may return control to the application on the host
# before the entire result is ready.
cdef hipsparseStatus_t hipsparseSpruneCsr2csrByPercentage(void * handle,int m,int n,int nnzA,void *const descrA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,float percentage,void *const descrC,float * csrValC,const int * csrRowPtrC,int * csrColIndC,pruneInfo_t info,void * buffer)



cdef hipsparseStatus_t hipsparseDpruneCsr2csrByPercentage(void * handle,int m,int n,int nnzA,void *const descrA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,double percentage,void *const descrC,double * csrValC,const int * csrRowPtrC,int * csrColIndC,pruneInfo_t info,void * buffer)


#  \ingroup conv_module
# \brief Convert a sparse HYB matrix into a sparse CSR matrix
# 
# \details
# \p hipsparseXhyb2csr converts a HYB matrix into a CSR matrix.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
cdef hipsparseStatus_t hipsparseShyb2csr(void * handle,void *const descrA,void *const hybA,float * csrSortedValA,int * csrSortedRowPtrA,int * csrSortedColIndA)



cdef hipsparseStatus_t hipsparseDhyb2csr(void * handle,void *const descrA,void *const hybA,double * csrSortedValA,int * csrSortedRowPtrA,int * csrSortedColIndA)



cdef hipsparseStatus_t hipsparseChyb2csr(void * handle,void *const descrA,void *const hybA,float2 * csrSortedValA,int * csrSortedRowPtrA,int * csrSortedColIndA)



cdef hipsparseStatus_t hipsparseZhyb2csr(void * handle,void *const descrA,void *const hybA,double2 * csrSortedValA,int * csrSortedRowPtrA,int * csrSortedColIndA)


#  \ingroup conv_module
# \brief Convert a sparse COO matrix into a sparse CSR matrix
# 
# \details
# \p hipsparseXcoo2csr converts the COO array containing the row indices into a
# CSR array of row offsets, that point to the start of every row.
# It is assumed that the COO row index array is sorted and that all arrays have been allocated
# prior to calling hipsparseXcoo2csr.
# 
# For example, given the COO row indices array:
# \f[
#   \begin{align}
#   \text{cooRowInd} &= \begin{bmatrix} 0 & 0 & 1 & 2 & 2 & 4 & 4 & 4 \end{bmatrix}
#   \end{align}
# \f]
# 
# the resulting CSR row pointer array after calling \p hipsparseXcoo2csr is:
# \f[
#   \begin{align}
#   \text{csrRowPtr} &= \begin{bmatrix} 0 & 2 & 3 & 5 & 8 \end{bmatrix}
#   \end{align}
# \f]
# 
# \note It can also be used, to convert a COO array containing the column indices into
# a CSC array of column offsets, that point to the start of every column. Then, it is
# assumed that the COO column index array is sorted, instead.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Sparse matrix in COO format
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcooRowInd[8] = {0, 0, 0, 1, 1, 2, 2, 2};
#   int hcooColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
#   float hcooVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int nnz       = 8;
#   hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;
# 
#   int* dcooRowInd = nullptr;
#   int* dcooColInd = nullptr;
#   hipMalloc((void**)&dcooRowInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcooColInd, sizeof(int) * nnz);
# 
#   hipMemcpy(dcooRowInd, hcooRowInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcooColInd, hcooColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
# 
#   int* dcsrRowPtr = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
# 
#   hipsparseXcoo2csr(handle, dcooRowInd, nnz, m, dcsrRowPtr, base);
# 
#   hipFree(dcooRowInd);
#   hipFree(dcooColInd);
# 
#   hipFree(dcsrRowPtr);
# 
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseXcoo2csr(void * handle,const int * cooRowInd,int nnz,int m,int * csrRowPtr,hipsparseIndexBase_t idxBase)


#  \ingroup conv_module
# \brief Create the identity map
# 
# \details
# \p hipsparseCreateIdentityPermutation stores the identity map in \p p, such that
# \f$p = 0:1:(n-1)\f$.
# 
# \code{.c}
#     for(i = 0; i < n; ++i)
#     {
#         p[i] = i;
#     }
# \endcode
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   int n = 10;
# 
#   int* dperm = nullptr;
#   hipMalloc((void**)&dperm, sizeof(int) * n);
# 
#   hipsparseCreateIdentityPermutation(handle, n, dperm);
# 
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseCreateIdentityPermutation(void * handle,int n,int * p)


#  \ingroup conv_module
# \brief Sort a sparse CSR matrix
# 
# \details
# \p hipsparseXcsrsort_bufferSizeExt returns the size of the temporary storage buffer
# in bytes required by hipsparseXcsrsort(). The temporary storage buffer must be allocated by
# the user.
cdef hipsparseStatus_t hipsparseXcsrsort_bufferSizeExt(void * handle,int m,int n,int nnz,const int * csrRowPtr,const int * csrColInd,unsigned long * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief Sort a sparse CSR matrix
# 
# \details
# \p hipsparseXcsrsort sorts a matrix in CSR format. The sorted permutation vector
# \p perm can be used to obtain sorted \p csrVal array. In this case, \p perm must be
# initialized as the identity permutation, see hipsparseCreateIdentityPermutation(). To
# apply the permutation vector to the CSR values, see hipsparse hipsparseSgthr().
# 
# \p hipsparseXcsrsort requires extra temporary storage buffer that has to be allocated by
# the user. Storage buffer size can be determined by hipsparseXcsrsort_bufferSizeExt().
# 
# \note
# \p perm can be \p NULL if a sorted permutation vector is not required.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t descr;
#   hipsparseCreateMatDescr(&descr);
# 
#   // Sparse matrix in CSR format (columns unsorted)
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcsrRowPtr[4] = {0, 3, 5, 8};
#   int hcsrColInd[8] = {3, 1, 0, 2, 1, 0, 4, 3};
#   float hcsrVal[8]  = {3.0f, 2.0f, 1.0f, 5.0f, 4.0f, 6.0f, 8.0f, 7.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int nnz       = 8;
# 
#   int* dcsrRowPtr = nullptr;
#   int* dcsrColInd = nullptr;
#   float* dcsrVal = nullptr;
#   hipMalloc((void**)&dcsrRowPtr, sizeof(int) * (m + 1));
#   hipMalloc((void**)&dcsrColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcsrVal, sizeof(float) * nnz);
# 
#   hipMemcpy(dcsrRowPtr, hcsrRowPtr, sizeof(int) * (m + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcsrColInd, hcsrColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcsrVal, hcsrVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#   size_t bufferSize;
#   hipsparseXcsrsort_bufferSizeExt(handle,
#                                   m,
#                                   n,
#                                   nnz,
#                                   dcsrRowPtr,
#                                   dcsrColInd,
#                                   &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   int* dperm = nullptr;
#   hipMalloc((void**)&dperm, sizeof(int) * nnz);
#   hipsparseCreateIdentityPermutation(handle, nnz, dperm);
# 
#   hipsparseXcsrsort(handle,
#                     m,
#                     n,
#                     nnz,
#                     descr,
#                     dcsrRowPtr,
#                     dcsrColInd,
#                     dperm,
#                     dbuffer);
# 
#   float* dcsrValSorted = nullptr;
#   hipMalloc((void**)&dcsrValSorted, sizeof(float) * nnz);
#   hipsparseSgthr(handle, nnz, dcsrVal, dcsrValSorted, dperm, HIPSPARSE_INDEX_BASE_ZERO);
# 
#   hipFree(dcsrRowPtr);
#   hipFree(dcsrColInd);
#   hipFree(dcsrVal);
#   hipFree(dcsrValSorted);
# 
#   hipFree(dbuffer);
#   hipFree(dperm);
# 
#   hipsparseDestroyMatDescr(descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseXcsrsort(void * handle,int m,int n,int nnz,void *const descrA,const int * csrRowPtr,int * csrColInd,int * P,void * pBuffer)


#  \ingroup conv_module
# \brief Sort a sparse CSC matrix
# 
# \details
# \p hipsparseXcscsort_bufferSizeExt returns the size of the temporary storage buffer
# in bytes required by hipsparseXcscsort(). The temporary storage buffer must be
# allocated by the user.
cdef hipsparseStatus_t hipsparseXcscsort_bufferSizeExt(void * handle,int m,int n,int nnz,const int * cscColPtr,const int * cscRowInd,unsigned long * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief Sort a sparse CSC matrix
# 
# \details
# \p hipsparseXcscsort sorts a matrix in CSC format. The sorted permutation vector
# \p perm can be used to obtain sorted \p csc_val array. In this case, \p perm must be
# initialized as the identity permutation, see hipsparseCreateIdentityPermutation(). To
# apply the permutation vector to the CSC values, see hipsparse hipsparseSgthr().
# 
# \p hipsparseXcscsort requires extra temporary storage buffer that has to be allocated by
# the user. Storage buffer size can be determined by hipsparseXcscsort_bufferSizeExt().
# 
# \note
# \p perm can be \p NULL if a sorted permutation vector is not required.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t descr;
#   hipsparseCreateMatDescr(&descr);
# 
#   // Sparse matrix in CSC format (unsorted row indices)
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcscRowInd[8] = {2, 0, 1, 0, 1, 2, 0, 2};
#   int hcscColPtr[6] = {0, 2, 4, 5, 7, 8};
#   float hcscVal[8]  = {6.0f, 1.0f, 4.0f, 2.0f, 5.0f, 7.0f, 3.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int nnz       = 8;
# 
#   int* dcscRowInd = nullptr;
#   int* dcscColPtr = nullptr;
#   float* dcscVal = nullptr;
#   hipMalloc((void**)&dcscRowInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcscColPtr, sizeof(int) * (n + 1));
#   hipMalloc((void**)&dcscVal, sizeof(float) * nnz);
# 
#   hipMemcpy(dcscRowInd, hcscRowInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcscColPtr, hcscColPtr, sizeof(int) * (n + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dcscVal, hcscVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#   size_t bufferSize;
#   hipsparseXcscsort_bufferSizeExt(handle,
#                                   m,
#                                   n,
#                                   nnz,
#                                   dcscColPtr,
#                                   dcscRowInd,
#                                   &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   int* dperm = nullptr;
#   hipMalloc((void**)&dperm, sizeof(int) * nnz);
#   hipsparseCreateIdentityPermutation(handle, nnz, dperm);
# 
#   hipsparseXcscsort(handle,
#                     m,
#                     n,
#                     nnz,
#                     descr,
#                     dcscColPtr,
#                     dcscRowInd,
#                     dperm,
#                     dbuffer);
# 
#   float* dcscValSorted = nullptr;
#   hipMalloc((void**)&dcscValSorted, sizeof(float) * nnz);
#   hipsparseSgthr(handle, nnz, dcscVal, dcscValSorted, dperm, HIPSPARSE_INDEX_BASE_ZERO);
# 
#   hipFree(dcscRowInd);
#   hipFree(dcscColPtr);
#   hipFree(dcscVal);
#   hipFree(dcscValSorted);
# 
#   hipFree(dbuffer);
#   hipFree(dperm);
# 
#   hipsparseDestroyMatDescr(descr);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseXcscsort(void * handle,int m,int n,int nnz,void *const descrA,const int * cscColPtr,int * cscRowInd,int * P,void * pBuffer)


#  \ingroup conv_module
# \brief Sort a sparse COO matrix
# 
# \details
# \p hipsparseXcoosort_bufferSizeExt returns the size of the temporary storage buffer
# in bytes required by hipsparseXcoosort(). The temporary storage buffer must be
# allocated by the user.
cdef hipsparseStatus_t hipsparseXcoosort_bufferSizeExt(void * handle,int m,int n,int nnz,const int * cooRows,const int * cooCols,unsigned long * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief Sort a sparse COO matrix by row
# 
# \details
# \p hipsparseXcoosortByRow sorts a matrix in COO format by row. The sorted
# permutation vector \p perm can be used to obtain sorted \p cooVal array. In this
# case, \p perm must be initialized as the identity permutation, see
# hipsparseCreateIdentityPermutation(). To apply the permutation vector to the COO
# values, see hipsparse hipsparseSgthr().
# 
# \p hipsparseXcoosortByRow requires extra temporary storage buffer that has to be
# allocated by the user. Storage buffer size can be determined by
# hipsparseXcoosort_bufferSizeExt().
# 
# \note
# \p perm can be \p NULL if a sorted permutation vector is not required.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Sparse matrix in COO format (with unsorted row indices)
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcooRowInd[8] = {0, 2, 0, 1, 1, 0, 2, 2};
#   int hcooColInd[8] = {0, 0, 1, 1, 2, 3, 3, 4};
#   float hcooVal[8]   = {1.0f, 6.0f, 2.0f, 4.0f, 5.0f, 3.0f, 7.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int nnz       = 8;
#   hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;
# 
#   int* dcooRowInd = nullptr;
#   int* dcooColInd = nullptr;
#   float* dcooVal = nullptr;
#   hipMalloc((void**)&dcooRowInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcooColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcooVal, sizeof(float) * nnz);
# 
#   hipMemcpy(dcooRowInd, hcooRowInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcooColInd, hcooColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcooVal, hcooVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#   size_t bufferSize;
#   hipsparseXcoosort_bufferSizeExt(handle, m, n, nnz, dcooRowInd, dcooColInd, &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   int* dperm = nullptr;
#   hipMalloc((void**)&dperm, sizeof(int) * nnz);
#   hipsparseCreateIdentityPermutation(handle, nnz, dperm);
# 
#   hipsparseXcoosortByRow(handle, m, n, nnz, dcooRowInd, dcooColInd, dperm, dbuffer);
# 
#   float* dcooValSorted = nullptr;
#   hipMalloc((void**)&dcooValSorted, sizeof(float) * nnz);
#   hipsparseSgthr(handle, nnz, dcooVal, dcooValSorted, dperm, base);
# 
#   hipFree(dcooRowInd);
#   hipFree(dcooColInd);
#   hipFree(dcooVal);
#   hipFree(dcooValSorted);
#   hipFree(dperm);
# 
#   hipFree(dbuffer);
# 
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseXcoosortByRow(void * handle,int m,int n,int nnz,int * cooRows,int * cooCols,int * P,void * pBuffer)


#  \ingroup conv_module
# \brief Sort a sparse COO matrix by column
# 
# \details
# \p hipsparseXcoosortByColumn sorts a matrix in COO format by column. The sorted
# permutation vector \p perm can be used to obtain sorted \p cooVal array. In this
# case, \p perm must be initialized as the identity permutation, see
# hipsparseCreateIdentityPermutation(). To apply the permutation vector to the COO
# values, see hipsparse hipsparseSgthr().
# 
# \p hipsparseXcoosortByColumn requires extra temporary storage buffer that has to be
# allocated by the user. Storage buffer size can be determined by
# hipsparseXcoosort_bufferSizeExt().
# 
# \note
# \p perm can be \p NULL if a sorted permutation vector is not required.
# 
# \note
# This function is non blocking and executed asynchronously with respect to the host.
# It may return before the actual computation has finished.
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   // Sparse matrix in COO format (with unsorted column indices)
#   //     1 2 0 3 0
#   // A = 0 4 5 0 0
#   //     6 0 0 7 8
#   int hcooRowInd[8] = {0, 0, 0, 1, 1, 2, 2, 2};
#   int hcooColInd[8] = {0, 1, 3, 1, 2, 0, 3, 4};
#   float hcooVal[8]   = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};
# 
#   int m         = 3;
#   int n         = 5;
#   int nnz       = 8;
#   hipsparseIndexBase_t base = HIPSPARSE_INDEX_BASE_ZERO;
# 
#   int* dcooRowInd = nullptr;
#   int* dcooColInd = nullptr;
#   float* dcooVal = nullptr;
#   hipMalloc((void**)&dcooRowInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcooColInd, sizeof(int) * nnz);
#   hipMalloc((void**)&dcooVal, sizeof(float) * nnz);
# 
#   hipMemcpy(dcooRowInd, hcooRowInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcooColInd, hcooColInd, sizeof(int) * nnz, hipMemcpyHostToDevice);
#   hipMemcpy(dcooVal, hcooVal, sizeof(float) * nnz, hipMemcpyHostToDevice);
# 
#   size_t bufferSize;
#   hipsparseXcoosort_bufferSizeExt(handle, m, n, nnz, dcooRowInd, dcooColInd, &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   int* dperm = nullptr;
#   hipMalloc((void**)&dperm, sizeof(int) * nnz);
#   hipsparseCreateIdentityPermutation(handle, nnz, dperm);
# 
#   hipsparseXcoosortByColumn(handle, m, n, nnz, dcooRowInd, dcooColInd, dperm, dbuffer);
# 
#   float* dcooValSorted = nullptr;
#   hipMalloc((void**)&dcooValSorted, sizeof(float) * nnz);
#   hipsparseSgthr(handle, nnz, dcooVal, dcooValSorted, dperm, base);
# 
#   hipFree(dcooRowInd);
#   hipFree(dcooColInd);
#   hipFree(dcooVal);
#   hipFree(dcooValSorted);
#   hipFree(dperm);
# 
#   hipFree(dbuffer);
# 
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseXcoosortByColumn(void * handle,int m,int n,int nnz,int * cooRows,int * cooCols,int * P,void * pBuffer)


#  \ingroup conv_module
# \brief
# This function computes the the size of the user allocated temporary storage buffer used when converting a sparse
# GEBSR matrix to another sparse GEBSR matrix.
# 
# \details
# \p hipsparseXgebsr2gebsr_bufferSize returns the size of the temporary storage buffer
# that is required by hipsparseXgebsr2gebsrNnz() and hipsparseXgebsr2gebsr().
# The temporary storage buffer must be allocated by the user.
cdef hipsparseStatus_t hipsparseSgebsr2gebsr_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nb,int nnzb,void *const descrA,const float * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDimA,int colBlockDimA,int rowBlockDimC,int colBlockDimC,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDgebsr2gebsr_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nb,int nnzb,void *const descrA,const double * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDimA,int colBlockDimA,int rowBlockDimC,int colBlockDimC,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCgebsr2gebsr_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nb,int nnzb,void *const descrA,float2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDimA,int colBlockDimA,int rowBlockDimC,int colBlockDimC,int * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZgebsr2gebsr_bufferSize(void * handle,hipsparseDirection_t dirA,int mb,int nb,int nnzb,void *const descrA,double2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDimA,int colBlockDimA,int rowBlockDimC,int colBlockDimC,int * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief This function is used when converting a GEBSR sparse matrix \p A to another GEBSR sparse matrix \p C.
# Specifically, this function determines the number of non-zero blocks that will exist in \p C (stored using either a host
# or device pointer), and computes the row pointer array for \p C.
# 
# \details
# The routine does support asynchronous execution.
cdef hipsparseStatus_t hipsparseXgebsr2gebsrNnz(void * handle,hipsparseDirection_t dirA,int mb,int nb,int nnzb,void *const descrA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDimA,int colBlockDimA,void *const descrC,int * bsrRowPtrC,int rowBlockDimC,int colBlockDimC,int * nnzTotalDevHostPtr,void * buffer)


#  \ingroup conv_module
# \brief
# This function converts the GEBSR sparse matrix \p A to another GEBSR sparse matrix \p C.
# 
# \details
# The conversion uses three steps. First, the user calls hipsparseXgebsr2gebsr_bufferSize() to determine the size of
# the required temporary storage buffer. The user then allocates this buffer. Secondly, the user then allocates \p mbC+1
# integers for the row pointer array for \p C where:
# \f[
#   \begin{align}
#   \text{mbC} &= \text{(m - 1) / rowBlockDimC + 1} \\
#   \text{nbC} &= \text{(n - 1) / colBlockDimC + 1}
#   \end{align}
# \f]
# The user then calls hipsparseXgebsr2gebsrNnz() to fill in the row pointer array for \p C ( \p bsrRowPtrC ) and
# determine the number of non-zero blocks that will exist in \p C. Finally, the user allocates space for the column
# indices array of \p C to have \p nnzbC elements and space for the values array of \p C to have
# \p nnzbC*rowBlockDimC*colBlockDimC and then calls hipsparseXgebsr2gebsr() to complete the conversion.
# 
# It may be the case that \p rowBlockDimC does not divide evenly into \p m and/or \p colBlockDim does not divide evenly
# into \p n. In these cases, the GEBSR matrix is expanded in size in order to fit full GEBSR blocks. For example, if
# the original GEBSR matrix A (using \p rowBlockDimA=2, \p colBlockDimA=3) looks like:
# 
# \f[
#  \left[
#   \begin{array}{c | c}
#     \begin{array}{c c c}
#      1 & 0 & 0 \\
#      3 & 4 & 0
#     \end{array} &
#     \begin{array}{c c c}
#      2 & 0 & 0 \\
#      4 & 5 & 6
#     \end{array} \\
#   \hline
#     \begin{array}{c c c}
#      1 & 2 & 3 \\
#      1 & 2 & 0
#     \end{array} &
#     \begin{array}{c c c}
#      4 & 0 & 0 \\
#      3 & 0 & 1
#     \end{array} \\
#  \end{array}
# \right]
# \f]
# 
# then if we specify \p rowBlockDimC=3 and \p colBlockDimC=2, our output GEBSR matrix C would be:
# 
# \f[
#  \left[
#   \begin{array}{c | c | c}
#     \begin{array}{c c}
#      1 & 0 \\
#      3 & 4 \\
#      1 & 2
#     \end{array} &
#     \begin{array}{c c}
#      0 & 2 \\
#      0 & 4 \\
#      3 & 4
#     \end{array} &
#     \begin{array}{c c}
#      0 & 0 \\
#      5 & 6 \\
#      0 & 0
#     \end{array} \\
#   \hline
#     \begin{array}{c c}
#      1 & 2 \\
#      0 & 0 \\
#      0 & 0
#     \end{array} &
#     \begin{array}{c c}
#      0 & 3 \\
#      0 & 0 \\
#      0 & 0
#     \end{array} &
#     \begin{array}{c c}
#      0 & 1 \\
#      0 & 0 \\
#      0 & 0
#     \end{array} \\
#  \end{array}
# \right]
# \f]
# 
# \par Example
# \code{.c}
#   // hipSPARSE handle
#   hipsparseHandle_t handle;
#   hipsparseCreate(&handle);
# 
#   hipsparseMatDescr_t descrA;
#   hipsparseCreateMatDescr(&descrA);
# 
#   hipsparseMatDescr_t descrC;
#   hipsparseCreateMatDescr(&descrC);
# 
#   // Sparse matrix in BSR format
#   //     1 2 | 0 3 | 0 0
#   //     0 4 | 5 0 | 0 1
#   // A = 6 0 | 0 7 | 8 0
#   //     ---------------
#   //     0 0 | 3 0 | 2 2
#   //     1 0 | 0 0 | 4 3
#   //     7 2 | 0 0 | 1 4
#   int hbsrRowPtrA[3] = {0, 3, 6};
#   int hbsrColIndA[6] = {0, 1, 2, 0, 1, 2};
#   float hbsrValA[36]  = {1.0f, 2.0f, 0.0f, 4.0f, 6.0f, 0.0f,
#                          0.0f, 3.0f, 5.0f, 0.0f, 0.0f, 7.0f,
#                          0.0f, 0.0f, 0.0f, 1.0f, 8.0f, 0.0f,
#                          0.0f, 0.0f, 1.0f, 0.0f, 7.0f, 2.0f,
#                          3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f,
#                          2.0f, 2.0f, 4.0f, 3.0f, 1.0f, 4.0f};
# 
#   int m           = 6;
#   int n           = 6;
#   int rowBlockDimA = 3;
#   int colBlockDimA = 2;
#   int rowBlockDimC = 2;
#   int colBlockDimC = 2;
#   hipsparseDirection_t dirA = HIPSPARSE_DIRECTION_ROW;
# 
#   int mbA   = (m + rowBlockDimA - 1) / rowBlockDimA;
#   int nbA   = (n + colBlockDimA - 1) / colBlockDimA;
#   int nnzbA = 6;
# 
#   int mbC   = (m + rowBlockDimC - 1) / rowBlockDimC;
#   int nbC   = (n + colBlockDimC - 1) / colBlockDimC;
# 
#   int* dbsrRowPtrA = nullptr;
#   int* dbsrColIndA = nullptr;
#   float* dbsrValA = nullptr;
#   hipMalloc((void**)&dbsrRowPtrA, sizeof(int) * (mbA + 1));
#   hipMalloc((void**)&dbsrColIndA, sizeof(int) * nnzbA);
#   hipMalloc((void**)&dbsrValA, sizeof(float) * rowBlockDimA * colBlockDimA * nnzbA);
# 
#   hipMemcpy(dbsrRowPtrA, hbsrRowPtrA, sizeof(int) * (mbA + 1), hipMemcpyHostToDevice);
#   hipMemcpy(dbsrColIndA, hbsrColIndA, sizeof(int) * nnzbA, hipMemcpyHostToDevice);
#   hipMemcpy(dbsrValA, hbsrValA, sizeof(float) * rowBlockDimA * colBlockDimA * nnzbA, hipMemcpyHostToDevice);
# 
#   int* dbsrRowPtrC = nullptr;
#   hipMalloc((void**)&dbsrRowPtrC, sizeof(int) * (mbC + 1));
# 
#   size_t bufferSize;
#   hipsparseSgebsr2gebsr_bufferSize(handle,
#                                    dirA,
#                                    mbA,
#                                    nbA,
#                                    nnzbA,
#                                    descrA,
#                                    dbsrValA,
#                                    dbsrRowPtrA,
#                                    dbsrColIndA,
#                                    rowBlockDimA,
#                                    colBlockDimA,
#                                    rowBlockDimC,
#                                    colBlockDimC,
#                                    &bufferSize);
# 
#   void* dbuffer = nullptr;
#   hipMalloc((void**)&dbuffer, bufferSize);
# 
#   int nnzbC;
#   hipsparseXgebsr2gebsrNnz(handle,
#                            dirA,
#                            mbA,
#                            nbA,
#                            nnzbA,
#                            descrA,
#                            dbsrRowPtrA,
#                            dbsrColIndA,
#                            rowBlockDimA,
#                            colBlockDimA,
#                            descrC,
#                            dbsrRowPtrC,
#                            rowBlockDimC,
#                            colBlockDimC,
#                            &nnzbC,
#                            dbuffer);
# 
#   hipDeviceSynchronize();
# 
#   int* dbsrColIndC = nullptr;
#   float* dbsrValC = nullptr;
#   hipMalloc((void**)&dbsrColIndC, sizeof(int) * nnzbC);
#   hipMalloc((void**)&dbsrValC, sizeof(float) * rowBlockDimC * colBlockDimC * nnzbC);
# 
#   hipsparseSgebsr2gebsr(handle,
#                         dirA,
#                         mbA,
#                         nbA,
#                         nnzbA,
#                         descrA,
#                         dbsrValA,
#                         dbsrRowPtrA,
#                         dbsrColIndA,
#                         rowBlockDimA,
#                         colBlockDimA,
#                         descrC,
#                         dbsrValC,
#                         dbsrRowPtrC,
#                         dbsrColIndC,
#                         rowBlockDimC,
#                         colBlockDimC,
#                         dbuffer);
# 
#   hipFree(dbsrRowPtrA);
#   hipFree(dbsrColIndA);
#   hipFree(dbsrValA);
# 
#   hipFree(dbsrRowPtrC);
#   hipFree(dbsrColIndC);
#   hipFree(dbsrValC);
# 
#   hipFree(dbuffer);
# 
#   hipsparseDestroyMatDescr(descrA);
#   hipsparseDestroyMatDescr(descrC);
#   hipsparseDestroy(handle);
# \endcode
cdef hipsparseStatus_t hipsparseSgebsr2gebsr(void * handle,hipsparseDirection_t dirA,int mb,int nb,int nnzb,void *const descrA,const float * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDimA,int colBlockDimA,void *const descrC,float * bsrValC,int * bsrRowPtrC,int * bsrColIndC,int rowBlockDimC,int colBlockDimC,void * buffer)



cdef hipsparseStatus_t hipsparseDgebsr2gebsr(void * handle,hipsparseDirection_t dirA,int mb,int nb,int nnzb,void *const descrA,const double * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDimA,int colBlockDimA,void *const descrC,double * bsrValC,int * bsrRowPtrC,int * bsrColIndC,int rowBlockDimC,int colBlockDimC,void * buffer)



cdef hipsparseStatus_t hipsparseCgebsr2gebsr(void * handle,hipsparseDirection_t dirA,int mb,int nb,int nnzb,void *const descrA,float2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDimA,int colBlockDimA,void *const descrC,float2 * bsrValC,int * bsrRowPtrC,int * bsrColIndC,int rowBlockDimC,int colBlockDimC,void * buffer)



cdef hipsparseStatus_t hipsparseZgebsr2gebsr(void * handle,hipsparseDirection_t dirA,int mb,int nb,int nnzb,void *const descrA,double2 * bsrValA,const int * bsrRowPtrA,const int * bsrColIndA,int rowBlockDimA,int colBlockDimA,void *const descrC,double2 * bsrValC,int * bsrRowPtrC,int * bsrColIndC,int rowBlockDimC,int colBlockDimC,void * buffer)


#  \ingroup conv_module
# \brief
# This function calculates the amount of temporary storage in bytes required for
# hipsparseXcsru2csr() and hipsparseXcsr2csru().
cdef hipsparseStatus_t hipsparseScsru2csr_bufferSizeExt(void * handle,int m,int n,int nnz,float * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDcsru2csr_bufferSizeExt(void * handle,int m,int n,int nnz,double * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseCcsru2csr_bufferSizeExt(void * handle,int m,int n,int nnz,float2 * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseZcsru2csr_bufferSizeExt(void * handle,int m,int n,int nnz,double2 * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,unsigned long * pBufferSizeInBytes)


#  \ingroup conv_module
# \brief
# This function converts unsorted CSR format to sorted CSR format. The required
# temporary storage has to be allocated by the user.
cdef hipsparseStatus_t hipsparseScsru2csr(void * handle,int m,int n,int nnz,void *const descrA,float * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsru2csr(void * handle,int m,int n,int nnz,void *const descrA,double * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsru2csr(void * handle,int m,int n,int nnz,void *const descrA,float2 * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsru2csr(void * handle,int m,int n,int nnz,void *const descrA,double2 * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,void * pBuffer)


#  \ingroup conv_module
# \brief
# This function converts sorted CSR format to unsorted CSR format. The required
# temporary storage has to be allocated by the user.
cdef hipsparseStatus_t hipsparseScsr2csru(void * handle,int m,int n,int nnz,void *const descrA,float * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,void * pBuffer)



cdef hipsparseStatus_t hipsparseDcsr2csru(void * handle,int m,int n,int nnz,void *const descrA,double * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,void * pBuffer)



cdef hipsparseStatus_t hipsparseCcsr2csru(void * handle,int m,int n,int nnz,void *const descrA,float2 * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,void * pBuffer)



cdef hipsparseStatus_t hipsparseZcsr2csru(void * handle,int m,int n,int nnz,void *const descrA,double2 * csrVal,const int * csrRowPtr,int * csrColInd,csru2csrInfo_t info,void * pBuffer)


#  \ingroup reordering_module
# \brief Coloring of the adjacency graph of the matrix \f$A\f$ stored in the CSR format.
# 
# \details
# \p hipsparseXcsrcolor performs the coloring of the undirected graph represented by the (symmetric) sparsity pattern of the matrix \f$A\f$ stored in CSR format. Graph coloring is a way of coloring the nodes of a graph such that no two adjacent nodes are of the same color. The \p fraction_to_color is a parameter to only color a given percentage of the graph nodes, the remaining uncolored nodes receive distinct new colors. The optional \p reordering array is a permutation array such that unknowns of the same color are grouped. The matrix \f$A\f$ must be stored as a general matrix with a symmetric sparsity pattern, and if the matrix \f$A\f$ is non-symmetric then the user is responsible to provide the symmetric part \f$\frac{A+A^T}{2}\f$.
cdef hipsparseStatus_t hipsparseScsrcolor(void * handle,int m,int nnz,void *const descrA,const float * csrValA,const int * csrRowPtrA,const int * csrColIndA,const float * fractionToColor,int * ncolors,int * coloring,int * reordering,void * info)



cdef hipsparseStatus_t hipsparseDcsrcolor(void * handle,int m,int nnz,void *const descrA,const double * csrValA,const int * csrRowPtrA,const int * csrColIndA,const double * fractionToColor,int * ncolors,int * coloring,int * reordering,void * info)



cdef hipsparseStatus_t hipsparseCcsrcolor(void * handle,int m,int nnz,void *const descrA,float2 * csrValA,const int * csrRowPtrA,const int * csrColIndA,const float * fractionToColor,int * ncolors,int * coloring,int * reordering,void * info)



cdef hipsparseStatus_t hipsparseZcsrcolor(void * handle,int m,int nnz,void *const descrA,double2 * csrValA,const int * csrRowPtrA,const int * csrColIndA,const double * fractionToColor,int * ncolors,int * coloring,int * reordering,void * info)


cdef extern from "hipsparse/hipsparse.h":

    ctypedef void * hipsparseSpVecDescr_t

    ctypedef void * hipsparseDnVecDescr_t

    ctypedef void * hipsparseSpMatDescr_t

    ctypedef void * hipsparseDnMatDescr_t

    ctypedef const void * hipsparseConstSpVecDescr_t

    ctypedef const void * hipsparseConstDnVecDescr_t

    ctypedef const void * hipsparseConstSpMatDescr_t

    ctypedef const void * hipsparseConstDnMatDescr_t

    cdef struct hipsparseSpGEMMDescr:
        pass

    cdef struct hipsparseSpSVDescr:
        pass

    cdef struct hipsparseSpSMDescr:
        pass

    ctypedef hipsparseSpGEMMDescr * hipsparseSpGEMMDescr_t

    ctypedef hipsparseSpSVDescr * hipsparseSpSVDescr_t

    ctypedef hipsparseSpSMDescr * hipsparseSpSMDescr_t

    ctypedef enum hipsparseFormat_t:
        HIPSPARSE_FORMAT_CSR
        HIPSPARSE_FORMAT_CSC
        HIPSPARSE_FORMAT_COO
        HIPSPARSE_FORMAT_COO_AOS
        HIPSPARSE_FORMAT_BLOCKED_ELL

    ctypedef enum hipsparseOrder_t:
        HIPSPARSE_ORDER_COLUMN
        HIPSPARSE_ORDER_COL
        HIPSPARSE_ORDER_ROW

    ctypedef enum hipsparseIndexType_t:
        HIPSPARSE_INDEX_16U
        HIPSPARSE_INDEX_32I
        HIPSPARSE_INDEX_64I

    ctypedef enum hipsparseSpMVAlg_t:
        HIPSPARSE_MV_ALG_DEFAULT
        HIPSPARSE_COOMV_ALG
        HIPSPARSE_CSRMV_ALG1
        HIPSPARSE_CSRMV_ALG2
        HIPSPARSE_SPMV_ALG_DEFAULT
        HIPSPARSE_SPMV_COO_ALG1
        HIPSPARSE_SPMV_CSR_ALG1
        HIPSPARSE_SPMV_CSR_ALG2
        HIPSPARSE_SPMV_COO_ALG2

    ctypedef enum hipsparseSpMMAlg_t:
        HIPSPARSE_MM_ALG_DEFAULT
        HIPSPARSE_COOMM_ALG1
        HIPSPARSE_COOMM_ALG2
        HIPSPARSE_COOMM_ALG3
        HIPSPARSE_CSRMM_ALG1
        HIPSPARSE_SPMM_ALG_DEFAULT
        HIPSPARSE_SPMM_COO_ALG1
        HIPSPARSE_SPMM_COO_ALG2
        HIPSPARSE_SPMM_COO_ALG3
        HIPSPARSE_SPMM_COO_ALG4
        HIPSPARSE_SPMM_CSR_ALG1
        HIPSPARSE_SPMM_CSR_ALG2
        HIPSPARSE_SPMM_CSR_ALG3
        HIPSPARSE_SPMM_BLOCKED_ELL_ALG1

    ctypedef enum hipsparseSparseToDenseAlg_t:
        HIPSPARSE_SPARSETODENSE_ALG_DEFAULT

    ctypedef enum hipsparseDenseToSparseAlg_t:
        HIPSPARSE_DENSETOSPARSE_ALG_DEFAULT

    ctypedef enum hipsparseSDDMMAlg_t:
        HIPSPARSE_SDDMM_ALG_DEFAULT

    ctypedef enum hipsparseSpSVAlg_t:
        HIPSPARSE_SPSV_ALG_DEFAULT

    ctypedef enum hipsparseSpSMAlg_t:
        HIPSPARSE_SPSM_ALG_DEFAULT

    ctypedef enum hipsparseSpMatAttribute_t:
        HIPSPARSE_SPMAT_FILL_MODE
        HIPSPARSE_SPMAT_DIAG_TYPE

    ctypedef enum hipsparseSpGEMMAlg_t:
        HIPSPARSE_SPGEMM_DEFAULT
        HIPSPARSE_SPGEMM_CSR_ALG_DETERMINISTIC
        HIPSPARSE_SPGEMM_CSR_ALG_NONDETERMINISTIC
        HIPSPARSE_SPGEMM_ALG1
        HIPSPARSE_SPGEMM_ALG2
        HIPSPARSE_SPGEMM_ALG3


cdef hipsparseStatus_t hipsparseCreateSpVec(void ** spVecDescr,long size,long nnz,void * indices,void * values,hipsparseIndexType_t idxType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseCreateConstSpVec(const void ** spVecDescr,long size,long nnz,const void * indices,const void * values,hipsparseIndexType_t idxType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseDestroySpVec(const void * spVecDescr)



cdef hipsparseStatus_t hipsparseSpVecGet(void *const spVecDescr,long * size,long * nnz,void ** indices,void ** values,hipsparseIndexType_t * idxType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseConstSpVecGet(const void * spVecDescr,long * size,long * nnz,const void ** indices,const void ** values,hipsparseIndexType_t * idxType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseSpVecGetIndexBase(const void *const spVecDescr,hipsparseIndexBase_t * idxBase)



cdef hipsparseStatus_t hipsparseSpVecGetValues(void *const spVecDescr,void ** values)



cdef hipsparseStatus_t hipsparseConstSpVecGetValues(const void * spVecDescr,const void ** values)



cdef hipsparseStatus_t hipsparseSpVecSetValues(void * spVecDescr,void * values)



cdef hipsparseStatus_t hipsparseCreateCoo(void ** spMatDescr,long rows,long cols,long nnz,void * cooRowInd,void * cooColInd,void * cooValues,hipsparseIndexType_t cooIdxType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseCreateConstCoo(const void ** spMatDescr,long rows,long cols,long nnz,const void * cooRowInd,const void * cooColInd,const void * cooValues,hipsparseIndexType_t cooIdxType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseCreateCooAoS(void ** spMatDescr,long rows,long cols,long nnz,void * cooInd,void * cooValues,hipsparseIndexType_t cooIdxType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseCreateCsr(void ** spMatDescr,long rows,long cols,long nnz,void * csrRowOffsets,void * csrColInd,void * csrValues,hipsparseIndexType_t csrRowOffsetsType,hipsparseIndexType_t csrColIndType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseCreateConstCsr(const void ** spMatDescr,long rows,long cols,long nnz,const void * csrRowOffsets,const void * csrColInd,const void * csrValues,hipsparseIndexType_t csrRowOffsetsType,hipsparseIndexType_t csrColIndType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseCreateCsc(void ** spMatDescr,long rows,long cols,long nnz,void * cscColOffsets,void * cscRowInd,void * cscValues,hipsparseIndexType_t cscColOffsetsType,hipsparseIndexType_t cscRowIndType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseCreateConstCsc(const void ** spMatDescr,long rows,long cols,long nnz,const void * cscColOffsets,const void * cscRowInd,const void * cscValues,hipsparseIndexType_t cscColOffsetsType,hipsparseIndexType_t cscRowIndType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseCreateBlockedEll(void ** spMatDescr,long rows,long cols,long ellBlockSize,long ellCols,void * ellColInd,void * ellValue,hipsparseIndexType_t ellIdxType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseCreateConstBlockedEll(const void ** spMatDescr,long rows,long cols,long ellBlockSize,long ellCols,const void * ellColInd,const void * ellValue,hipsparseIndexType_t ellIdxType,hipsparseIndexBase_t idxBase,hipDataType valueType)



cdef hipsparseStatus_t hipsparseDestroySpMat(const void * spMatDescr)



cdef hipsparseStatus_t hipsparseCooGet(void *const spMatDescr,long * rows,long * cols,long * nnz,void ** cooRowInd,void ** cooColInd,void ** cooValues,hipsparseIndexType_t * idxType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseConstCooGet(const void * spMatDescr,long * rows,long * cols,long * nnz,const void ** cooRowInd,const void ** cooColInd,const void ** cooValues,hipsparseIndexType_t * idxType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseCooAoSGet(void *const spMatDescr,long * rows,long * cols,long * nnz,void ** cooInd,void ** cooValues,hipsparseIndexType_t * idxType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseCsrGet(void *const spMatDescr,long * rows,long * cols,long * nnz,void ** csrRowOffsets,void ** csrColInd,void ** csrValues,hipsparseIndexType_t * csrRowOffsetsType,hipsparseIndexType_t * csrColIndType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseConstCsrGet(const void * spMatDescr,long * rows,long * cols,long * nnz,const void ** csrRowOffsets,const void ** csrColInd,const void ** csrValues,hipsparseIndexType_t * csrRowOffsetsType,hipsparseIndexType_t * csrColIndType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseCscGet(void *const spMatDescr,long * rows,long * cols,long * nnz,void ** cscColOffsets,void ** cscRowInd,void ** cscValues,hipsparseIndexType_t * cscColOffsetsType,hipsparseIndexType_t * cscRowIndType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseConstCscGet(const void * spMatDescr,long * rows,long * cols,long * nnz,const void ** cscColOffsets,const void ** cscRowInd,const void ** cscValues,hipsparseIndexType_t * cscColOffsetsType,hipsparseIndexType_t * cscRowIndType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseBlockedEllGet(void *const spMatDescr,long * rows,long * cols,long * ellBlockSize,long * ellCols,void ** ellColInd,void ** ellValue,hipsparseIndexType_t * ellIdxType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseConstBlockedEllGet(const void * spMatDescr,long * rows,long * cols,long * ellBlockSize,long * ellCols,const void ** ellColInd,const void ** ellValue,hipsparseIndexType_t * ellIdxType,hipsparseIndexBase_t * idxBase,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseCsrSetPointers(void * spMatDescr,void * csrRowOffsets,void * csrColInd,void * csrValues)



cdef hipsparseStatus_t hipsparseCscSetPointers(void * spMatDescr,void * cscColOffsets,void * cscRowInd,void * cscValues)



cdef hipsparseStatus_t hipsparseCooSetPointers(void * spMatDescr,void * cooRowInd,void * cooColInd,void * cooValues)



cdef hipsparseStatus_t hipsparseSpMatGetSize(const void * spMatDescr,long * rows,long * cols,long * nnz)



cdef hipsparseStatus_t hipsparseSpMatGetFormat(const void * spMatDescr,hipsparseFormat_t * format)



cdef hipsparseStatus_t hipsparseSpMatGetIndexBase(const void * spMatDescr,hipsparseIndexBase_t * idxBase)



cdef hipsparseStatus_t hipsparseSpMatGetValues(void * spMatDescr,void ** values)



cdef hipsparseStatus_t hipsparseConstSpMatGetValues(const void * spMatDescr,const void ** values)



cdef hipsparseStatus_t hipsparseSpMatSetValues(void * spMatDescr,void * values)



cdef hipsparseStatus_t hipsparseSpMatGetStridedBatch(const void * spMatDescr,int * batchCount)



cdef hipsparseStatus_t hipsparseSpMatSetStridedBatch(void * spMatDescr,int batchCount)



cdef hipsparseStatus_t hipsparseCooSetStridedBatch(void * spMatDescr,int batchCount,long batchStride)



cdef hipsparseStatus_t hipsparseCsrSetStridedBatch(void * spMatDescr,int batchCount,long offsetsBatchStride,long columnsValuesBatchStride)



cdef hipsparseStatus_t hipsparseSpMatGetAttribute(const void * spMatDescr,hipsparseSpMatAttribute_t attribute,void * data,unsigned long dataSize)



cdef hipsparseStatus_t hipsparseSpMatSetAttribute(void * spMatDescr,hipsparseSpMatAttribute_t attribute,const void * data,unsigned long dataSize)



cdef hipsparseStatus_t hipsparseCreateDnVec(void ** dnVecDescr,long size,void * values,hipDataType valueType)



cdef hipsparseStatus_t hipsparseCreateConstDnVec(const void ** dnVecDescr,long size,const void * values,hipDataType valueType)



cdef hipsparseStatus_t hipsparseDestroyDnVec(const void * dnVecDescr)



cdef hipsparseStatus_t hipsparseDnVecGet(void *const dnVecDescr,long * size,void ** values,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseConstDnVecGet(const void * dnVecDescr,long * size,const void ** values,hipDataType * valueType)



cdef hipsparseStatus_t hipsparseDnVecGetValues(void *const dnVecDescr,void ** values)



cdef hipsparseStatus_t hipsparseConstDnVecGetValues(const void * dnVecDescr,const void ** values)



cdef hipsparseStatus_t hipsparseDnVecSetValues(void * dnVecDescr,void * values)



cdef hipsparseStatus_t hipsparseCreateDnMat(void ** dnMatDescr,long rows,long cols,long ld,void * values,hipDataType valueType,hipsparseOrder_t order)



cdef hipsparseStatus_t hipsparseCreateConstDnMat(const void ** dnMatDescr,long rows,long cols,long ld,const void * values,hipDataType valueType,hipsparseOrder_t order)



cdef hipsparseStatus_t hipsparseDestroyDnMat(const void * dnMatDescr)



cdef hipsparseStatus_t hipsparseDnMatGet(void *const dnMatDescr,long * rows,long * cols,long * ld,void ** values,hipDataType * valueType,hipsparseOrder_t * order)



cdef hipsparseStatus_t hipsparseConstDnMatGet(const void * dnMatDescr,long * rows,long * cols,long * ld,const void ** values,hipDataType * valueType,hipsparseOrder_t * order)



cdef hipsparseStatus_t hipsparseDnMatGetValues(void *const dnMatDescr,void ** values)



cdef hipsparseStatus_t hipsparseConstDnMatGetValues(const void * dnMatDescr,const void ** values)



cdef hipsparseStatus_t hipsparseDnMatSetValues(void * dnMatDescr,void * values)



cdef hipsparseStatus_t hipsparseDnMatGetStridedBatch(const void * dnMatDescr,int * batchCount,long * batchStride)



cdef hipsparseStatus_t hipsparseDnMatSetStridedBatch(void * dnMatDescr,int batchCount,long batchStride)



cdef hipsparseStatus_t hipsparseAxpby(void * handle,const void * alpha,const void * vecX,const void * beta,void * vecY)



cdef hipsparseStatus_t hipsparseGather(void * handle,const void * vecY,void * vecX)



cdef hipsparseStatus_t hipsparseScatter(void * handle,const void * vecX,void * vecY)



cdef hipsparseStatus_t hipsparseRot(void * handle,const void * c_coeff,const void * s_coeff,void * vecX,void * vecY)



cdef hipsparseStatus_t hipsparseSparseToDense_bufferSize(void * handle,const void * matA,void * matB,hipsparseSparseToDenseAlg_t alg,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseSparseToDense(void * handle,const void * matA,void * matB,hipsparseSparseToDenseAlg_t alg,void * externalBuffer)



cdef hipsparseStatus_t hipsparseDenseToSparse_bufferSize(void * handle,const void * matA,void * matB,hipsparseDenseToSparseAlg_t alg,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseDenseToSparse_analysis(void * handle,const void * matA,void * matB,hipsparseDenseToSparseAlg_t alg,void * externalBuffer)



cdef hipsparseStatus_t hipsparseDenseToSparse_convert(void * handle,const void * matA,void * matB,hipsparseDenseToSparseAlg_t alg,void * externalBuffer)



cdef hipsparseStatus_t hipsparseSpVV_bufferSize(void * handle,hipsparseOperation_t opX,const void * vecX,const void * vecY,void * result,hipDataType computeType,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseSpVV(void * handle,hipsparseOperation_t opX,const void * vecX,const void * vecY,void * result,hipDataType computeType,void * externalBuffer)



cdef hipsparseStatus_t hipsparseSpMV_bufferSize(void * handle,hipsparseOperation_t opA,const void * alpha,const void * matA,const void * vecX,const void * beta,void *const vecY,hipDataType computeType,hipsparseSpMVAlg_t alg,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseSpMV_preprocess(void * handle,hipsparseOperation_t opA,const void * alpha,const void * matA,const void * vecX,const void * beta,void *const vecY,hipDataType computeType,hipsparseSpMVAlg_t alg,void * externalBuffer)



cdef hipsparseStatus_t hipsparseSpMV(void * handle,hipsparseOperation_t opA,const void * alpha,const void * matA,const void * vecX,const void * beta,void *const vecY,hipDataType computeType,hipsparseSpMVAlg_t alg,void * externalBuffer)



cdef hipsparseStatus_t hipsparseSpMM_bufferSize(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * matA,const void * matB,const void * beta,void *const matC,hipDataType computeType,hipsparseSpMMAlg_t alg,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseSpMM_preprocess(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * matA,const void * matB,const void * beta,void *const matC,hipDataType computeType,hipsparseSpMMAlg_t alg,void * externalBuffer)



cdef hipsparseStatus_t hipsparseSpMM(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * matA,const void * matB,const void * beta,void *const matC,hipDataType computeType,hipsparseSpMMAlg_t alg,void * externalBuffer)



cdef hipsparseStatus_t hipsparseSpGEMM_createDescr(hipsparseSpGEMMDescr_t* descr)



cdef hipsparseStatus_t hipsparseSpGEMM_destroyDescr(hipsparseSpGEMMDescr_t descr)



cdef hipsparseStatus_t hipsparseSpGEMM_workEstimation(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * matA,const void * matB,const void * beta,void * matC,hipDataType computeType,hipsparseSpGEMMAlg_t alg,hipsparseSpGEMMDescr_t spgemmDescr,unsigned long * bufferSize1,void * externalBuffer1)



cdef hipsparseStatus_t hipsparseSpGEMM_compute(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * matA,const void * matB,const void * beta,void * matC,hipDataType computeType,hipsparseSpGEMMAlg_t alg,hipsparseSpGEMMDescr_t spgemmDescr,unsigned long * bufferSize2,void * externalBuffer2)



cdef hipsparseStatus_t hipsparseSpGEMM_copy(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * matA,const void * matB,const void * beta,void * matC,hipDataType computeType,hipsparseSpGEMMAlg_t alg,hipsparseSpGEMMDescr_t spgemmDescr)



cdef hipsparseStatus_t hipsparseSpGEMMreuse_workEstimation(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * matA,const void * matB,void * matC,hipsparseSpGEMMAlg_t alg,hipsparseSpGEMMDescr_t spgemmDescr,unsigned long * bufferSize1,void * externalBuffer1)



cdef hipsparseStatus_t hipsparseSpGEMMreuse_nnz(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * matA,const void * matB,void * matC,hipsparseSpGEMMAlg_t alg,hipsparseSpGEMMDescr_t spgemmDescr,unsigned long * bufferSize2,void * externalBuffer2,unsigned long * bufferSize3,void * externalBuffer3,unsigned long * bufferSize4,void * externalBuffer4)



cdef hipsparseStatus_t hipsparseSpGEMMreuse_copy(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * matA,const void * matB,void * matC,hipsparseSpGEMMAlg_t alg,hipsparseSpGEMMDescr_t spgemmDescr,unsigned long * bufferSize5,void * externalBuffer5)



cdef hipsparseStatus_t hipsparseSpGEMMreuse_compute(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * matA,const void * matB,const void * beta,void * matC,hipDataType computeType,hipsparseSpGEMMAlg_t alg,hipsparseSpGEMMDescr_t spgemmDescr)



cdef hipsparseStatus_t hipsparseSDDMM_bufferSize(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * A,const void * B,const void * beta,void * C,hipDataType computeType,hipsparseSDDMMAlg_t alg,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseSDDMM_preprocess(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * A,const void * B,const void * beta,void * C,hipDataType computeType,hipsparseSDDMMAlg_t alg,void * tempBuffer)



cdef hipsparseStatus_t hipsparseSDDMM(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * A,const void * B,const void * beta,void * C,hipDataType computeType,hipsparseSDDMMAlg_t alg,void * tempBuffer)



cdef hipsparseStatus_t hipsparseSpSV_createDescr(hipsparseSpSVDescr_t* descr)



cdef hipsparseStatus_t hipsparseSpSV_destroyDescr(hipsparseSpSVDescr_t descr)



cdef hipsparseStatus_t hipsparseSpSV_bufferSize(void * handle,hipsparseOperation_t opA,const void * alpha,const void * matA,const void * x,void *const y,hipDataType computeType,hipsparseSpSVAlg_t alg,hipsparseSpSVDescr_t spsvDescr,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseSpSV_analysis(void * handle,hipsparseOperation_t opA,const void * alpha,const void * matA,const void * x,void *const y,hipDataType computeType,hipsparseSpSVAlg_t alg,hipsparseSpSVDescr_t spsvDescr,void * externalBuffer)



cdef hipsparseStatus_t hipsparseSpSV_solve(void * handle,hipsparseOperation_t opA,const void * alpha,const void * matA,const void * x,void *const y,hipDataType computeType,hipsparseSpSVAlg_t alg,hipsparseSpSVDescr_t spsvDescr)



cdef hipsparseStatus_t hipsparseSpSM_createDescr(hipsparseSpSMDescr_t* descr)



cdef hipsparseStatus_t hipsparseSpSM_destroyDescr(hipsparseSpSMDescr_t descr)



cdef hipsparseStatus_t hipsparseSpSM_bufferSize(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * matA,const void * matB,void *const matC,hipDataType computeType,hipsparseSpSMAlg_t alg,hipsparseSpSMDescr_t spsmDescr,unsigned long * pBufferSizeInBytes)



cdef hipsparseStatus_t hipsparseSpSM_analysis(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * matA,const void * matB,void *const matC,hipDataType computeType,hipsparseSpSMAlg_t alg,hipsparseSpSMDescr_t spsmDescr,void * externalBuffer)



cdef hipsparseStatus_t hipsparseSpSM_solve(void * handle,hipsparseOperation_t opA,hipsparseOperation_t opB,const void * alpha,const void * matA,const void * matB,void *const matC,hipDataType computeType,hipsparseSpSMAlg_t alg,hipsparseSpSMDescr_t spsmDescr,void * externalBuffer)
